{"pages":[{"title":"关于","text":"本人 Scarecrow41 ，菜，只会刨坟，理想是未来成为跨国连锁挖坟公司的 CEO 。 G r a v e   F o r   Y o u   A l l .","link":"/about/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"「Note」并查集","text":"定义 并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。 —— baidu 并查集一般包括两个操作： 查找 ： 寻找根节点 合并 ： 将同类的集合合并在一棵树上实现方法 使用 代表法，即每个集合选择一个固定的元素，将其作为整个集合的代表 通过维护数组 $fa[]$ 来表示两个集合之间的所属关系，即用$fa[x]$记录$x$的父节点。根节点的fa[]指向自己。 储存方式1.链表储存即使用一般的树形结构 1234567891011121314151617typedef struct node;typedef node * tree;struct node { int data, father;};tree bt;``` ### 2.数组储存即直接定义$fa[x]$为$x$的父节点;#### 2.1初始化```cppvoid MakeSet(int n) { for(int i = 1;i &lt;= n;i ++) { fa[i] = i;//每个节点的父节点都指向自己 rank[i] = 0;//保存高度 }} 2.2查找父节点12345int FindSet(int x) {//路径压缩版 if(fa[x] != x) fa[x] = FindSet(fa[x]); return fa[x];} 2.3合并集合123456789101112void UnionSet(int x, int y){ int u = FindSet(x); int v = FindSet(y); if(u == v) return; //已经在同一个集合之中 if(rank[u] &gt; rank[v]) fa[v] = u; else { fa[u] = v; if(rank[u] == rank[v]) rank[v] ++; } }","link":"/2020/06/21/2020-06-21-%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"title":"「Solution」老鼠与猫的交易","text":"题目描述有一只老鼠很喜欢奶酪，但是奶酪被分别放在N个房间里，而且这些房间都有一只猫咪看守，现在它准备和猫咪们做个交易。它有M磅的猫食，想用这M磅猫食换取奶酪。在猫咪看守的每一个房间里有奶酪J[i] 磅，同时猫咪需要F[i]磅的食物，如果老鼠给猫咪F[i] * (a)%的猫食，那么它就可以得到J[i] * (a)%的奶酪。现在已知每只猫咪对猫食的需求量和每个房间的奶酪数，那老鼠怎样才能换得最多的奶酪呢？ 输入格式第一行输入两个正整数M和N（M和N不大于10000），后面跟N行（每个房间的奶酪数和猫食的需求量）。 输出格式输出老鼠得到的最多的奶酪数，保留三位小数。 样例样例1输入5 37 24 35 2样例1输出13.333样例2输入20 325 1824 1515 10样例2输出31.500 分析典型的贪心，一道性价比问题，即需要在有限的总钱数下得到更高价格的商品，在输入时求出物价，并按从高到低排序即可。 具体实现123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10005; struct node{ double j, f, p;//定义成double更方便};node a[MAXN];int n, m;double ans;bool cmp(node x, node y) {//按性价比从搞到低排序 return x.p &gt; y.p; }int main() { scanf(&quot;%d %d&quot;, &amp;m, &amp;n); for(int i = 1;i &lt;= n; i++) { scanf(&quot;%lf %lf&quot;, &amp;a[i].j, &amp;a[i].f); a[i].p = a[i].j / a[i].f;//求性价比 } sort(a + 1, a + 1 + n, cmp); for(int i = 1;i &lt;= n; i++) {//统计 if(m &gt;= a[i].f) {//如果奶酪没有用完 m -= a[i].f; ans += a[i].j; } else { ans += a[i].p * m; break; } } printf(&quot;%.3lf\\n&quot;, ans); return 0;}","link":"/2020/07/05/2020-07-05-%E8%B4%AA%E5%BF%83%20-%20%E8%80%81%E9%BC%A0%E4%B8%8E%E7%8C%AB%E7%9A%84%E4%BA%A4%E6%98%93/"},{"title":"「Note」拓扑排序","text":"拓扑排序拓扑排序是对一张 有向 并且 无环 的图进行遍历排序。如果在图中所有的节点构成的序列$A$中，对于每一条边$(x, y)$：$x$都出现在$y$的前面，则序列$A$就为这张图的拓扑序。 关于入度和出度入度 ：以节点$x$为终点的有向边的条数被称为$x$的入度。记作 $deg(x)$ .出度 ：以节点$x$为起点的有向边的条数被称为$x$的出度。例如在此图中，节点3的入度就为2 ，节点4的入度也为2. 思想不断选择图中入度为0的节点入队（如上图中的节点5、2、 1）。再将$x$连向的节点的入度减一。 实现1.建一个空的拓扑序列$A$。2.预处理入度，将入度是0的节点全部入队。3.取出队头，此时的对头$x$一定是入度为0的节点，所以$A[++ cnt] = x;$4.对于此时的队头$x$，把所连的$y$的入度减一，即$deg[y] –;$5.操作至队列为空，此时$A[]$则为这张图的拓扑排序。6.在最后将$A[]$的长度检查以下，即看此时的$cnt$是否为图中的节点个数，如果少于了节点数，则说明图中有环。 图示初始图1.建立空序列2.2.预处理入度，将入度是0的节点全部入队。3.取出队头，此时的对头$x$一定是入度为0的节点，所以$A[++ cnt] = x;$4.对于此时的队头$x$，把所连的$y$的入度减一，即$deg[y] –;$5.操作至队列为空，此时$A[]$则为这张图的拓扑排序。 6.在最后将$A[]$的长度检查以下，即看此时的$cnt$是否为图中的节点个数，此时发现少了三个节点，所以图中含有环，即$(2, 4) (4, 6)(6, 2)$。 代码本人太菜了，邻接表出了点玄学错误，就只能用矩阵。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10005;int n, m, cnt;bool a[MAXN][MAXN];int deg[MAXN], ans[MAXN];queue&lt;int&gt; q;void topsort(void) { for (int i = 1; i &lt;= n; i++) if (deg[i] == 0) q.push(i); while (!q.empty()) { const int u = q.front(); ans[++cnt] = u; q.pop(); for (int i = 1; i &lt;= n; i++) if (a[u][i]) { deg[i]--; if (deg[i] == 0) q.push(i); } }}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); a[x][y] = 1; deg[y]++; } topsort(); if (cnt &lt; n) { printf(&quot;no solution\\n&quot;); } else { for (int i = 1; i &lt;= cnt; i++) { printf(&quot;%d &quot;, ans[i]); } } return 0;}","link":"/2020/07/11/2020-07-07-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"「Solution」火柴排队","text":"火柴排队 内存限制：128 MiB时间限制：1000 ms 题目描述涵涵有两盒火柴，每盒装有n 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为： $∑(ai-bi)^2$其中 ai 表示第一列火柴中第 i 个火柴的高度，bi 表示第二列火柴中第 i 个火柴的高度。每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。 请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 99,999,997 取模的结果。 输入格式共三行，第一行包含一个整数 n，表示每盒中火柴的数目。 第二行有 n 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。 第三行有 n 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。 输出格式输出共一行，包含一个整数，表示最少交换次数对 99,999,997 取模的结果。 样例样例1输入42 3 1 43 2 1 4样例1输出1样例2输入41 3 4 21 7 2 4样例2输出2 数据范围与提示输入输出样例说明1： 最小距离是 0，最少需要交换 1 次，比如：交换第 1 列的前 2 根火柴或者交换第 2 列的前 2 根火柴。 输入输出样例说明2： 最小距离是 10，最少需要交换 2 次，比如：交换第 1 列的中间 2 根火柴的位置，再交换第 2 列中后 2 根火柴的位置。 数据范围：对于 10%的数据， 1 ≤ n ≤ 10；对于 30%的数据，1 ≤ n ≤ 100；对于 60%的数据，1 ≤ n ≤ 1,000；对于 100%的数据，1 ≤ n ≤ 100,000，0 ≤火柴高度≤ maxlongint 分析感谢C202207LYX提出问题，现将证明给出。这是一道比较有意思的题目。如果要使$∑(ai-bi)^2$最小，那么$(ai-bi)$的值就因该为最小，为了保证所有$(ai-bi)$的总值最小，就需要让序列$A$中的第$k$个数对应序列$B$的第$k$个数。可以得出一个结论就是同序和≥乱序和≥逆序和证明：设有序数列k1kn,p1pn，取k1&lt;k2、p1&lt;p2 因此容易得到：k1p1+k2p2&gt;k1p2+k2p1; 将上述不等式变形一下： k2p2-k2p1&gt;k1p2-k1p1 即k2(p2-p1)&gt;k1(p2-p1) ∵k2&gt;k1,p2&gt;p1 ∴k2(p2-p1)&gt;k1(p2-p1) 证毕； 推广2中的结论到1中，乱序就是不断将顺序交换打乱的过程，最终结果符合2的结论，因此 顺序之乘&gt;=乱序之乘，证毕 同序操作首先定义一个结构体:$node$ 123struct node { LL val, num;}; 这里引入一个思想——离散化。通过数据范围，可以得知：1 ≤ n ≤ 100,000，&amp;&amp; 0 ≤火柴高度≤ maxlongint，也就是说，火柴的高度分布比较稀疏，并且如果排序，那么$long$ $long$会直接溢出。、此时接需要离散化 离散化定义：离散化，把无限空间中有限的个体映射到有限的空间中去，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：原数据：$1,999,100000,15$；处理后：$1,3,4,2；$原数据：${100,200}，{20,50000}，{1,400}；$处理后：${3,4}，{2,6}，{1,5}；$ 此时可以通过$node$中的$num$实现对数据离散化的操作。警示：简单的离散化不能去重但在此题中必然会有相同的元素出现因为是毒瘤数据所以可以通过先保存下标，再根据$val$的大小$sort$。给出参考代码： 12345678910111213141516bool cmp(node x, node y) { if(x.val == y.val) return x.num &lt; y.num; return x.val &lt; y.val;}for(LL i = 1;i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a[i].val); a[i].num = i;} for(LL i = 1;i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;b[i].val); b[i].num = i;}sort(a + 1, a + 1 + n, cmp);sort(b + 1, b + 1 + n, cmp); 然后经行同序排列。假设我们离散化之后得到了这样两个序列：$A:(1,3,4,2)和B:(1,4,2,3)$我们以$a[i]$为关键字对$b[i]$排序，令$x[a[i]]=b[i]$，在$a$和$b$中构造一种映射关系。若序列$a$与序列$b$相等，那么此时$x[a[i]]$应该等于$a[i]$的，也就是$x[i]=i$。那么也就是说如果我们想让序列$a$与序列$b$相等，那么我们需要让$x$升序排列。问题就变为，将原本乱的$X$序列升序排列的最少交换次数。我们会得到：$x[1]=1,x[3]=4,x[4]=2,x[2]=3$，x序列就是这样的：$(1,4,2,3)$。哪里是“乱”的，就调整哪里。$(4,2)$和$(4,3)$是“乱”的，调整这两处即可。也就是说，要维护这个例子中的这两个序列的“距离”最小值，我们最少只需要调整2次即可。在这里就是一组逆序对。有几个逆序对，就要调整几次。那么这题可以最终得到一个结论：在$X$序列中逆序对的个数就是本题的答案。 逆序对求逆序对一共有三种方法： 1.暴力枚举$O(n^2)$只能得到80pts。 123456for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) if (x[i] &gt; x[j]) { ans++; ans %= MOD; } 2.归并排序$O(logn)$ 123456789101112131415161718192021void merge(LL L, LL R, LL Mid){ LL i = L;LL j = Mid + 1;LL k = L; while(i &lt;= Mid &amp;&amp; j &lt;= R){ if(x[i] &lt;= x[j])t[k ++] = x[i ++]; else{ ans += Mid - i + 1; ans %= MOD; t[k ++] = x[j ++]; } } while(i &lt;= Mid)t[k ++] = x[i ++]; while(j &lt;= R)t[k ++] = x[j ++]; for(i = L; i &lt;= R; i ++)x[i] = t[i]; }void mergesort(LL L, LL R){ if(L &lt; R){ LL Mid = (L + R) / 2; mergesort(L, Mid),mergesort(Mid + 1, R); merge(L, R, Mid); }} 3.树状数组我太菜了。。。还没学会。。。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 100005;const int MOD = 99999997;struct node { LL val, num;};LL n, ans, x[MAXN], t[MAXN];node a[MAXN], b[MAXN];bool cmp(node x, node y) { if(x.val == y.val) return x.num &lt; y.num; return x.val &lt; y.val;}void merge(LL L, LL R, LL Mid){ LL i = L;LL j = Mid + 1;LL k = L; while(i &lt;= Mid &amp;&amp; j &lt;= R){ if(x[i] &lt;= x[j])t[k ++] = x[i ++]; else{ ans += Mid - i + 1; ans %= MOD; t[k ++] = x[j ++]; } } while(i &lt;= Mid)t[k ++] = x[i ++]; while(j &lt;= R)t[k ++] = x[j ++]; for(i = L; i &lt;= R; i ++)x[i] = t[i]; }void mergesort(LL L, LL R){ if(L &lt; R){ LL Mid = (L + R) / 2; mergesort(L, Mid),mergesort(Mid + 1, R); merge(L, R, Mid); }}int main() { scanf(&quot;%lld&quot;, &amp;n); for(LL i = 1;i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a[i].val); a[i].num = i; } for(LL i = 1;i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;b[i].val); b[i].num = i; } sort(a + 1, a + 1 + n, cmp); sort(b + 1, b + 1 + n, cmp); for(LL i = 1;i &lt;= n; i++) { x[a[i].num] = b[i].num; } mergesort(1, n); printf(&quot;%lld\\n&quot;, ans % MOD); return 0;}","link":"/2020/07/12/2020-07-12-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F%20%E8%AF%A6%E8%A7%A3/"},{"title":"「Solution」分离与合体","text":"题目描述经过在机房里数日的切磋，LYD 从杜神牛那里学会了分离与合体，出关前，杜神牛给了他一个测试……杜神牛造了n 个区域，他们紧邻着排成一行，编号 1 ~ n 。在每个区域里都放着一把 OI 界的金钥匙，每一把都有一定的价值，LYD 当然想得到他们了。然而杜神牛规定 LYD 不能一下子把他们全部拿走，而是每次只可以拿一把。为了尽快得到所有金钥匙，LYD 自然就用上了刚学的分离与合体特技。一开始 LYD 可以选择 1 … n - 1 中的任何一个区域进入，我们不妨把这个区域记为k 。进入后 LYD 会在 区域发生分离，从而分离成两个小 LYD。分离完成的同时会有一面墙在 k 区域和 k + 1 区域间升起，从而把1…k 和 k + 1 … n 阻断成两个独立的区间，并在各自区间内任选除区间末尾之外（即从 1..k-1 和 k+1…n-1中选取）的任意一个区域再次发生分离，这样就有了四个小小 LYD……重复以上所叙述的分离，直到每个小 LYD 发现自己所在的区间只剩下了一个区域，那么他们就可以抱起自己梦寐以求的 OI 金钥匙。但是 LYD 不能就分成这么多个个体存在于世界上，这些小 LYD 还会再合体，合体的小 LYD 所在区间中间的墙会消失。合体会获得 合并后所在区间左右端区域里金钥匙价值之和之前分离的时候所在区域的金钥匙价值。LYD 请你编程求出最终可以获得的最大总价值，并按照分离阶段从前到后，区域从左到右的顺序，输出发生分离区域编号。若有多种方案，选择分离区域尽量靠左的方案（也可以理解为输出字典序最小的）。例如先打印一分为二的区域，然后从左到右打印二分为四的分离区域，然后是四分为八的…… 输入格式第一行一个正整数n 第二行 n 个用空格分开的正整数 $a_i$ ，表示 区域里每把金钥匙的价值。 输出格式第一行一个数，表示获得的最大价值第二行按照分离阶段从前到后，区域从左到右的顺序，输出发生分离区域编号。若有多种方案，选择分离区域尽量靠左的方案（也可以理解为输出字典序最小的）。 样例样例输入71 2 3 4 5 6 7 样例输出2381 2 3 4 5 6数据范围与提示对于100% 的数据，$n_i$，$a_i$保证运算过程和结果不超过 $int$ 位正整数范围。 思路分析首先，求出获得的最大价值可以直接通过区间DP得到，只是将合并石子的条件做了改动。可以设$dp[i, j]$是从第$i$个区域到第$j$个区域之间获得的最大价值。状态转移方程为： $dp[i,j]=dp[i,k]+dp[k+1,j]+a[i]*a[k]*a[j]$$(1&lt;=i&lt;=n-len+1, j=i+len-1, i&lt;=k&lt;j)$ 参考代码： 123456789101112for(int len = 2;len &lt;= n; len++) { for(int i = 1;i &lt;= n - len + 1; i++) { int j = i + len - 1; for(int k = i;k &lt; j; k++) { if(dp[i][k] + dp[k + 1][j] + (a[i] + a[j]) * a[k] &gt; dp[i][j]) { dp[i][j] = dp[i][k] + dp[k + 1][j] + (a[i] + a[j]) * a[k]; pre[i][j] = k; } } } } printf(&quot;%d\\n&quot;, dp[1][n]); 重点在于如何输出路径。注意读题： 求出最终可以获得的最大总价值，并按照分离阶段从前到后，区域从左到右的顺序，输出发生分离区域编号。若有多种方案，选择分离区域尽量靠左的方案（也可以理解为输出字典序最小的）。例如先打印一分为二的区域，然后从左到右打印二分为四的分离区域，然后是四分为八的……也就是说需要倒着输出，从最后的划分点往回找，先递归输出左边，再输出右边。结果考试的时候以为要从左往右输出，于是所有的输出都是从1~n-1… 又因为一些bug导致基本没得分。。。输出可以用dfs，从最后一个划分点往回找。 定义$dfs(x, y, end)$,$x$表示左边界，$y$表示右边界，$end$ 表示划分次数。要配合使用一个$while$循环，原理如下 1.定义一个$h$表示输出的序号，每轮循环+1,与$dfs$中的$end$配合，保证输出的顺序不乱，将$h$初始化为0，$flag$置为1.2.进入循环 { 先把flag置为0：如果在dfs中满足了h == end即现在的划分次数$end$刚好等于 此时应该为的划分次数$h$，即可以将它置为1。 再把h++，更新划分点的次数。 进行$dfs(1， n， 1)$. 3.dfs(…….) { 如果左端点大于等于了右端点，那么就return ; 如果如果在dfs中满足了h == end即现在的划分次数$end$刚好等于此时应该为的划分次数$h$，（以确保顺序没乱） 就可以将$pre[x, y]$输出。 然后递归输出左半部分，在输出右半部分 （血的教训告诉我要审题。。。） 左半部分边界：左端点为$x$，右端点为$pre[x][y]$,end++. 左半部分边界：左端点为$pre[x][y]+1$，右端点为$y$,end++. tab }} 参考代码： 12345678910111213141516void dfs(int x, int y, int end) { if (x &gt;= y) return; if (end == h) { printf(&quot;%d &quot;, pre[x][y]); flag = 1; return; } dfs(x, pre[x][y], end + 1); dfs(pre[x][y] + 1, y, end + 1);}flag = 1;while(flag) { flag = 0; h ++; dfs(1, n, 1);}","link":"/2020/07/19/2020-07-19-%E5%88%86%E7%A6%BB%E4%B8%8E%E5%90%88%E4%BD%93%E9%A2%98%E8%A7%A3%20%E5%8C%BA%E9%97%B4DP%20%20%20DFS/"},{"title":"「Note」STL技巧整理","text":"关于STL的简单总结 STLSTL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。它是由Alexander Stepanov、Meng Lee和David R Musser在惠普实验室工作时所开发出来的。从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL是C++的一部分，因此不用安装额外的库文件。 STL 目录一览 vector queue priority_queue deque set mapvector 变长数组，内部基于倍增思想。声明 12345#include &lt;vector&gt;vector&lt;int&gt; a;vector&lt;int&gt; b[250];struct node{...};vector&lt;node&gt; c; size/emptysize 返回的是已知vector的长度，empty返回bool，判断是否为空。 clear清空。。。 迭代器类似于指针，用’*’解除引用。声明方式 vector::iterator it; begin/end &amp; front/backbegin/end :望文生义，返回第一个元素与最后一个元素的迭代器。front/back : 返回第一个元素与最后一个元素的数值。遍历方式1. 1for(int i = 1;i &lt;= a.size(); i++) printf(&quot;%d &quot;, a[i]; 123for(vector&lt;int&gt;::iterator it = a.begin();it != a.end(); it++) { printf(&quot;%d &quot;, a[i]);} push_back() &amp; pop_back()向最后一位插入元素， 或删除元素。 queue声明1234queue&lt;int&gt; q;struct res{...}; queue&lt;res&gt; q;priority_queue&lt;int&gt; q;struct res{...}; priority_queue&lt;res&gt; q; queue 循环队列 函数 作用 实例 时间复杂度 push 入队（从队尾） q.push(val) $O(1)$ pop 出队（从队头） q.pop() $O(1)$ front 队头元素 int x = q.front $O(1)$ back 队尾元素 int y = q.front $O(1)$ priority_queue 优先队列 —&gt;大根堆 函数 作用 实例 时间复杂度 push 把元素插入堆 q.push(val) $O(log n)$ pop 删除堆顶 q.pop() $O(log n)$ top 查询堆顶元素（最大值） int x = q.top $O(1)$ deque 双端队列 = vector + queue 函数 作用 实例 时间复杂度 [] 随机访问 同vector $O(1)$ begin/end 头尾迭代器 同vector $O(1)$ front/back 头尾元素 同queue $O(1)$ clear 清空 q.clear $O(n) 另一些望文生义的函数push_back/push_frontpop_front/pop_back setset声明12set&lt;int&gt; s;struct res{...}; set&lt;res&gt; s; size/empty/clear与vector的相关函数相似。时间复杂度$O(1)$ 迭代器set的迭代器是一个双向访问迭代器，不支持随机访问，但可以使用’‘解除引用，并且*只支持’++’与‘–’两个运算符。 迭代器声明1set&lt;int&gt;::ioerator it; begin/end返回首尾元素的迭代器 insert插入元素。注意 set与数学中的集合相似，不包含重复的元素，如果插入的元素已经存在，则不会重复操作。时间复杂度$O(log n)$ 遍历方式12345set&lt;int&gt; s;for(int i = 1;i &lt;= n; i++) s.insert(a[i]);for(set&lt;int&gt;::ioerator it = s.begin(); it != s.end(); it++) { printf(&quot;%d &quot;, *it);} find / lower_bound &amp; upper_bound在set集合中寻找一个等于x元素，返回迭代器，如果寻找不到，则返回s.end()。lower_bound :寻找 ≥ x的元素中最小的一个upper_bound:寻找&gt;x的元素中最小的一个 erase删除迭代器it所指向的元素 count返回set中等于x的元素个数 mapmap是对于 $key - value$的映射，$key$和$value$可以为任意的类型。 size/empty/clear/begin/end同前迭代器是一个双向访问器。 123map&lt;key, value&gt;::iterator it = m.begin();it-&gt;first --- key;it-&gt;second --- value; find$find(x)$ 为在map里寻找以$x$为$key$的迭代器，如果没有就返回$m.end()$","link":"/2020/07/22/2020-07-22-STL%20%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86%207_22/"},{"title":"「Solution」数三角","text":"@TOC 题目描述这是一个数三角的游戏。长度为1或SQRT(2)的小木棍放在一个网格上。如图所示，有水平的，垂直的或对角的。对角放置的木棍可以交叉。 将木棍随意地放在网格上得到的图案可能不含三角形，也可能含一个或多个三角形。如下图所示， (a),(b),(c),(d)和(e)分别含有2,5,12,0,0个三角形。你的任务是写一个程序数出一个图案中的三角形个数。。cpp 输入格式输入文件count.in包括N+1行： 先输入图案中木棍的个数N。下面输入这N根木棍的位置，用两个网格坐标表示，这两个坐标分别为木棍两端的位置。网格大小不超过10´10，因此网格左下和右上的坐标分别为(0,0)和(9,9)。 输出格式输入文件count.out包括1行： 三角形的个数。 样例样例输入30 0 0 10 0 1 00 1 1 0 样例输出1 分析我在考试时的思路是定义一个 三维数组 $G[x][y][state]$表示取火柴棒较上的端点的位置，$state$表示摆放的状态 ： 1 -&gt; 向左倾斜 2 -&gt; 向右倾斜 3 -&gt; 垂直于网格线 4 -&gt; 平行于网格线但我在实现的过程中发现了问题，如果在端点离得比较远的时候，枚举会很浪费时间，并且能够构成三角形的组合非常多，不易写出代码，调试程序会变得非常的麻烦。考试后看了$LJS$的代码后又重新理了一下思路：此题的步骤大致分成三个板块 ： 预处理 处理连通性 -&gt; $Floyd$ 判断是否构成三角形 预处理 1.将输入坐标依次扩大两倍 如下图： 这样的话就可以判断如小图中对角线交叉，可以使得对对角线的交点处于网格上。在一次判断两点之间的关系2.标记所连接的线段是对角线还是在网格线上面。参考代码如下(比较累赘)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253for(int i = 1;i &lt;= n; i++) { int a1, a2, a3, a4; scanf(&quot;%d %d %d %d&quot;, &amp;a1, &amp;a2, &amp;a3, &amp;a4); a1 *= 2, a2 *= 2, a3 *= 2, a4 *= 2; if (a3 + a4 - a1 - a2 == 2) { //在网格线的直边上面 if (a2 == a4) {//竖 map[a1 + 1][a2][a3][a2] = 1; map[a3][a2][a1 + 1][a2] = 1; map[a1 + 1][a2][a1][a2] = 1; map[a1][a2][a1 + 1][a2] = 1; } if (a1 == a3) {//横 map[a1][a2 + 1][a1][a4] = 1; map[a1][a4][a1][a2 + 1] = 1; map[a1][a2 + 1][a1][a2] = 1; map[a1][a2][a1][a2 + 1] = 1; } } if (a1 + a2 - a3 - a4 == 2) {//反向 if (a2 == a4) { map[a1][a2][a3 + 1][a2] = 1; map[a3 + 1][a2][a1][a2] = 1; map[a3][a2][a3 + 1][a2] = 1; map[a3][a2][a3 + 1][a2] = 1; } if (a1 == a3) { map[a1][a2][a1][a4 + 1] = 1; map[a1][a4 + 1][a1][a2] = 1; map[a1][a4 + 1][a1][a4] = 1; map[a1][a4][a1][a4 + 1] = 1; } } if (a1 + a2 - a3 - a4 == 4) {//在对角线上面 map[a3 + 1][a4 + 1][a1][a2] = 1; map[a1][a2][a3 + 1][a4 + 1] = 1; map[a3][a4][a3 + 1][a4 + 1] = 1; map[a3 + 1][a4 + 1][a3][a4] = 1; } if (a3 + a4 - a1 - a2 == 4) { map[a1 + 1][a2 + 1][a3][a4] = 1; map[a3][a4][a1 + 1][a2 + 1] = 1; map[a1][a2][a1 + 1][a2 + 1] = 1; map[a1 + 1][a2 + 1][a1][a2] = 1; } if (a1 + a2 == a3 + a4) { map[a1][a2][(a1 + a3) / 2][(a2 + a4) / 2] = 1; map[(a1 + a3) / 2][(a2 + a4) / 2][a1][a2] = 1; map[a3][a4][(a1 + a3) / 2][(a2 + a4) / 2] = 1; map[(a1 + a3) / 2][(a2 + a4) / 2][a3][a4] = 1; } map[a1][a2][a3][a4] = 1;//将已经给出的两点连在一起 map[a3][a4][a1][a2] = 1;} 求出连通性参考$Floyd$算法的思想：枚举中转点$i$与和它相连接的另外两个不同于中转点且没有连接的节点$z$,$j$，判断两点之间的可连性（三点共线），如果可以，就将其连接。可连性判断：$(z1 - i1) * (j - i) - (j1 - i1) * (z - i) == 0$ 12345678910111213141516171819for (int i = 0; i &lt;= 18; i++) { for (int j = 0; j &lt;= 18; j++) { for (int z = 0; z &lt;= 18; z++) { for (int i1 = 0; i1 &lt;= 18; i1++) { for (int j1 = 0; j1 &lt;= 18; j1++) { for (int z1 = 0; z1 &lt;= 18; z1++) { if (map[i][i1][j][j1] == 1 &amp;&amp; map[i][i1][z][z1] == 1 &amp;&amp; !(i == j &amp;&amp; i1 == j1) &amp;&amp; !(i == z &amp;&amp; i1 == z1) &amp;&amp; (z1 - i1) * (j - i) - (j1 - i1) * (z - i) == 0 &amp;&amp; map[j][j1][z][z1] == 0 &amp;&amp; map[z][z1][j][j1] == 0) { map[j][j1][z][z1] = 1; map[z][z1][j][j1] = 1; } } } } } } } 判断是否构成三角形判断方式：暴力枚举三角形的三个端点，如果三点之间能够相连，那么能够组成三角形，就$ans++$。在输出时应该注意要将$ans / 6$，因为在枚举三个端点会出现重复，根据乘法原理可知，$ans$的枚举将会重复$3 * 2 * 1$次。 1234567891011121314151617181920for (int i = 0; i &lt;= 18; i++) { for (int j = 0; j &lt;= 18; j++) { for (int z = 0; z &lt;= 18; z++) { for (int i1 = 0; i1 &lt;= 18; i1++) { for (int j1 = 0; j1 &lt;= 18; j1++) { for (int z1 = 0; z1 &lt;= 18; z1++) { if (map[i][i1][j][j1] == 1 &amp;&amp; map[i][i1][z][z1] == 1 &amp;&amp; map[j][j1][z][z1] == 1 &amp;&amp; !(i == j &amp;&amp; i1 == j1) &amp;&amp; !(i == z &amp;&amp; i1 == z1) &amp;&amp; !(j == z &amp;&amp; j1 == z1) &amp;&amp; (z1 - i1) * (j - i) - (j1 - i1) * (z - i) != 0) { ans++; } } } } } } }ans /= (3 * 2 * 1); 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 35;bool map[MAXN][MAXN][MAXN][MAXN];int n, ans;int main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1;i &lt;= n; i++) { int a1, a2, a3, a4; scanf(&quot;%d %d %d %d&quot;, &amp;a1, &amp;a2, &amp;a3, &amp;a4); a1 *= 2, a2 *= 2, a3 *= 2, a4 *= 2; if (a3 + a4 - a1 - a2 == 2) { //在网格线的直边上面 if (a2 == a4) {//竖 map[a1 + 1][a2][a3][a2] = 1; map[a3][a2][a1 + 1][a2] = 1; map[a1 + 1][a2][a1][a2] = 1; map[a1][a2][a1 + 1][a2] = 1; } if (a1 == a3) {//横 map[a1][a2 + 1][a1][a4] = 1; map[a1][a4][a1][a2 + 1] = 1; map[a1][a2 + 1][a1][a2] = 1; map[a1][a2][a1][a2 + 1] = 1; } } if (a1 + a2 - a3 - a4 == 2) {//反向 if (a2 == a4) { map[a1][a2][a3 + 1][a2] = 1; map[a3 + 1][a2][a1][a2] = 1; map[a3][a2][a3 + 1][a2] = 1; map[a3][a2][a3 + 1][a2] = 1; } if (a1 == a3) { map[a1][a2][a1][a4 + 1] = 1; map[a1][a4 + 1][a1][a2] = 1; map[a1][a4 + 1][a1][a4] = 1; map[a1][a4][a1][a4 + 1] = 1; } } if (a1 + a2 - a3 - a4 == 4) {//在对角线上面 map[a3 + 1][a4 + 1][a1][a2] = 1; map[a1][a2][a3 + 1][a4 + 1] = 1; map[a3][a4][a3 + 1][a4 + 1] = 1; map[a3 + 1][a4 + 1][a3][a4] = 1; } if (a3 + a4 - a1 - a2 == 4) { map[a1 + 1][a2 + 1][a3][a4] = 1; map[a3][a4][a1 + 1][a2 + 1] = 1; map[a1][a2][a1 + 1][a2 + 1] = 1; map[a1 + 1][a2 + 1][a1][a2] = 1; } if (a1 + a2 == a3 + a4) { map[a1][a2][(a1 + a3) / 2][(a2 + a4) / 2] = 1; map[(a1 + a3) / 2][(a2 + a4) / 2][a1][a2] = 1; map[a3][a4][(a1 + a3) / 2][(a2 + a4) / 2] = 1; map[(a1 + a3) / 2][(a2 + a4) / 2][a3][a4] = 1; } map[a1][a2][a3][a4] = 1;//将已经给出的两点连在一起 map[a3][a4][a1][a2] = 1; } for (int i = 0; i &lt;= 18; i++) { for (int j = 0; j &lt;= 18; j++) { for (int z = 0; z &lt;= 18; z++) { for (int i1 = 0; i1 &lt;= 18; i1++) { for (int j1 = 0; j1 &lt;= 18; j1++) { for (int z1 = 0; z1 &lt;= 18; z1++) { if (map[i][i1][j][j1] == 1 &amp;&amp; map[i][i1][z][z1] == 1 &amp;&amp; !(i == j &amp;&amp; i1 == j1) &amp;&amp; !(i == z &amp;&amp; i1 == z1) &amp;&amp; (z1 - i1) * (j - i) - (j1 - i1) * (z - i) == 0 &amp;&amp; map[j][j1][z][z1] == 0 &amp;&amp; map[z][z1][j][j1] == 0) { map[j][j1][z][z1] = 1; map[z][z1][j][j1] = 1; } } } } } } } for (int i = 0; i &lt;= 18; i++) { for (int j = 0; j &lt;= 18; j++) { for (int z = 0; z &lt;= 18; z++) { for (int i1 = 0; i1 &lt;= 18; i1++) { for (int j1 = 0; j1 &lt;= 18; j1++) { for (int z1 = 0; z1 &lt;= 18; z1++) { if (map[i][i1][j][j1] == 1 &amp;&amp; map[i][i1][z][z1] == 1 &amp;&amp; map[j][j1][z][z1] == 1 &amp;&amp; !(i == j &amp;&amp; i1 == j1) &amp;&amp; !(i == z &amp;&amp; i1 == z1) &amp;&amp; !(j == z &amp;&amp; j1 == z1) &amp;&amp; (z1 - i1) * (j - i) - (j1 - i1) * (z - i) != 0) { ans++; } } } } } } } ans /= (3 * 2 * 1); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2020/07/25/2020-07-25-%E6%95%B0%E4%B8%89%E8%A7%92%20%E9%A2%98%E8%A7%A3/"},{"title":"「Note」树状数组","text":"定义树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)是一个查询和修改复杂度都为log(n)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。 —— by baidu 实现用一个数组$bit[i]$表示从$[i - lowbit(x) + 1, x]$中的所有的数的和。如下图： lowbit操作$lowbit$表示一个数在二进制中只保留最后一位1及其以后的0所表示的数字。常用的方法：先将原数取反再与上原数： 123int lowbit(int x) { return x &amp; (-x);} update操作$update$是单点修改操作，可以修改任意一个点上的数值，并进行全局维护。 1234void update(int x, int y) { for(int i = x;i &lt;= n; i += lowbit(i)) bit[i] += y;} Sum操作$Sum(x)$是将从$1 -x$的所有数值的和累加起来： 123456long long Sum(int x) { long long ans = 0; for(int i = x; i; i -= lowbit(i)) ans += bit[i]; return ans;} 常用模板单点修改，区间查询基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 5;int n, q;long long a, bit[MAXN];int lowbit(int x) { return x &amp; (- x);}long long Sum(int x) { long long ans = 0; for(int i = x;i &gt; 0; i -= lowbit(i)) ans += bit[i]; return ans;}void update(int x, int y) { for(int i = x;i &lt;= n; i += lowbit(i)) bit[i] += y;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for(int i = 1;i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a); update(i, a); } for(int i = 1;i &lt;= q; i++) { int oder; scanf(&quot;%d&quot;, &amp;oder); if(oder == 1) { int k, x; scanf(&quot;%d %d&quot;, &amp;k, &amp;x); update(k, x); } if(oder == 2) { int l, r; scanf(&quot;%d %d&quot;, &amp;l, &amp;r); printf(&quot;%lld\\n&quot;, Sum(r) - Sum(l - 1)); } } return 0;} 区间修改，区间查询$P[]仍为A[]的差分数组，那么原数组的前缀和A[1]+A[2]+……+ A[n]=P[1]+(P[1]+P[2])+(P[1]+P[2]+P[3])+……+(P[1]+P[2]+……+P[n])=nP[1]+(n-1)P[2]+(n-2)P[3]+……+P[n]=n(P[1]+P[2]+P[3]+……+P[n])-(0P[1]+1P[2]+2*P[3]+……+(n-1)P[n])$观察减式两边，分别将P[i]和(i-1)p[i]建立两个树状数组BIT1和BIT2，BIT1就是差分数组，区间修改按上一例进行；BIT2的增量就不是x了，而是x(i-1)。至于区间查询，我们已经知道原数组前缀和了，直接相减即可查询区间和。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 5;int n, q;int a[MAXN];long long bit1[MAXN], bit2[MAXN];int lowbit(int x) { return x &amp; -x;}void updata(int x, int y) { for(int i = x;i &lt;= n; i += lowbit(i)) { bit1[i] += (long long) y; bit2[i] += (long long) (x - 1) * y; }}long long Sum(int k) { long long ans = 0; for(int i = k; i; i -= lowbit(i)) { ans += (long long) bit1[i] * k - (long long) bit2[i]; } return ans;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for(int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); updata(i, a[i] - a[i - 1]); } for(int i = 1;i &lt;= q; i++) { int opt, l, r, x; scanf(&quot;%d&quot;, &amp;opt); if(opt == 1) { scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;x); updata(l, x); updata(r + 1, -x); } if(opt == 2) { scanf(&quot;%d %d&quot;, &amp;l, &amp;r); printf(&quot;%lld\\n&quot;, Sum(r) - Sum(l - 1)); } } return 0;} 区间修改，单点查询$对原数组A[]建一个差分数组P[i]=A[i]-A[i-1]那么A[i]=P[1]+P[2]+……+P[i]$将差分数组P[]建立BIT，单点查询就是sum，区间修改就是update(left, x)和update(right+1, -x)，BIT求前缀和sum就是区间修改后的单点查询了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 5;int n, q, a[MAXN];long long p[MAXN], bit[MAXN];int lowbit(int x) { return x &amp; (- x);}void updata(int x, int y) { for(int i = x;i &lt;= n; i += lowbit(i)) bit[i] += y;}long long Sum(int x) { long long ans = 0; for(int i = x;i &gt; 0; i -= lowbit(i)) { ans += bit[i]; } return ans;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for(int i = 1;i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); p[i] = a[i] - a[i - 1]; updata(i, p[i]); } for(int i = 1;i &lt;= q; i++) { int oder; scanf(&quot;%d&quot;, &amp;oder); if(oder == 1) { int l, r, x; scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;x); updata(l, x); updata(r + 1, -x); } else { int x; scanf(&quot;%d&quot;, &amp;x); printf(&quot;%lld\\n&quot;, Sum(x)); } } return 0;} 二维树状数组 ：单点修改，区间查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e4 + 5; int n, m, opt;long long bit[MAXN][MAXN];int lowbit(int x) { return x &amp; -x;}void update(int x, int y, int k) { for(int i = x; i &lt;= n; i += lowbit(i)) { for(int j = y; j &lt;= m; j += lowbit(j)) { bit[i][j] += k; } }}long long Sum(int x, int y) { long long ans = 0; for(int i = x; i &gt; 0; i -= lowbit(i)) { for(int j = y; j &gt; 0; j -= lowbit(j)) { ans += bit[i][j]; } } return ans;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); while(scanf(&quot;%d&quot;, &amp;opt) != EOF) { if(opt == 1) { int x, y, k; scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;k); update(x, y, k); } else { int a, b, c, d; scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); printf(&quot;%lld\\n&quot;, Sum(c, d) - Sum(a - 1, d) - Sum(c, b - 1) + Sum(a - 1, b - 1)); } } return 0;} 二维树状数组 ：区间修改，区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define LL long longusing namespace std;const int MAXN = 2055;int n, m, arr[MAXN], opt;long long bit1[MAXN][MAXN], bit2[MAXN][MAXN], bit3[MAXN][MAXN], bit4[MAXN][MAXN];int lowbit(int x) { return x &amp; -x; }void update(int a, int c, int x) { for (int i = a; i &lt;= n; i += lowbit(i)) { for (int j = c; j &lt;= m; j += lowbit(j)) { bit1[i][j] += (LL)x; bit2[i][j] += (LL)c * x; bit3[i][j] += (LL)a * x; bit4[i][j] += (LL)a * c * x; } }}long long Sum(int x, int y) { long long ans = 0; for (int i = x; i; i -= lowbit(i)) { for (int j = y; j; j -= lowbit(j)) { ans += (LL)bit1[i][j] * (x + 1) * (y + 1) - (LL)bit2[i][j] * (x + 1) - (LL)bit3[i][j] * (y + 1) + (LL)bit4[i][j]; } } return ans;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); while (scanf(&quot;%d&quot;, &amp;opt) != EOF) { int a, b, c, d, x; if (opt == 1) { scanf(&quot;%d %d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;x); update(a, b, x); update(c + 1, b, -x); update(a, d + 1, -x); update(c + 1, d + 1, x); } if (opt == 2) { scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); printf(&quot;%lld\\n&quot;, Sum(c, d) + Sum(a - 1, b - 1) - Sum(a - 1, d) - Sum(c, b - 1)); } } return 0;}","link":"/2020/07/26/2020-07-26-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"「Note」图论学习笔记2","text":"@TOC 多源最短路Floyd$Floyd$是基于$DP$思想。设$k$为中转点，与$i$, $j$都有边相连。那么可以得到$dis[i][j]$的最短路径的状态转移方程为：$dis[k,i,j]=min(dis[k-1,i,j], dis[k-1,i,k]+dis[k-1,k,j]$ 12345678910111213141516171819202122232425memset(dis, 0x3f, sizeof(dis));memset(pre, 0, sizeof(pre));pre[u][v] = u;void Floyd() { for(int k = 1;k &lt;= n; k++) { for(int i = 1;i &lt;= n; i++) { for(int j = 1;j &lt;= n; j++) { if(dis[i][j] &gt; dis[i][k] + dis[k][j]) { dis[i][j] = dis[i][k] + dis[k][j]; pre[i][j] = pre[k][j];//输出路径 } } } }}void print(int x) { if(pre[s][x] == 0) { printf(&quot;%d &quot;, s); return ; } print(pre[s][x]); printf(&quot;%d &quot;, x);} Dijkstra$Dijkstra$使用贪心思想，求最短路的步骤如下：1.初始化：把$dis[]$置为∞，$v[]$置为0表示还没有访问过。2.循环遍历与当前节点相邻的节点，找出最短的距离。3.用找出的最短距离更新剩下的节点。 一般版本123456789101112131415161718192021222324252627void Dijkstra(int s, int t) { memset(dis, 0x3f, sizeof(dis)); memset(v, 0, sizeof(v)); v[s] = 1; for(int i = 1;i &lt; n; i++) { int k = 0; for(int j = 1;j &lt;= n; j++) { if(! v[j] &amp;&amp; (k == 0 || dis[j] &lt; dis[k])) k = j; } v[k] = 1; for(int j = 1;j &lt;= n; j++) { if(dis[k] + w[k][j] &lt; dis[j]) { dis[j] = dis[k] + w[k][j]; pre[j] = k; } } }}void print(int x) { if(pre[x] == 0) { printf(&quot;%d &quot;, x); return ; } print(pre[x]); printf(&quot;%d &quot;, x);} 邻接表优化12345678910111213141516171819202122232425262728struct edge { int v, w; edge(){} edge(int V, int W) { v = V; W = W; }};void DijkstraAdl(int s, int t) { memset(dis, 0x3f, sizeof(dis)); memset(v, 0, sizeof(v)); dis[s] = 0; for(int i = 1;i &lt;= n; i++) { int u, v, w; for(int j = 1;j &lt;= n; j++) { if(! v[i] &amp;&amp; dis[i] &lt; dis[u]) u = i; } v[u] = 1; for(int j = 0;j &lt; G[u].size(); j++) { v = G[u][j].v, w = G[u][j].w; if(dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; pre[v] = u; } } }} 优先队列优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2505;int n, m, s, t;bool vis[MAXN];int dis[MAXN];struct edge { int v, w; edge() {} edge(int V, int W) { v = V; w = W; }};struct node { int u, dis; node() {} node(int U, int D) { u = U; dis = D; } friend bool operator&lt;(node x, node y) { return x.dis &gt; y.dis; }};priority_queue&lt;node&gt; q;vector&lt;edge&gt; G[MAXN];void AddEdge(int u, int v, int w) { G[u].push_back(edge(v, w)); G[v].push_back(edge(u, w));}void Dijkstra(int s, int t) { memset(vis, 0, sizeof(vis)); memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; q.push(node(s, 0)); while (q.size()) { int now = q.top().u; q.pop(); if (vis[now]) continue; vis[now] = 1; for (int i = 0; i &lt; G[now].size(); i++) { int v = G[now][i].v; if (dis[v] &gt; dis[now] + G[now][i].w) { dis[v] = dis[now] + G[now][i].w; q.push(node(v, dis[v])); } } }}int main() { scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for (int i = 1; i &lt;= m; i++) { int u, v, w; scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); AddEdge(u, v, w); } Dijkstra(s, t); printf(&quot;%d\\n&quot;, dis[t]); return 0;}","link":"/2020/07/29/2020-07-29-%E5%9B%BE%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"},{"title":"「Note」图论学习笔记3","text":"@toc Bellman-Ford 算法Bellman-Ford算法：$Dijkstra$类似，都以松弛操作为基础，即估计的最短路径值渐渐地被更加准确的值替代，直至得到最优解。在两个算法中，计算时每个边之间的估计距离值都比真实值大，并且被新找到路径的最小长度替代。 松弛每次松弛操作实际上是对相邻节点的访问，第 n次松弛操作保证了所有深度为n的路径最短。由于图的最短路径最长不会经过超过 |V|-1条边。 负边权操作“松弛”操作是在广度上找路，所以对负边进行操作而不会影响结果。 负权环判定在处理完所有的边后，如果还有边可以松弛，那么就一定存在负权环。 朴素实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 505;struct Node { int u, v, w;} node[MAXN];int n, m, s, t;int dis[MAXN], pre[MAXN];bool Bellman_Ford(int s, int t) { memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; pre[s] = 0; for (int i = 1; i &lt; n; i++) {//迭代 n - 1次 for (int j = 1; j &lt;= m; j++) {//遍历每一条边 if (dis[node[j].u] + node[j].w &lt; dis[node[j].v]) {//松弛 dis[node[j].v] = dis[node[j].u] + node[j].w; pre[node[j].v] = node[j].u; } } } for (int i = 1; i &lt;= m; i++) {//判断负权环 if (dis[node[i].u] + node[i].w &lt; dis[node[i].v]) { return false; } } return true;}void print(int x) {//输出路径 if (pre[x] == 0) { printf(&quot;%d &quot;, x); return; } print(pre[x]); printf(&quot;%d &quot;, x);}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, ui, vi, wi; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;, &amp;ui, &amp;vi, &amp;wi); node[i].u = ui; node[i].v = vi; node[i].w = wi; pre[vi] = ui; } scanf(&quot;%d %d&quot;, &amp;s, &amp;t); if (Bellman_Ford(s, t)) { printf(&quot;%d\\n&quot;, dis[t]); print(t); } else { printf(&quot;No Solution\\n&quot;); } return 0;} Spfa思想建一个队列 ，取队头顶点u；将与点u相连的所有点v松弛，如果能更新估计值，那么就更新，如果点v没有在队列中，那么要将点v入队，如果已经在队列中了，那么就不用，循环直到队空为止，完成了单源最短路的求解。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243int n, m, s, t;int dis[MAXN];bool vis[MAXN];struct edge {//存边 int v, w; edge() {} edge(int V, int W) { v = V; w = W; }};vector&lt;edge&gt; G[MAXM];queue&lt;int&gt; q;void AddEdge(int u, int v, int w) {//加边 G[u].push_back(edge(v, w)); G[v].push_back(edge(u, w));}void Spfa(int s, int t) { memset(dis, 0x3f, sizeof(dis)); memset(vis, 0, sizeof(vis)); dis[s] = 0; vis[s] = 1; q.push(s); while (q.size()) { int u = q.front();//取出队头 q.pop(); vis[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) { if (dis[u] + G[u][i].w &lt; dis[G[u][i].v]) {//扩展新节点 dis[G[u][i].v] = dis[u] + G[u][i].w; if (!vis[G[u][i].v]) { vis[G[u][i].v] = 1; q.push(G[u][i].v); } } } }}","link":"/2020/07/30/2020-07-30-%E5%9B%BE%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"},{"title":"「Note」图论学习笔记1","text":"@TOC 图的基本概念图：由顶点（vertex）和边（edge）组成。 顶点—具体事物边—具体事物之间的联系 顶点的集合$V$，边的集合$E$，图记为$G = (V,E)$ 图的存储结构一般分为两种 ： 邻接矩阵、邻接表 邻接矩阵由一个二维数组实现,比较简单，但是在存储稠密图时比较不划算。$G[i][j]$表示的是顶点i与顶点j的关系。如果顶点i和顶点j之间有边相连， $G[i][j]=1$如果顶点i和顶点j之间无边相连， $G[i][j]=0$ 对于无向图：$G[i][j]=G[j][i]$如果边上面有权值，则$G[i][j] = val$ 邻接表通过使用$vector$实现 存点123456789struct edge { int v, w; edge(){};//首先申明函数 edge(int V, int W) { v = V; w = W; }}; vector&lt;edge&gt; G[MAXN]; 加边1234void addEdge(int u, int v, int w) {//u 起点 v 终点 w 边上的权值 G[u].push_back(edge(v, w)); G[v].push_back(edge(u, w));//如果是无向图就加上这一句} 图的遍历有深度优先遍历和广度优先遍历两种 深度优先初始状态是图中所有顶点未曾被访问，可从图中顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到；若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;queue&gt;#include &lt;vector&gt; #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 205;int n, m;bool v[MAXN];vector&lt;int&gt; G[MAXN];void addEdge(int u, int v) { G[u].push_back(v);}void dfs(int x) { printf(&quot;%d &quot;, x); v[x] = 1; sort(G[x].begin(), G[x].end()); for(int i = 0;i &lt; G[x].size(); i++) { if(! v[G[x][i]]) { v[G[x][i]] = 1; dfs(G[x][i]); } }}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1;i &lt;= m; i++) { int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); addEdge(u, v); } for(int i = 1;i &lt;= n; i++) { if(! v[i]) dfs(i); } return 0;} 广度优先假设从图中某顶点v出发，在访问v之后依次访问v的各个未被访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。换句话说，广度优先搜索遍历图的过程是以v为起始点，由近至远，依次访问和v有路径相通且路径长度为1，2，…的顶点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;queue&gt;#include &lt;vector&gt; #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 205;int n, m;bool v[MAXN];vector&lt;int&gt; G[MAXN];void addEdge(int u, int v) { G[u].push_back(v);}void bfs(int k) { queue&lt;int&gt; q; q.push(k); v[k] = 1; printf(&quot;%d &quot;, k); while(q.size()) { int a = q.front(); q.pop(); sort(G[a].begin(), G[a].end()); for(int i = 0;i &lt; G[a].size(); i++) { if(! v[G[a][i]]) { v[G[a][i]] = 1; printf(&quot;%d &quot;, G[a][i]); q.push(G[a][i]); } } }}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1;i &lt;= m; i++) { int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); addEdge(u, v); } for(int i = 1;i &lt;= n; i++) { if(! v[i]) bfs(i); } return 0;}","link":"/2020/07/28/2020-07-28-%E5%9B%BE%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"title":"「Notice」最小生成树","text":"@toc 定义给定一个带权图，满足以下条件： 1.保证图中所有的点都联通 2.在满足条件1的情况下尽可能去掉多的边，使得所有的边权之和最小，即$\\Sigma_{i=1}^{i&lt;=m}w_i$最小。 Kruskal算法 Kruskal是基于贪心的思想，根据以上的定义描述依次枚举$1-m$条边，如果两个点没有存在于一个连通分量中，那么就连上这一条边。此算法的难点在于查询两个点是否在一个连通分量中，朴素思想可以使用$DFS$/$BFS$进行遍历，但是会使得时间复杂度非常高，此时可以使用并查集进行维护，优化时间。 算法流程1.建立并查集，初始化$fa[i] = i$.2.按边权从小到大枚举。3.如果$(u, v, w)$中$u$和$v$不连通，就合并$u$,$v$所在的集合，$ans$累加上$w$.4.否则直接跳过5.如果已经加上了$n - 1$条边，那么就退出，得到答案。 时间复杂度为 $O(m log m)$. 具体实现建立结构体存边123456struct node { int u, v, w; // u -&gt; 起点 v -&gt; 终点 w -&gt; 边权} dis[MAXM];bool cmp(node x, node y) {//自定义排序 贪心 保证边权较小的排在前面 return x.w &lt; y.w;} 并查集维护12345678910111213int FindSet(int v) {//查询父节点 if(fa[v] == v) return v; else { return fa[v] = FindSet(fa[v]);//路径压缩 }}bool UnionSet(int v, int u) {//查询是否在一个连通分量之中 + 合并 int x = FindSet(v); int y = FindSet(u); if(x == y) return 0; fa[x] = fa[y]; return 1;} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 105;const int MANM = MAXN * MAXN;int n, m, tot, ans;int fa[MAXN];//存边与排序struct node { int u, v, w;} dis[MAXM];bool cmp(node x, node y) { return x.w &lt; y.w;}//并查集维护int FindSet(int v) { if(fa[v] == v) return v; else { return fa[v] = FindSet(fa[v]); }} bool UnionSet(int v, int u) { int x = FindSet(v); int y = FindSet(u); if(x == y) return 0; fa[y] = fa[x]; return 1;} int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;, &amp;dis[i].u, &amp;dis[i].v, &amp;dis[i].w);//输入每一条边的值 } sort(dis + 1, dis + 1 + m, cmp) ;//按w从小到大排序 for(int i = 1; i &lt;= n; i++) fa[i] = i;//并查集初始化 for(int i = 1; i &lt;= m; i++) {//枚举每一条边 if(UnionSet(dis[i].u, dis[i].v)) {//查询是否在一个连通分量之中 ans += dis[i].w;//加入边权 tot ++;//记录已经加入的边数 } if(tot == n - 1) break; //如果边数已满，就积时退出 } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2020/08/05/2020-08-05-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%20-%20Kruskal/"},{"title":"「Solution」SCOI 滑雪与时间胶囊","text":"SCOI 滑雪与时间胶囊题目描述a180285 非常喜欢滑雪。他来到一座雪山，这里分布着$M$条供滑行的轨道和$N$个轨道之间的交点（同时也是景点），而且每个景点都有一编号$i(1&lt;=i&lt;=n)$和一高度$$。a180285 能从景点$i$滑到景点$j$当且仅当存在一条$i$和$j$之间的边，且$i$的高度不小于$j$。与其他滑雪爱好者不同， a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。于是 a180285 拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。现在， a180285 站在$1$号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？ 输入格式输入的第一行是两个整数$N$,$M$。接下来$1$行有$N$个整数$H_i$，分别表示每个景点的高度。接下来$M$行，表示各个景点之间轨道分布的情况。每行$3$个整数,$U_i$,$V_i$,$K_i$。表示编号为$U_i$的景点和编号为$V_i$的景点之间有一条长度为$K_i$的轨道。 输出格式输出一行，表示 a180285 最多能到达多少个景点，以及此时最短的滑行距离总和。 样例样例输入3 33 2 11 2 12 3 11 3 10 样例输出3 2 思路用$Kruskal$或$Prim$肯定是过不了的,因为题目中有限制.首先在输入时处理起点与终点,从高向低去存边,再用$DFS$从点$1$开始跑一遍,用$vis$存一下哪些边可以到达,最后用$node$存可以使用的边.写一个$cmp$,以$u$的高度为第一关键字,用$w$为第二关键字.最后跑一遍$Kruskal$或者$Prim$就可以求解. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 5;const int MAXM = 5 * 1e6 + 5;int n, m, h[MAXN], maxl, tot, cnt, fa[MAXN];long long ans;bool vis[MAXN];struct node { int u, v, w;} dis[MAXM];bool cmp(node x, node y) { if (h[x.v] != h[y.v]) return h[x.v] &gt; h[y.v]; else return x.w &lt; y.w;}struct edge { int v, w; edge() {} edge(int V, int W) { v = V; w = W; }};vector&lt;edge&gt; G[MAXN];void AddEdge(int u, int v, int w) { G[u].push_back(edge(v, w)); }int FindSet(int v) { if (fa[v] == v) return fa[v]; else return fa[v] = FindSet(fa[v]);}bool UnionSet(int u, int v) { int x = FindSet(u); int y = FindSet(v); if (x == y) return 0; else { fa[x] = fa[y]; return 1; }}void Kruskal() { for (int i = 1; i &lt;= n; i++) fa[i] = i; sort(dis + 1, dis + 1 + cnt, cmp); for (int i = 1; i &lt;= cnt; i++) { if (UnionSet(dis[i].u, dis[i].v)) { ans += dis[i].w; tot++; } if (tot == maxl - 1) break; } printf(&quot;%lld\\n&quot;, ans);}void dfs(int x) { vis[x] = 1; maxl++; for (int i = 0; i &lt; G[x].size(); i++) { int v = G[x][i].v; if (!vis[v]) { dfs(v); } }}void intn() { for (int i = 1; i &lt;= n; i++) { if (vis[i] == 1) { for (int j = 0; j &lt; G[i].size(); j++) { if (vis[G[i][j].v] == 1) { cnt ++; dis[cnt].u = i; dis[cnt].v = G[i][j].v; dis[cnt].w = G[i][j].w; } } } }}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;h[i]); } for (int i = 1, ui, vi, wi; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;, &amp;ui, &amp;vi, &amp;wi); if (h[ui] &gt;= h[vi]) { AddEdge(ui, vi, wi); } if (h[ui] &lt;= h[vi]) { AddEdge(vi, ui, wi); } } dfs(1); printf(&quot;%d &quot;, maxl); intn(); Kruskal(); return 0;}","link":"/2020/08/15/2020-08-15-SCOI%20%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」构造完全图","text":"题目链接分析假设有如下图两个集合 $x$ &amp; $y$。因为要构造一个完全图，所以应该将$x$中的$s[x]$个节点与$y$中的$s[y]$个节点一一连接即连接$s[x] * s[y] - 1$（此处减一是为了在后面单独处理原图中的$dis[i].w$）个节点，为了保证此完全图的最小生成树所以要用$(s[x] * s[y] - 1) * (dis[i].w + 1)$，最后加上原图中的$dis[i].w$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 1e5 + 5;int n, fa[MAXN], s[MAXN];LL ans;struct node { int u, v, w;} dis[MAXN];bool cmp (node x, node y) { return x.w &lt; y.w;}int FindSet(int v) { if (fa[v] == v) { return v; } else { return fa[v] = FindSet(fa[v]); }}bool UnionSet(int v, int u) { int x = FindSet(v); int y = FindSet(y); if (x == y) return 0; else { fa[x] = fa[y]; return 1; }}void Kruskal() { sort (dis + 1, dis + n, cmp); for (int i = 1; i &lt;= n; i++) { s[i] = 1; fa[i] = i; } for (int i = 1; i &lt; n; i++) { int x = FindSet(dis[i].u); int y = FindSet(dis[i].v); if (x == y) continue; ans += (long long)(dis[i].w + 1) * (s[x] * s[y] - 1) + dis[i].w; fa[x] = y; s[y] += s[x]; } printf(&quot;%lld\\n&quot;, ans);}int main() { scanf (&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) { scanf (&quot;%d %d %d&quot;, &amp;dis[i].u, &amp;dis[i].v, &amp;dis[i].w); } Kruskal(); return 0;}","link":"/2020/08/17/2020-08-17-%E6%9E%84%E9%80%A0%E5%AE%8C%E5%85%A8%E5%9B%BE%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」数星星 Stars","text":"题目链接 分析一道树状数组，但坑点比较多。。。首先在草稿纸上画图可以得知：星星的等级与$x$无关，至于$y$的大小有关，于是我们可以根据输入顺序一一将其插入树状数组进行维护，此星星的等级其实就是在插入前以$1$~星星的$y$的星星数量和。 注意星星的坐标是从$(0, 0)$开始存，但树状数组不能够维护，所以要提前将所有星星的$x$加上一。(如果在求和函数中把限度跳到0就会卡死循环我就错了) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 3e5 + 5;int x[MAXN], n, m, star[MAXN], t[MAXN];int bit[MAXN];int lowbit(int x) { return x &amp; (-x);}void update(int k, int x) { for (int i = k; i &lt;= MAXN; i += lowbit(i)) { bit[i] += x; }}int Sum(int k) { int ans = 0; for (int i = k; i; i -= lowbit(i)) { ans += bit[i]; } return ans;} int main() {// freopen(&quot;star.in&quot;, &quot;r&quot;, stdin);// freopen(&quot;star.out&quot;, &quot;w&quot;, stdout); scanf (&quot;%d&quot;, &amp;n); for (int i = 1, y; i &lt;= n; i++) { scanf (&quot;%d %d&quot;, &amp;x[i], &amp;y); ++x[i]; m = max(m, x[i]); } for (int i = 1; i &lt;= n; i++) { star[Sum(x[i])] ++; update(x[i], 1); } for (int i = 0; i &lt; n; i++) { printf (&quot;%d\\n&quot;, star[i]); } return 0;}","link":"/2020/08/17/2020-08-17-%E6%95%B0%E6%98%9F%E6%98%9F%20Stars%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」秘密的牛奶运输","text":"题目连接 分析一道可以暴力水过去的次小生成树 step1首先用$Kruskal$||$Prim$求出原图的一颗最小生成树，在连边的时候，用一个$vis$记录一下那些已经在最小生成树里面。 step2提前暴力$dfs$或者$bfs$求出任意两点构成的环之间的最大权值具体操作定义函数$dfs(int s, int u, int father, int mw1, int mw2)$s -&gt; 起点 u -&gt; 终点 father 判断是否回到原起点 mw1 最大值 mw2 次大值再用md1[s][u]保存从s -&gt; u的最大边权值， 用md2[s][u]保存从s -&gt; u的次大边权值循环遍历与重点u相连接的每一个点（v)，如果没有回到father就继续。定义t1, t2如果 从u -&gt; v的 权值(w) 大于了现在的mw1- 把t1 更新为 w- 把t2 更新为 mw1 否则 如果 w 大于了现在的mw2 并且小于 mw1 - 把t1 更新为 mw1 - 把t2 更新为 w最后递归遍历 dfs(s, v, u, t1, t2) step2再一次考虑每一条非树边，用这条边上的权值考虑替换原边END 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 505;const int MAXM = 1e4 + 5;long long n, m, tot, fa[MAXN], md1[MAXN][MAXN], md2[MAXN][MAXN];long long ans, sum;bool vis[MAXN];struct node { long long u, v, w; bool vis;} dis[MAXM];bool cmp(node x, node y) { return x.w &lt; y.w;}struct edge { int v, w; edge() {} edge(int V, int W) { v = V; w = W; }};vector&lt;edge&gt; G[MAXN];void AddEdge(int u, int v, long long w) { G[u].push_back(edge(v, w)); }int FindSet(int v) { if (fa[v] == v) return fa[v]; else return fa[v] = FindSet(fa[v]);}bool UnionSet(int u, int v) { int x = FindSet(u); int y = FindSet(v); if (x == y) return 0; else { fa[x] = fa[y]; return 1; }}void dfs(int s, int u, int fa, int mw1, int mw2) { md1[s][u] = mw1; md2[s][u] = mw2; for (int j = 0; j &lt; G[u].size(); j++) { int v = G[u][j].v; int w = G[u][j].w; if (v != fa) { int t1, t2; if (w &gt; mw1) { t1 = w; t2 = mw1; } else if (w &lt; mw1 &amp;&amp; w &gt; mw2) { t1 = mw1; t2 = w; } dfs (s, v, u, t1, t2); } }} void Kruskal() { for (int i = 1; i &lt;= n; i++) fa[i] = i; sort(dis + 1, dis + 1 + m, cmp); for (int i = 1; i &lt;= m; i++) { if (UnionSet(dis[i].u, dis[i].v)) { sum += dis[i].w; tot++; dis[i].vis = 1; AddEdge(dis[i].u, dis[i].v, dis[i].w); AddEdge(dis[i].v, dis[i].u, dis[i].w); } if (tot == n - 1) break; } for (int i = 1; i &lt;= n; i++) { dfs (i, i, -1, 0, 0); } ans = 1e19; for (int i = 1; i &lt;= m; i++) { if (dis[i].vis == 0) { int w = dis[i].w, u = dis[i].u, v = dis[i].v; if (w &gt; md1[u][v]) ans = min(ans, sum + w - md1[u][v]); else if (w &gt; md2[u][v]) ans = min(ans, sum + w - md2[u][v]); } } printf (&quot;%lld\\n&quot;, ans);}int main() { scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { scanf (&quot;%lld %lld %lld&quot;, &amp;dis[i].u, &amp;dis[i].v, &amp;dis[i].w); } Kruskal(); return 0;}","link":"/2020/08/07/2020-08-17-%E7%A7%98%E5%AF%86%E7%9A%84%E7%89%9B%E5%A5%B6%E8%BF%90%E8%BE%93%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」叶子清除计划【第五周】","text":"叶子清除计划【第五周】题目描述⼩Y同学是⼀位数据结构⼤师同时也是⼀位园艺⼤师。 秋天到了，⼩Y同学需要对学校内的⼀棵树展现他顶尖的修叶⽔平。 学校内的这棵树是⼀颗拥有n个点的⽆根树，每次⼩Y会删去所有的叶⼦节点（即度数小于等于1的节点)，直到所有的点都被删除了为⽌。 ⼩Y现在想问你对于每个点，求出它是第⼏次操作中被删除的。 输入格式第⼀⾏⼀个数字n，表⽰树上节点个数 接下来n−1⾏，每⾏两个数字u,v，表⽰树上的⼀条边。 输出格式⼀⾏n个数字，第i个数字表⽰节点i在第⼏次操作中被删除。 样例样例输入1:1234551 21 32 42 5 样例输出1:12 2 1 1 1 样例输入2:123441 21 31 4 样例输出2:12 1 1 1 数据范围与提示对于30%的数据，n≤1000 对于100%的数据，2≤n≤100000,1≤u,v≤n 分析首先看到题目，所给树是一棵无根树,一棵没有特定的根节点的树，称为无根树。所以任意选取图中某个点为根，均可将无根树转化成为有根树，即在输入时要双向加边。因为每次是要将叶子节点删去，那么当入度为1时（假设此边所连点为根节点，此节点就是叶子节点），就应该删掉。题目要求删除的顺序，所以就定义一个结构体，保存入度和删除的次序，通过以上推论可得删掉的节点的次序就应该是它倒数第二条边所连接的节点的次序加一。用拓扑序变形就可解决。分析至此，不难写出代码. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100005;int n;vector&lt;int&gt; G[MAXN]; struct node { int in, flo;} a[MAXN];queue&lt;int&gt; q;void topsort() { for (int i = 1; i &lt;= n; i++) { if (a[i].in == 1) { q.push(i); a[i].flo = 1; } } while (q.size()) { int u = q.front(); q.pop();// printf (&quot;%d: &quot;, u); for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; a[v].in --; if (a[v].in == 1) {// printf (&quot;%d &quot;, v); a[v].flo = a[u].flo + 1; q.push(v); } }// printf (&quot;\\n&quot;); }}int main() { scanf (&quot;%d&quot;, &amp;n); for (int i = 1, u, v; i &lt; n; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); a[u].in ++, a[v].in ++; }// for (int i = 1; i &lt;= n; i++) {// printf (&quot;%d %d\\n&quot;, a[i].flo, a[i].in);// } topsort(); for (int i = 1; i &lt;= n; i++) { printf (&quot;%d &quot;, a[i].flo); } return 0;}","link":"/2020/08/19/2020-08-19-%E5%8F%B6%E5%AD%90%E6%B8%85%E9%99%A4%E8%AE%A1%E5%88%92%E3%80%90%E7%AC%AC%E4%BA%94%E5%91%A8%E3%80%91%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」Ant Trip","text":"Ant Trip分析题意很简单，爆搜的时间复杂度比较高，不考虑。应该使用欧拉回路的相关知识求解。 intn()输入时将两个节点的入度都加一（无向），然后将两个节点合并在一个连通图中. 12345for (int i = 1, u, v; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); in[v] ++, in[u] ++; UnionSet(u, v);} TFW居然都不知道要将两个节点合并在一个连通图中 work()step1从1~n循环，依次枚举，记录每个连通图中的点数。用一个ans[]数组保存连通图中度为奇数的节点。 step2再枚举一遍如果一个连通图中的节点数不大于1，就不用画，跳过。如果ans[]为0，这次图是一个欧拉回路，就sum++如果ans[]不为零 sum += ans[]/2 TFW只顾抄代码，连ans[]/2都不知道啥意思因为一笔只能够画掉两个奇数度数的节点 （因为TFW不停问，特此强调) ,所以只加上ans[]/2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;int n, m, sum;int in[MAXN], num[MAXN], ans[MAXN], fa[MAXN];/* num -&gt; 保存一个连通块里有几个节点*/int FindSet(int v) { if (fa[v] == v) return v; else return fa[v] = FindSet(fa[v]);}void UnionSet(int u, int v) { int x = FindSet(u); int y = FindSet(v); if (x == y) return ; else fa[x] = y;}int main() { while (scanf (&quot;%d %d&quot;, &amp;n, &amp;m) != EOF) { sum = 0; for (int i = 1; i &lt;= n; i++) { fa[i] = i; ans[i] = 0; num[i] = 0; in[i] = 0; } for (int i = 1, u, v; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); in[v] ++, in[u] ++; UnionSet(u, v); } for (int i = 1; i &lt;= n; i++) { num[FindSet(i)] ++; if (in[i] % 2 == 1) { ans[FindSet(i)] ++; } } for (int i = 1; i &lt;= n; i++) { if (num[i] &lt;= 1) continue; if (ans[i] == 0) sum ++; else { sum += ans[i] / 2; } } printf (&quot;%d\\n&quot;, sum); } return 0;}","link":"/2020/08/20/2020-08-20-Ant%20Trip%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」「一本通 3.1 练习 4」Tree","text":"题目地址 分析第一眼看到此题，感觉就是一道水题，直接加上前$need$小的白边就行了，再处理到$n-1$条黑边，但是，打完后突然发现有问题。。。 虽然加上了前$need$小的白边，但是会出现树不连通的现象，即无法构成生成树。 正解思路二分一个增量$mid$(可正可负)。跑一遍$Kruskal$，将所有的白边都加上$a$，记录构成生成树后所用到的白边，如果数量小于$need$就将右端点往左移，否则往右移。最后的$ans$需要减去增量$need * mid$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5 * 1e4 + 5;const int MAXM = 1e5 + 5;int n, m, need, fa[MAXN], l, r, mid, ans, cnt;struct node { int u, v, w, color;} dis[MAXM];bool cmp(node x, node y) { if (x.w == y.w) return x.color &lt; y.color; return x.w &lt; y.w;}int FindSet(int v) { if (fa[v] == v) return v; else { return fa[v] = FindSet(fa[v]); }}bool UnionSet(int u, int v) { int x = FindSet(u); int y = FindSet(v); if (x == y) return 0; fa[x] = fa[y]; return 1;}bool check(int mid) { int tot = 0, white = 0; cnt = 0; for (int i = 0; i &lt;= n; i++) fa[i] = i; for (int i = 1; i &lt;= m; i++) { if (dis[i].color == 0) { dis[i].w += mid; } } sort(dis + 1, dis + 1 + m, cmp); for (int i = 1; i &lt;= m; i++) { if (UnionSet(dis[i].u, dis[i].v)) { tot++; cnt += dis[i].w; if (dis[i].color == 0) white++; } if (tot == n - 1) break; } for (int i = 1; i &lt;= m; i++) { if (dis[i].color == 0) { dis[i].w -= mid; } } if (white &lt; need) { return 0; } else return 1;}int main() { scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;need); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d %d %d %d&quot;, &amp;dis[i].u, &amp;dis[i].v, &amp;dis[i].w, &amp;dis[i].color); } l = -1e2 - 5, r = 1e2 + 5; while (l &lt;= r) { mid = (l + r) &gt;&gt; 1; if (check(mid)) { l = mid + 1; ans = cnt - need * mid; } else { r = mid - 1; } } printf(&quot;%d&quot;, ans); return 0;}","link":"/2020/08/19/2020-08-19-%E3%80%8C%E4%B8%80%E6%9C%AC%E9%80%9A%203.1%20%E7%BB%83%E4%B9%A0%204%E3%80%8DTree%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」假日住宿","text":"假日住宿题目描述给出一棵$N$节点的树，每个节点代表一个城市，每个城市有一个人，每个人离开自己的城市到另一个城市，每个城市只能有一个人，问这$N$个人移动距离和的最大值。 输入格式输入的第一行包含一个整数$T(1&lt;=t&lt;=10)$，表示测试用例的数量。每个测试用例包含几行。 第一行包含一个整数$2&lt;=N&lt;=10^5$，代表城市数。 然后接下来的行分别包含三个整数$X， Y， Z$意味着在城市$X$和城市$Y$之间有一条高速公路，其长度为$Z$。 您可以假设所有城市都已连接并且高速公路是双向的。 输出格式输出每个样例中，所有人员的最大总行程。 样例输入样例112345678910112 4 1 2 3 2 3 2 4 3 2 6 1 2 32 3 42 4 14 5 85 6 5 输出样例1121862 分析这道题其实和树的重心有异曲同工的地方，虽然并不是求出重心来进行相关的操作，但是它所用的统计边数的方法与其十分类似。此题关键不是在于人在怎么走，即不需要考虑人的移动，而是如何把边的作用发挥到最大。考虑边的情况： 一条边连接了两个顶点，这两个顶点又可以拓展为两棵子树，如果想要最后的路程最长，那么就应该要更多的人去走这一条边，此时最多的人数就是左右两颗子树的点数中的较小者2w（左边的人走到右边，右边的人走到左边），点数就可以用与重心相同的方法计算。 核心代码1234567891011void dfs(LL fa, LL u) { s[u] = 1;//边界出口 || 初始只有自己一个节点 for (int i = 0; i &lt; G[u].size(); i++) { LL v = G[u][i].v, w = G[u][i].w; if (v == fa) continue; dfs(u, v); s[u] += s[v];//累加点数 ans += w * 2 * min(s[v], n - s[v]);//即左右两颗子树的点数中的较小者 * 2 * w }}","link":"/2020/10/04/2020-10-04-%E5%81%87%E6%97%A5%E4%BD%8F%E5%AE%BF%20%E9%A2%98%E8%A7%A3/"},{"title":"「Note」RMQ算法","text":"RMQRMQ 即范围最小值问题 $(Range$ $Minimum$ $Query)$支持==查询从$A_l, A_{l+1},A_{l+2}…，A_r$中的极值$(Max$ $or$ $Min)$== 算法思想设$dp_{i,j}$为左端点为$i$， 右端点为$2^j(1 &lt;&lt; j)$数组中的极值。 可以画出图像:(如下图) 可以求出递推式：==$dp_{i, j} = (min || max)(dp_{i, j-1}, dp_{i+2^{j-1}, j-1})$== 预处理1234567891011void RMQ_intn() { for (int i = 1; i &lt;= n; i++) { dp[i][0] = a[i]; } int t = log(n) / log(2) + 1; for (int j = 1; j &lt; t; j++) { for (int i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; i++) { dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]); } }} 查询1234int RMQ_query(int l, int r) { int k = log(r - l + 1) / log(2); return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);}","link":"/2020/08/24/2020-08-24-RMQ%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"},{"title":"「Solution」初二普及组全真模拟赛","text":"数你太美【第一周】题目描述PB 获得了两个正整数数列 ${a_i}$ , ${b_i}$ ，长度分别为 n , m ，其中每个数都小于 10。 定义一个正整数是“美丽的正整数”，当且仅当:这个数的十进制表示中，至少有一个 数位上的数在数列 a_i 出现过，至少有一个数位上的数在数列 b_i 出现过。现在 PB 希 望求出最小的“美丽的正整数”。 输入格式第一行，两个正整数 n , m ; 第二行，n 个正整数，第 i 个为 a_i ; 第三行，m 个正整数，第 i 个为 b_i 。 输出格式一行，一个正整数表示最小的“美丽的正整数”。 样例样例输入样例输入 12 32 46 5 2 样例输出 12 样例解释 12 既在数列 a 中出现又在数列 b 中出现，且可知没有比 2 小的正整数是“美丽的正整 数”。 样例输入 22 68 71 1 4 5 1 4 样例输出 217 样例解释 2:17 中有数位 1,7 。1 在数列 b 中出现， 7 在数列 a 中出现，且可以证明没有比 17 小 的正整数是“美丽的正整数”。 数据范围与提示对于 30% 的数据， $1&lt;=n,m&lt;=4;$对于 100% 的数据， $1&lt;=n,m&lt;=9,1&lt;=a_i,b_i&lt;=9。$ 分析首先已知所有的$a_i$和$b_i$都不会大于9，则可知道组合的“美丽的正整数”一定没有单独的“美丽的正整数”优。不难想出方法，先排序，遍历两个数组，如果有相同元素，则直接输出并退出，否则就比较两个序列的最小值，将其组成两位数输出。 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 105;const int INF = 0x3f3f3f3f;int n, m, a[MAXN], b[MAXN], ans;bool flag;int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d&quot;, &amp;b[i]); } sort(a + 1, a + 1 + n); sort(b + 1, b + 1 + m); ans = 0x3f3f3f3f; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (a[i] == b[j]) { ans = min(ans, a[i]); flag = 1; } } } if (flag) printf(&quot;%d\\n&quot;, ans); else { printf(&quot;%d%d\\n&quot;, min(a[1], b[1]), max(a[1], b[1])); } return 0;} 逃亡【第一周】题目描述从前有个平面直角坐标系，坐标系里有座学校。这是一个矩形，左下角是 (0,0)，右上角是 (n,m)。有 k 个蒟蒻在校园中。第 i 个蒟蒻在 (xi,yi) 的位置。由于一些不可 抗因素，所有 xi 互不相同，所有 yi 互不相同。这时 PB 要来抓蒟蒻们做实验了! 蒟蒻们听到这个消息，也是四处逃亡，只要逃到校园的边界上就不会被 PB 抓到。 每个蒟蒻可以沿着任意路线逃亡。然而蒟蒻们反应迟钝，所以如果两个蒟蒻的逃亡路线 有交点，它们就有可能相撞，就会被 PB 抓住。所以任意两人的路线不能有交点。 现在蒟蒻们想知道，蒟蒻全部能成功逃亡的路线的长度之和的最小值。(虽然，这 对神通广大的 PB 根本不是一回事……) 输入格式第一行三个整数 n, m, k，相邻两数用一个空格分开。 接下来 k 行，第 i 行两个正整数 xi 和 yi，用一个空格分开。 输出格式一行一个数表示总距离的最小值，保留 3 位小数。 样例样例输入5 5 11 2 样例输出1.000 数据范围与提示对于前 30% 的数据，0&lt;=n,m&lt;=6, 1&lt;=k&lt;=5。 对于前 100% 的数据，0&lt;=n,m&lt;=10^9, 1&lt;=k&lt;=5000, 1&lt;=xi&lt;n, 1&lt;=yi&lt;m 对于所有数据，xi 互不相同，yi 互不相同。 分析开始读题有点晕，准备想如何分配每个蒟蒻的逃跑路线，但画图后我发现 “任意两人的路线不能有交点。”是一句废话。假设有一个点$(x, y)$，那么在不考虑其他点的情况下，它的最优逃跑路线就是它分别到四个边界的距离的最小值即$Min(x, y, n - x, n - y)$。并且此题也不需要考虑其他点。 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5005;int n, m, k, x, y;double ans;int main() { scanf (&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= k; i++) { scanf (&quot;%d %d&quot;, &amp;x, &amp;y); x = min(x, n - x); y = min(y, m - y); ans += min(x, y); } printf (&quot;%.3lf\\n&quot;, ans); return 0;} 数数字【第一周】题目描述PB 带来了若干只蒟蒻。 众所周知，NTF 是数论学会的会长，于是 PB 准备用数字击败 NTF，以证明 PB 比 NTF 更强。 于是 PB 准备了一些卡片，并在每个蒟蒻头上都贴了一张卡牌。每个卡牌上都写了一个数字。 由于蒟蒻太弱了，甚至不会看镜子来了解自己头上的数字，但他们由于经常被大佬吊打，所以观察力敏锐，他们都知道别人头上的数字。 第 i 个蒟蒻会告诉你他看到了 ai 种数字(定义两个数字不同种当且仅当它们的值不同) 但是由于蒟蒻太弱了，可能会报错数据，NTF 需要核实是否有一种情况使所有蒟 蒻说的话都正确。(可能情况不唯一) 输入格式多组测试，文件第一行一个整数 T，表示测试数据组数; 对于每组数据，第一行，一个整数 n，表示蒟蒻的数量; 第二行，n 个整数用空格隔开，表示数组 ai，意义同题面。 输出格式如果至少有一种情况使所有蒟蒻的话都正确，输出”yes”，否则，输出”no”。 样例样例输入221 141 3 2 2 样例输出yesno 数据范围与提示对于所有数据，T&lt;=10 对于 20% 的数据，N≤8 对于所有数据，1≦N≤1000000, 0≦ai&lt;N 分析一道思维题。考试时先打了一个假暴力，考完看提交记录有50pts，然后开始想数学解法。打假暴力时想到了一个优化：如果这个数列中最大值与最小值已经相差了2及以上，就不用管了。因为每个蒟蒻看到的种数是$a_i$, 那么总种树无非就是$a_i +1$(自己头上的数字唯一)或者$a_i$(自己头上的数字不唯一，已经出现过)，当两个$a_i$相差2及以上是，是无论如何也无法匀平的。继续按思路往下走，当最大值和最小值不同时，就只有两种情况，相差一或相等。 当最大值等于最小值的时候，分两种情况讨论，最大值等于$n-1$说明所有的蒟蒻的数字都是唯一的，符合条件。如果最大值的二倍小于$n$，也满足条件，因为每个每个蒟蒻都不唯一，所以至少有两个蒟蒻的数字一样，则他们可以互相看到，可以弥补上统计，正是如此，那么也可以得知此时每个数字都有两个重复的元素，所以最大值的二倍要小于$n$. 那么当他们相差一的时候，就说明有蒟蒻头上的数字唯一(因为蒟蒻无法看到自己头上的数字，所以会统计掉一个，但其他头上是重复数字的蒟蒻则会把他统计上，导致相差一)，用一个$sum$统计有多少个数字唯一的蒟蒻(即$a_i=Min(a_1 … a_n)$)，可得$sum$应该大于$Min(a_1 … a_n)$，因为已经得到了最大值与最小值相同时的结论，我们可以在现在的数列中去掉数字唯一的蒟蒻，那么最大值应该小于等于$(n - sum) / 2 + sum$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000005;const int INF = 0x3f3f3f3f;int t, n, t1, t2, sum;int a[MAXN];int main() { scanf (&quot;%d&quot;, &amp;t); while (t--) { scanf (&quot;%d&quot;, &amp;n); t1 = INF; t2 = -1; sum = 0; for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d&quot;, &amp;a[i]); t1 = min(t1, a[i]); t2 = max(t2, a[i]); } if (t2 - t1 &gt; 1) { printf (&quot;no\\n&quot;); continue; } if (t2 - t1 == 1) { for (int i = 1; i &lt;= n; i++) { if (a[i] == t1) { sum ++; } } if (sum &lt; t2 &amp;&amp; t2 &lt;= (n - sum) / 2 + sum) { printf (&quot;yes\\n&quot;); continue; } else { printf (&quot;no\\n&quot;); continue; } } if (t2 == t1) { if (t2 == n - 1) { printf (&quot;yes\\n&quot;); continue; } if (t2 * 2 &lt;= n) { printf (&quot;yes\\n&quot;); continue; } else { printf (&quot;no\\n&quot;); continue; } } } return 0;}","link":"/2020/09/12/2020-09-12-%E5%88%9D%E4%BA%8C%E6%99%AE%E5%8F%8A%E7%BB%84%E5%85%A8%E7%9C%9F%E6%A8%A1%E6%8B%9F%E8%B5%9B%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」关于两次dfs-bfs求树的直径反证法思路","text":"刚刚听了jmy讲他的证明方法，大致意思就是树上的任意一点所能到达的最远距离一定会在直径的两个端点上。但我认为反证法其实来得更快。思路如下： 证明： 反证法。假设已经用两次bfs/dfs求得的直径为$AB$,且$AB$上有一点$N$。如果$AB$不是这颗树的直径，那么一定存在一条链$CD$，使得$CD &gt; AB$，不妨设$CD$与$AB$的交点为$M$，所以$NB &gt; NC$即可以得到$MB &gt; MC$，可以得到$MB + MD &gt; MC + MD$所以$CD$不是树的直径，与假设矛盾。故假设不成立，原命题成立。 证毕。","link":"/2020/10/04/2020-10-04-%E5%85%B3%E4%BA%8E%E4%B8%A4%E6%AC%A1dfs-bfs%E6%B1%82%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E5%8F%8D%E8%AF%81%E6%B3%95%E6%80%9D%E8%B7%AF/"},{"title":"「Solution」[NOIP2009]最优贸易","text":"今天考了一道分层图，本来是一道板题，结果我被误导了，想成了 架设电话线一题，考完写炸了才发现，架设电话线只需要==求出第k+1大的长度，只需要满足局部最优==，但是飞行线路要==使总和最小==，只能用分层图，然后我翻了半天标签，找到了这道题。 link但是当旁边LH看到之后，他告诉我，这是一道DP。 结果我没看出来。。。 分层图倒是很简单。 Sulotionstep1首先，他可以在图上到处走动，所以很自然地可以建一张图，所有的边权都是0。然后这道题只与水晶球的价格有关，所以我们把点权搬到边权上面。step2因为他只进行一次买卖，所以有下面两种情况：假设从$u$到$v$，水晶球在$u$的价格为$w$.1.买. 建第二层图，连接第一层图 -&gt; 在$u$和$v$之间建一条边边权为$-w$。2.卖. 建第三层图，连接第二层图 -&gt; 在$u$和$v$之间建一条边边权为$w$。step3我们在最后有两种方法走向终点：不买卖直接走向终点直接在第一层图的n号节点建立边权为0的有向边接入一个“大终点”买卖一次后走向终点在第三层图的n号节点建立边权为0的有向边接入“大终点” 至此，这道题就只需要求一个最长路即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100005 * 3 + 1;int n, m, a[MAXN];bool vis[MAXN];int dis[MAXN];queue&lt;int&gt; q;void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &gt; '9' || c &lt; '0') { if (c == '-') f = -f; c = getchar(); } while (c &lt;= '9' &amp;&amp; c &gt;= '0') { x = x * 10 + c - '0'; c = getchar(); } x *= f;}struct edge { int v, w; edge(){} edge(int V, int W) { v = V; w = W; }};vector&lt;edge&gt; G[MAXN];void AddEdge(int u, int v, int w) { G[u + n * 0].push_back(edge(v + n * 0, 0)); G[u + n * 1].push_back(edge(v + n * 1, 0)); G[u + n * 2].push_back(edge(v + n * 2, 0)); G[u + n * 0].push_back(edge(v + n * 1, -w)); G[u + n * 1].push_back(edge(v + n * 2, w));}void Spfa() { memset(vis, 0, sizeof(vis)); memset(dis, 0xcf, sizeof(dis)); dis[1] = 0; vis[1] = 1; q.push(1); while (q.size()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i].v, w = G[u][i].w; if (dis[v] &lt; dis[u] + w) { dis[v] = dis[u] + w; if (vis[v] == 0) { vis[v] = 1; q.push(v); } } } } printf (&quot;%d\\n&quot;, dis[n]);}int main() { read(n); read(m); for (int i = 1; i &lt;= n; i++) { read(a[i]); } for (int i = 1, u, v, opt; i &lt;= m; i++) { read(u), read(v), read(opt); AddEdge(u, v, a[u]); if (opt == 2) { AddEdge(v, u, a[v]); } } G[n].push_back(edge(n * 3 + 1, 0)); G[n * 3].push_back(edge(n * 3 + 1, 0)); n *= 3; n++; Spfa(); return 0;}","link":"/2020/10/07/2020-10-07-%E3%80%90NOIP2009%E3%80%91%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%20%E9%A2%98%E8%A7%A3/"},{"title":"「Note」简单数论","text":"整除定义设$a,b \\in \\mathbb{Z}$,且$b \\neq 0$.如果存在$q\\in\\mathbb{Z}$，使得$a=bq$,则$b$整除a，记作$b\\mid a$，此时$b$为$a$的因数，$a$叫做$b$的倍数. 性质1$如果a \\mid b 且 b\\mid c$,那么$c\\mid a$证明 ： $设an=b, bm=c (n, m \\in \\mathbb{Z}).$$\\therefore c/a = nm.$$\\therefore c\\mid a.$ 2$如果a\\mid b且a\\mid c，有a\\mid (bx+cy)$证明：$设 as = b, at = c$$s,t\\in\\mathbb{Z^+}$$\\therefore ast = c$$\\therefore a\\mid c$ 3$如果c\\mid a, c\\mid b，那么对于任意m, n\\in\\mathbb{Z},有c\\mid ma+mb$.证明$如果m\\neq 0,则a\\mid b \\Leftrightarrow mb\\mid ma$$\\because a\\mid b$$\\therefore 不妨设an=b$$\\therefore anm = bm$$\\therefore n*am = bm$$\\therefore mb\\mid ma$ 4$如果ax+by=1，a\\mid n, a\\mid n. \\Rightarrow ab\\mid n$.证明：$设as=n=1, bt=n, s,t\\in\\mathbb{Z}且s, t \\neq 0$.$\\because ax+by=1$.$\\therefore \\frac{x}{b} + \\frac{y}{a}$.$\\because ab\\mid n$$\\therefore \\frac{n}{ab}\\in\\mathbb{Z}$$\\therefore n \\times \\frac{1}{ab}$$=\\frac{nx}{b}+\\frac{ny}{a}$$=tx+sy$ 5如果$b=d\\times q + c,q\\in\\mathbb{Z}$$d\\mid c \\Leftrightarrow d\\mid b$ 模运算定义对于整数$a,b (b \\neq 0)$,求$a \\div b$的余数.记作$a$ $mod$ $b$$(a%b)$. 性质1.分配率$(a+b)%c=(a%c+b%c)%c$$(a-b)%c=(a%c-b%c)%c$$(a\\times b)%c=(a%c\\times b%c)%c$$(a^b)%c=(a%b)^b%c$统一证明:设$ka+m_a=c, kb+m_b=c$带入整理可得:$\\Rightarrow(a+b)%c=(m_a+m_b)%c$$\\Rightarrow(a-b)%c=(m_a-m_b)%c$$\\Rightarrow(ab)%c=(m_am_b)%c$而幂运算可与看做多个乘法运算 2.缩放性2.1$如果a%b=c,d\\neq 0$$\\Rightarrow (ab)%(bd)=cd$证明: 设$a=bs+c$ $\\Rightarrow ad=(bs+c)d$ $\\Rightarrow ad=sbd+cd$ $\\Rightarrow (ab)%(bd)=cd$ 2.2$如果a%b=c,d\\mid a, d\\mid b$$\\Rightarrow(a/d)%(b/d)=(c/d).$证明： 设$bs+c=a$. $\\frac{b}{d}\\times s + \\frac{c}{d}=\\frac{a}{d}$ 2.3$\\frac{a}{b}%c=\\frac{a%(bc)}{b}$证明： 两边同时乘$b$，可以得到： $a%(bc)=a%(bc)$","link":"/2020/10/17/2020-10-17-%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5/"},{"title":"「Note」KMP","text":"KMP算法模板 1234567891011121314151617181920212223const int MAXN = 1e6 + 5;char a[MAXN], b[MAXN];int nxt[MAXN], f[MAXN], ans;void KMP(char* a, char* b) { int n = strlen(a + 1), m = strlen(b + 1); nxt[1] = 0; for (int i = 2, j = 0; i &lt;= n; i++) { while (j &gt; 0 &amp;&amp; a[i] != a[j + 1]) j = nxt[j]; if (a[i] == a[j + 1]) j++; nxt[i] = j; } for (int i = 1, j = 0; i &lt;= m; i++) { while (j &gt; 0 &amp;&amp; (j == n || b[i] != a[j + 1])) j = nxt[j]; if (b[i] == a[j + 1]) j++; f[i] = j; if (f[i] == n) { ans++; } } printf (&quot;%d\\n&quot;, ans);}","link":"/2020/11/23/2020-11-23-KMP/"},{"title":"「Note」Matrix","text":"矩阵模板，支持相乘与相加 1234567891011121314151617181920212223242526272829303132333435363738struct Matrix { int r, c; LL m[MAXN][MAXN]; Matrix(){} Matrix(int r, int c) : r(r), c(c){}; void clear() { memset(m, 0, sizeof(m)); } void init() { for (int i = 1; i &lt;= r; i++) m[i][i] = 1; } Matrix operator * (const Matrix B) const { Matrix C(r, B.c); for (int i = 1; i &lt;= C.r; i++) { for (int j = 1; j &lt;= C.c; j++) { C.m[i][j] = 0; for (int k = 1; k &lt;= c; k++) { C.m[i][j] += ((m[i][k] * B.m[k][j]) % mod) % mod; } } } return C; } Matrix operator ^ (const int p) const { int t = p; Matrix res(r, r), tmp(r, r); res.clear(); for (int i = 1; i &lt;= r; i++) res.m[i][i] = 1; memcpy(tmp.m, m, sizeof(tmp.m)); while (t) { if (t &amp; 1) res = res * tmp; tmp = tmp * tmp; t &gt;&gt;= 1; } return res; }}","link":"/2020/11/24/2020-11-24-Matrix/"},{"title":"「Solution」编码问题[NOIP1995普及+提高]","text":"为上个世纪的题写个题解吧。。。 题面 说明因为本人开始做题习惯从1开始标号，所以在$T = 2$的情况下的数字大小其实是离散化后的大小，要得到$a[i]$直接–就好了。 $T = 1$当$T = 1$时很好做，直接用树状数组求一个顺序对即可。对于求顺序对其实可以直接反着打逆序对。即是在循环$a[i]$时，先输出$query(a[i])$，再在$a[i]$的后面$update(a[i], 1)$就好了。 $T = 2$这个就有点难想了。已知这个数的大小应该是在他前面且比他小的数与在他后面比他小的数的和。可是树状数组只能维护前缀和。那么现在就可以从后往前循环。对于最后一位，它的大小肯定就是给出的$b[i] + 1$，那么倒数第二位数可以分类讨论： 1 假如倒数第一位比倒数第二位大则此值为$(b[i] + 1) + 1$ 2 反之即为$b[i] + 1$那么其实在维护树状数组时只需要查询$b[i] + 1$这个位置就行了。为了在查询时方便，我们在得到上一个数的大小后，应$update(a[i], -1)$，将此点初始化时的增量减带即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 5;int t, n, a[MAXN], b[MAXN];int bit[MAXN], add;int lowbit(int x) { return x &amp; -x;}void update(int x, int k) { for (int i = x; i &lt;= n; i += lowbit(i)) bit[i] += k;}int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += bit[i]; return res;}int main() { scanf (&quot;%d %d&quot;, &amp;t, &amp;n); if (t == 1) { for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d&quot;, &amp;a[i]); a[i] ++; } for (int i = 1; i &lt;= n; i++) { printf (&quot;%d &quot;, query(a[i])); update(a[i], 1); } } else { for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d&quot;, &amp;b[i]); update(i, 1); } for (int i = n; i &gt;= 1; i--) { int l = 1, r = n; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; if (query(mid) &lt;= b[i]) { l = mid + 1; } else r = mid; } a[i] = r; update(r, -1); } for (int i = 1; i &lt;= n; i++) { printf (&quot;%d &quot;, --a[i]); } } return 0;}","link":"/2020/12/01/2020-12-01-%E9%A2%98%E8%A7%A3%20%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E3%80%90NOIP1995%E6%99%AE%E5%8F%8A%20%E6%8F%90%E9%AB%98%E3%80%91/"},{"title":"「Summary」CSP2020总结","text":"前言这是我第一次参加比较大型的比赛，也是我自认为打得最糟糕的一场比赛了，或许是前期模拟赛几起又几落，导致对自己实力概况不太熟悉，一参考心态就紧张的缘故，打pj时智商完全不在线上。还是应该静下来好好总结一下吧。 PJ情况关于pj，我T1看错题，T2没想出来（直到看完，LYR提醒我才想起一个叫桶排的东西），然后没了信心做T3，T4，从考试开始一直慌到结束。分数难以接受，整个人郁闷到了极点。考完之后反省，发现还是基础掌握薄弱，学了一些较为高级的算法后，把最根本的东西忘了，有一些知识点囫囵吞枣略过了。在考试的临场发挥上出了大问题，拿到题后整个人就麻了，心态没有调整好，没有提前做题的预判。 SolutionT1题目看错了，以为必须2的幂连加。这本来就是一个简单的二进制拆分。 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int d[50] = {0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824};int n;vector&lt;int&gt; ans;int main() { scanf (&quot;%d&quot;, &amp;n); if (n % 2 == 1) { printf (&quot;-1\\n&quot;); return 0; } int tmp = n; for (int i = 30; i &gt;= 1; i--) { if (tmp &gt;= d[i]) { tmp -= d[i]; ans.push_back(d[i]); } if (tmp == 0) break; } for (int i = 0; i &lt; ans.size(); i++) { printf (&quot;%d &quot;, ans[i]); } return 0;} T2考场上没看出来，忽略了分数的范围，搞忘了桶排。扫一遍，来一个，桶排加一个，在从600往回找即可。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 5;const int MAXM = 605;int len, w, a, t[MAXM];int main() { scanf (&quot;%d %d&quot;, &amp;len, &amp;w); for (int i = 1; i &lt;= len; i++) { scanf (&quot;%d&quot;, &amp;a); t[a] ++; int p = max(1, (i * w / 100)); int sum = 0, last = 0; for (int i = 600; i &gt;= 0; i--) { sum += t[i]; last = i; if (sum &gt;= p) { break; } } printf (&quot;%d &quot;, last); } return 0;} T3正在调。 T4自认为此题比T3简单。开始想成了spfa，打完发现死循环了，才知道这个图有环，于是又加了几个参数进去跑，还是不行。之后想出了正解，结果初始化值初始化了n*m内的dp（为了避免用memset），然而调了很久一直不对，耗得时间只剩40min还有两道题，被迫写了个暴力。考完突然想起DP初始化要初始全局，因为当第一层有可能被第0层更新（其实特判一下也行。思路比较好想。用dp[i][j][0]表示从上往下走到[i,j]的最大值，dp[i][j][1]表示从下往上走到[i,j]的最大值。从左至右的最大值在这两种状态中也可以更新。 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 1e3 + 5;int n, m;int a[MAXN][MAXN];LL dp[MAXN][MAXN][5];int main() { scanf (&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf (&quot;%d&quot;, &amp;a[i][j]); } } memset(dp, 0xcf, sizeof(dp)); dp[1][0][0] = 0; for (int j = 1; j &lt;= m; j++) { for (int i = 1; i &lt;= n; i++) dp[i][j][0] = max(dp[i - 1][j][0] + a[i][j], max(dp[i][j - 1][1] + a[i][j], dp[i][j - 1][0] + a[i][j])); for (int i = n; i &gt;= 1; i--) dp[i][j][1] = max(dp[i + 1][j][1] + a[i][j], max(dp[i][j - 1][0] + a[i][j], dp[i][j - 1][1] + a[i][j])); } printf (&quot;%lld\\n&quot;, dp[n][m][0]); return 0;} TG情况稍微比PJ好了吧。。。汲取了PJ崩溃的经验，提前浏览了四道题目并且看好了相关限制（但是最后一题还是忘了拼盘），T2太过于自信，结果用了map直接被卡。 T1，T3，T4都没打出来。T1还在调，T3没思路，T4拼盘20pts。 T2思路很简单，用一个$all$或上所有的$a[i]$,然后依次标记每一个$p$即可。注意$k&lt;=64$，这种情况下加一个特判就够了。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL unsigned long longusing namespace std;const int MAXN = 1e6 + 5;const int MAXK = 1e8 + 5;LL n, m, c, k, tot, all;bool vis[MAXK];int main() { scanf (&quot;%llu %llu %llu %llu&quot;, &amp;n, &amp;m, &amp;c, &amp;k); for (int i = 1; i &lt;= n; i++) { LL x; scanf (&quot;%llu&quot;, &amp;x); all |= x; } for (int i = 1; i &lt;= m; i++) { LL q, p; scanf (&quot;%llu %llu&quot;, &amp;p, &amp;q); if (!((1ull&lt;&lt;p) &amp; all)) { if (vis[p] == 0) { vis[p] = 1; tot++; } } } if (k - tot == 64 ) { if (n == 0) { printf (&quot;18446744073709551616\\n&quot;); } else { printf (&quot;%llu\\n&quot;, (1ull&lt;&lt;63) - n + (1ull&lt;&lt;63)); } } else { printf (&quot;%llu\\n&quot;, (1ull&lt;&lt;(k - tot)) - n); } return 0;} 总结pj打得很是郁闷，但这次打击也给我提示了很多：不能好高骛远，最重要的应该是理解每个基础算法的思想，踏实做好接下来的每一题。还是回到起跑线吧。","link":"/2020/12/09/2020-12-09-CSP2020%E6%80%BB%E7%BB%93/"},{"title":"「Solution」图论100题 1~5题","text":"前言咕咕咕了这么久，居然更新了。。。因为本人太菜了，所以掺了点并查集的题凑合。总之这个帖子又复活了。 T1 「NOIP2015」信息传递link题意很清晰了，可以直接用$dfs$找一个最小环。在dfs板子上稍加变动即可。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2 * 1e6 + 5;const int INF = 0x3f3f3f3f;int n, ans, t[MAXN], de[MAXN], num[MAXN], tot;bool vis[MAXN];void dfs(int u, int d) { de[u] = d; num[u] = tot; if (de[t[u]] != 0) { if (num[t[u]] &lt; tot) return ; ans = min(ans, d - de[t[u]] + 1); } else dfs(t[u], d + 1);} int main() { ans = INF; scanf (&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d&quot;, &amp;t[i]); } for (int i = 1; i &lt;= n; i++) { if (de[i] == 0) { tot++; dfs(i, 1); } } printf (&quot;%d\\n&quot;, ans); return 0;} T2 「NOIP2009」最优贸易link step1首先，他可以在图上到处走动，所以很自然地可以建一张图，所有的边权都是0。然后这道题只与水晶球的价格有关，所以我们把点权搬到边权上面。 step2因为他只进行一次买卖，所以有下面两种情况：假设从$u$到$v$，水晶球在$u$的价格为$w$.1.买. 建第二层图，连接第一层图 -&gt; 在$u$和$v$之间建一条边边权为$-w$。2.卖. 建第三层图，连接第二层图 -&gt; 在$u$和$v$之间建一条边边权为$w$。 step3我们在最后有两种方法走向终点： 不买卖直接走向终点直接在第一层图的n号节点建立边权为0的有向边接入一个“大终点” 买卖一次后走向终点在第三层图的n号节点建立边权为0的有向边接入“大终点” 至此，这道题就只需要求一个最长路即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100005 * 3 + 1;int n, m, a[MAXN];bool vis[MAXN];int dis[MAXN];queue&lt;int&gt; q;void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &gt; '9' || c &lt; '0') { if (c == '-') f = -f; c = getchar(); } while (c &lt;= '9' &amp;&amp; c &gt;= '0') { x = x * 10 + c - '0'; c = getchar(); } x *= f;}struct edge { int v, w; edge(){} edge(int V, int W) { v = V; w = W; }};vector&lt;edge&gt; G[MAXN];void AddEdge(int u, int v, int w) { G[u + n * 0].push_back(edge(v + n * 0, 0)); G[u + n * 1].push_back(edge(v + n * 1, 0)); G[u + n * 2].push_back(edge(v + n * 2, 0)); G[u + n * 0].push_back(edge(v + n * 1, -w)); G[u + n * 1].push_back(edge(v + n * 2, w));}void Spfa() { memset(vis, 0, sizeof(vis)); memset(dis, 0xcf, sizeof(dis)); dis[1] = 0; vis[1] = 1; q.push(1); while (q.size()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i].v, w = G[u][i].w; if (dis[v] &lt; dis[u] + w) { dis[v] = dis[u] + w; if (vis[v] == 0) { vis[v] = 1; q.push(v); } } } } printf (&quot;%d\\n&quot;, dis[n]);}int main() { read(n); read(m); for (int i = 1; i &lt;= n; i++) { read(a[i]); } for (int i = 1, u, v, opt; i &lt;= m; i++) { read(u), read(v), read(opt); AddEdge(u, v, a[u]); if (opt == 2) { AddEdge(v, u, a[v]); } } G[n].push_back(edge(n * 3 + 1, 0)); G[n * 3].push_back(edge(n * 3 + 1, 0)); n *= 3; n++; Spfa(); return 0;} T3「Uva 10004」二染色做了四色问题后调的一道题。又是$dfs$，提前给0节点涂上-1，然后在每次处理时判断两个地方。1.如果没访问，就去递归，每次都涂上相反的颜色。2.如果访问过，并且涂上了现在相同的颜色，直接返回0。 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 205; int n, m, p[MAXN];vector&lt;int&gt; G[MAXN];bool dfs(int u, int last) { p[u] = -last; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (p[v] != 0 &amp;&amp; p[v] == p[u]) return false; if (p[v] == 0 &amp;&amp; dfs(v, p[u]) == 0) return false; } return true;}int main() { while (scanf (&quot;%d&quot;, &amp;n), n) { scanf (&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= n; i++) G[i].clear(); for (int i = 1, u, v; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } memset(p, 0, sizeof(p)); if (dfs(0, -1)) printf (&quot;BICOLORABLE\\n&quot;); else printf (&quot;NOT BICOLORABLE\\n&quot;); } return 0;} T4巡逻这道题就有点意思了，但我的做法不是最优的。如果想找到更好的解法，可以问问lifan。在这里有两种情况： 1.k = 1比较显然，当在没有修路的时候，按照dfs的顺序(访问和回溯)应该将每条边访问两遍。假设我们在$u$和$v$之间建一条边，那么在$u$到$v$的唯一路径上的所有道路都只用访问一边，即将$2\\times(n - 1)$条边变成了$2 \\times (n - 1)-Lenth_{(u,v)}$。那么要是删掉的边最多，可以直接想到，求出直径，然后将它删掉。 2.k = 2这种情况就有点难想了。那么在求出最长边后(直径)，在求出次长边即可，可是当两条边重合时需要将重合的边加上，即警察会将每条边访问一次。求两条边的重合部分写出来很麻烦，有没有更简单的方法呢?可以回到式子上：$2 \\times (n - 1)-Lenth_1-Lenth_2+Lenth_3$，$Lenth_3$即为两边的重合边。可以想到：$2 \\times (n - 1)-Lenth_1-Lenth_2+Lenth_3 = 2 \\times (n - 1)-Lenth_1-(Lenth_2-Lenth_3)$。来到这一步其实已经很清晰了。可以在求完直径时，把直径上的边全部取反成-1,那么再求次长边时就可以直接减去此长度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;map&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;int n, l1, l2, far, k, d[MAXN], pre[MAXN], last, way[MAXN], cnt;vector&lt;int&gt; G[MAXN];bool vis[MAXN];map&lt;pair&lt;int, int&gt;, bool&gt; add;void dfs(int&amp; tmp, int u, int fa) { if (tmp &lt; d[u]) { tmp = d[u]; last = u; far = u; } for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == fa) continue; d[v] = d[u] + 1; pre[v] = u; dfs(tmp, v, u); }}void dpdfs(int u) { vis[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v] == 0) { dpdfs(v); int w = 1; if (add[make_pair(u, v)] == 1 || add[make_pair(v, u)] == 1) w = -1; l2 = max(l2, d[u] + d[v] + w); d[u] = max(d[u], d[v] + w); } }}void print(int p) { if (pre[p] == 0) { way[++cnt] = p; return; } print(pre[p]); way[++cnt] = p;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for (int i = 1, u, v; i &lt; n; i++) { scanf(&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(l1, 1, 0); d[far] = 0; memset(pre, 0, sizeof(pre)); dfs(l1, far, 0); if (k == 1) { printf(&quot;%d\\n&quot;, (n - 1) * 2 - (l1 - 1)); return 0; } else { print(last); for (int i = 1; i &lt;= cnt; i++) { add[make_pair(way[i], way[i + 1])] = 1; } memset(d, 0, sizeof(d)); dpdfs(1); printf(&quot;%d\\n&quot;, (n - 1) * 2 - (l1 - 1) - (l2 - 1)); } return 0;} T5 「CF9E」Interesting Graph and Appleslink这是OJ上为数不多的能看清题面的CF的题。我还是简单翻译一下吧。题意：在$n$个点$m$条边的图上添加最少的边，使其成为一个大环。水入并查集，再添加两条边的时候，可以将他们加入一个集合里。并更新度。如果其中有点的入度$&gt;2$那么输出$NO$，因为在一个环中，每个节点的度至多为2，且此题不能删边，可以直接结束。然后依次选择两个节点，如果它们的度都小于2，并且没有在一个集合中，就可以把它们加在一起，然后更新度数。在加边完成之后，会出现总边只有$n-1$的情况，此时找到剩下两个度为1的点，把它们连在一起即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 55;int n, m;int deg[MAXN], fa[MAXN];void MakeSet(int n) { for (int i = 1; i &lt;= n; i++) fa[i] = i;}int FindSet(int v) { if (fa[v] == v) return v; else return fa[v] = FindSet(fa[v]);}void UnionSet(int u, int v) { int x = FindSet(u); int y = FindSet(v); if (x == y) return; fa[x] = fa[y]; return;}struct node { int u, v; node(){} node(int U, int V) { u = U; v = V; }};vector&lt;node&gt; ans;int main() { scanf (&quot;%d %d&quot;, &amp;n, &amp;m); MakeSet(n); for (int i = 1, u, v; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); deg[u]++, deg[v]++; UnionSet(u, v); } for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 2) { printf (&quot;NO\\n&quot;); return 0; } for (int i = 1; i &lt;= n; i++) { for (int j = i + 1; j &lt;= n; j++) if (FindSet(i) != FindSet(j) &amp;&amp; deg[i] &lt; 2 &amp;&amp; deg[j] &lt; 2) { ans.push_back(node(i, j)); deg[i]++, deg[j]++; UnionSet(i, j); } } if (ans.size() + m == n - 1) { int u = 0, v = 0; for (int i = 1; i &lt;= n; i++) { if (deg[i] &lt; 2) { deg[i]++; if (u == 0) u = i; else v = i; } } ans.push_back(node(u, v)); } for (int i = 1; i &lt;= n; i++) { if (FindSet(i) != FindSet(1)) { printf (&quot;NO\\n&quot;); return 0; } } printf (&quot;YES\\n%d\\n&quot;, ans.size()); for (int i = 0; i &lt; ans.size(); i++) { node now = ans[i]; printf (&quot;%d %d\\n&quot;, now.u, now.v); } return 0;}","link":"/2020/12/17/2020-12-17-%E5%9B%BE%E8%AE%BA100%E9%A2%98%201~5%E9%A2%98/"},{"title":"「Solution」定价","text":"Link思路其实就是一道水题。只要打出了T 20pts的代码，那么你离AC就相差无几了。其实可以发现如果你在算了100之后并不需要去算101~999。那么可以直接人口普查，跑一遍，每次在循环$i++$时改成$i+=add$即可。至于$add$就是一眼的事情了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int Add[15] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};int t, l, r;int change(int num) { while (num % 10 == 0) { num /= 10; } int power = 1; int len = 0; for (int i = 1; i &lt;= 9; i++) { power *= 10; if (power &gt;= num) { len = i; break; } } int last = num % 10; if (last == 5) { return len * 2 - 1; } else return len * 2;}int add(int x) { int tot = 0; while (x % 10 == 0) { x /= 10; tot++; } return tot;}int main() { scanf (&quot;%d&quot;, &amp;t); while (t--) { scanf (&quot;%d %d&quot;, &amp;l, &amp;r); int ans = 50; int num; for (int i = l; i &lt;= r; i += Add[add(i)]) { if (change(i) &lt; ans) { ans = change(i); num = i; } } printf (&quot;%d\\n&quot;, num); } return 0;}","link":"/2020/12/17/2020-12-17-%E5%AE%9A%E4%BB%B7%20%E6%80%9D%E8%B7%AF/"},{"title":"「Note」数位DP","text":"占坑，先咕着","link":"/2020/12/19/2020-12-19-%E6%95%B0%E4%BD%8DDP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"「Note」SegmentTree","text":"线段树模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 * 4 + 5;int n, m, a[MAXN];struct SegmentTree { int l, r; int dat;} s[MAXN];void build(int p, int l, int r) { s[p].l = l, s[p].r = r; if (l == r) { s[p].dat = a[l]; return; } int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); s[p].dat = max(s[p * 2].dat, s[p * 2 + 1].dat);}void update(int p, int x, int val) { if (s[p].l == s[p].r) { s[p].dat = val; return; } int mid = (s[p].l + s[p].r) / 2; if (x &lt;= mid) update(p * 2, x, val); else update(p * 2 + 1, x, val); s[p].dat = max(s[p * 2].dat, s[p * 2 + 1].dat);}int query(int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) { return s[p].dat; } int mid = (s[p].l + s[p].r) / 2; int val = (-(1 &lt;&lt; 30)); if (l &lt;= mid) val = max(val, query(p * 2, l, r)); if (r &gt; mid) val = max(val, query(p * 2 + 1, l, r)); return val;}int main() { scanf (&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d&quot;, &amp;a[i]); } build(1, 1, n); scanf (&quot;%d&quot;, &amp;m); while (m--) { int opt; scanf (&quot;%d&quot;, &amp;opt); if (opt == 1) { int x, val; scanf (&quot;%d %d&quot;, &amp;x, &amp;val); update(1, x, val); } else { int l, r; scanf (&quot;%d %d&quot;, &amp;l, &amp;r); printf (&quot;%d\\n&quot;, query(1, l, r)); } } return 0;}","link":"/2020/12/22/2020-12-22-SegmentTree/"},{"title":"「Note」权值线段树","text":"权值线段树初步 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;const int MAXM = 1e9;int q, tot = 1;struct SegmentTree { int lc, rc; int cnt, del;} s[MAXN * 30];void pushup(int p) { s[p].cnt = s[s[p].lc].cnt + s[s[p].rc].cnt; return;}void pushdown(int p) { if (s[p].del == 1) { s[p].del = 0; s[s[p].lc].del = 1; s[s[p].rc].del = 1; s[s[p].lc].cnt = 0; s[s[p].rc].cnt = 0; } }void update(int p, int l, int r, int id) { if (l == r) { s[p].del = 0; s[p].cnt++; return; } pushdown(p); int mid = (l + r) &gt;&gt; 1; if (id &lt;= mid) { if (s[p].lc == 0) s[p].lc = ++tot; update(s[p].lc, l, mid, id); } else { if (s[p].rc == 0) s[p].rc = ++tot; update(s[p].rc, mid + 1, r, id); } pushup(p);}void clean(int p, int l, int r, int ql, int qr) { if (s[p].cnt == 0 || s[p].del == 1 || p == 0) return; if (l &gt;= ql &amp;&amp; qr &gt;= r) { s[p].cnt = 0; s[p].del = 1; return; } pushdown(p); int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) { clean(s[p].lc, l, mid, ql, qr); } if (qr &gt; mid) { clean(s[p].rc, mid + 1, r, ql, qr); } pushup(p);}int sum(int p, int l, int r, int ql, int qr) { if (s[p].cnt == 0 || s[p].del == 1 || p == 0) return 0; if (l &gt;= ql &amp;&amp; qr &gt;= r) { return s[p].cnt; } pushdown(p); int val = 0; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) { val += sum(s[p].lc, l, mid, ql, qr); } if (qr &gt; mid) { val += sum(s[p].rc, mid + 1, r, ql, qr); } return val;}int querykth(int p, int l, int r, int ql, int qr, int k) { if (s[p].cnt == 0 || s[p].del == 1 || p == 0) return -1; if (l == r) { if (s[p].cnt &gt;= k) return l; else return -1; } pushdown(p); int mid = (l + r) &gt;&gt; 1, cnt = 0; if (qr &gt; mid) { cnt = sum(s[p].rc, mid + 1, r, ql, qr); if (cnt &gt;= k) return querykth(s[p].rc, mid + 1, r, ql, qr, k); } if (ql &lt;= mid) { return querykth(s[p].lc, l, mid, ql, qr, k - cnt); } return -1;}int main() { scanf (&quot;%d&quot;, &amp;q); while (q--) { int opt, x, l, r, k; scanf (&quot;%d&quot;, &amp;opt); if (opt == 1) { scanf (&quot;%d&quot;, &amp;x); update(1, 1, 1e9, x); } if (opt == 2) { scanf (&quot;%d %d&quot;, &amp;l, &amp;r); clean(1, 1, 1e9, l, r); } if (opt == 3) { scanf (&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k); printf (&quot;%d\\n&quot;, querykth(1, 1, 1e9, l, r, k)); } } return 0;}","link":"/2021/01/01/2021-01-01-%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91%20Query%20the%20Kth%20Number/"},{"title":"「Solution」AtCoder[abc183]Code","text":"打了一下abc的题，好简单。留档存个代码吧。 A有手就行。 12345678910111213141516#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long x;int main() { scanf (&quot;%lld&quot;, &amp;x); if (x &gt;= 0) { printf (&quot;%lld\\n&quot;, x); } else { printf (&quot;0\\n&quot;); } return 0;} B相似… 12345678910111213141516#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define db doubleusing namespace std;db sx, sy, tx, ty;db t, ans;int main() { scanf (&quot;%lf %lf %lf %lf&quot;, &amp;sx, &amp;sy, &amp;tx, &amp;ty); t = (tx - sx) / (sy + ty) * sy; ans = sx + t; printf (&quot;%.10lf\\n&quot;, ans); return 0;} C无脑爆搜即可。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 15;int n, k;int dis[MAXN][MAXN], ans;bool vis[MAXN];void dfs(int now, int tot, int sum) { if (tot == n) { sum += dis[now][1]; if (sum == k) { ans++; } return; } for (int i = 2; i &lt;= n; i++) { if (i == now || vis[i] == 1) continue; vis[i] = 1; dfs(i, tot + 1, sum + dis[now][i]); vis[i] = 0; }}int main() { scanf (&quot;%d %d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { scanf (&quot;%d&quot;, &amp;dis[i][j]); } } dfs(1, 1, 0); printf (&quot;%d\\n&quot;, ans); return 0;} D开始还把题看错了。直接差分搞。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 2 * 1e5 + 5;int n, w, m;LL a[MAXN];int main() { scanf (&quot;%d %d&quot;, &amp;n, &amp;w); for (int i = 1, s, t, q; i &lt;= n; i++) { scanf (&quot;%d %d %d&quot;, &amp;s, &amp;t, &amp;q); a[s] += q, a[t] -= q; m = max(m, t); } for (int i = 0; i &lt; m; i++) { a[i] += a[i - 1]; if (a[i] &gt; w) { printf (&quot;No\\n&quot;); return 0; } } printf (&quot;Yes\\n&quot;); return 0;} E前缀和优化DP 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 2005;const int mod = 1e9 + 7;int n, m;LL dp[MAXN][MAXN], sum[MAXN][MAXN][5];bool vis[MAXN][MAXN];int main() { scanf (&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { char x; cin &gt;&gt; x; if (x == '.') { vis[i][j] = 1; } } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (vis[i][j] == 1) { dp[i][j] = (sum[i - 1][j][1] + sum[i][j - 1][2] + sum[i - 1][j - 1][3]) % mod; if (i == 1 &amp;&amp; j == 1) dp[i][j]++; sum[i][j][1] = (sum[i - 1][j][1] + dp[i][j]) % mod; sum[i][j][2] = (sum[i][j - 1][2] + dp[i][j]) % mod; sum[i][j][3] = (sum[i - 1][j - 1][3] + dp[i][j]) % mod; } } } printf (&quot;%lld\\n&quot;, dp[n][m]); return 0;} F改良版的并查集。要用$map$离散化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2 * 1e5 + 5;struct node { map&lt;int, int&gt; tot; int f, id, c;} fa[MAXN];int FindSet(int v) { if (fa[v].f == fa[v].id) { return fa[v].f; } else return fa[v].f = FindSet(fa[v].f);}void UnionSet(int u, int v) { int x = FindSet(u); int y = FindSet(v); if (fa[x].f == fa[y].f) return; map&lt;int, int&gt;::iterator it; for (it = fa[x].tot.begin(); it != fa[x].tot.end(); it++) { if (fa[y].tot.find(it -&gt; first) == fa[y].tot.end()) { fa[y].tot[it -&gt; first]++; } } fa[x].f = fa[y].f;}int n, q;int main() { scanf (&quot;%d %d&quot;, &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d&quot;, fa[i].c); fa[i].f = i, fa[i].id = i, fa[i].tot[fa[i].c]++; } while (q--) { int opt, x, y; scanf (&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y); if (opt == 1) { UnionSet(x, y); } else { printf (&quot;%d\\n&quot;, fa[x].tot[y]); } } return 0;} END","link":"/2021/01/12/2021-01-12-AtCoder%5Babc183%5DCode/"},{"title":"「Note」单调队列","text":"12345678910111213141516171819struct Deque { int head, tail, n, m, q[MAXN], a[MAXN], p; Deque(){} Deque(int n, int m, int head, int tail, int p) : n(n), m(m), head(head), tail(tail), p(p){}; int get(int id) { int res = a[q[head]]; while (id - q[head] &gt;= m &amp;&amp; head &lt;= tail) head++; while (a[id] &lt;= a[q[tail]] &amp;&amp; head &lt;= tail) tail--; q[++tail] = id; return res * p; } void scan() { for (int i = 1; i &lt;= n; i++) scanf (&quot;%d&quot;, &amp;a[i]), a[i] *= p; } }","link":"/2021/02/01/2021-02-01-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"title":"「Solution」友谊赛","text":"今天友谊赛题解，上届巨佬写的，搬上了方便查看。 A-Rainyrabbit 爱邮递算法 1每次重建快递站后直接深搜一遍累加贡献就好了，然后 $\\mathcal{O}(1)$ 回答。 你可以获得 10pts 的好成绩。 算法 2菊花图，这个很简单啊。 如果加的是花心，相当于其他城市都加 $1$，否则就是花心的城市加 $1$，其他城市加 $2$。 结合算法 1 可以获得 30pts 的好成绩。 算法 3一条链的话也是送的，直接拆拆贡献用棵线段树维护即可。 结合算法 1,2 可以获得 60pts 的好成绩。 算法 4做法 1 考虑树怎么做，很套路的可以将 $dis(x,y)$ 拆成 $dep_x+dep_y-2dep_{\\operatorname{lca}(x,y)}$，但是拆了还是不好做，修改最坏还是 $\\mathcal{O(n)}$ 的。 发现 $dep_{\\operatorname{lca}(x,y)}$ 这个玩意可以借助 [LNOI2014]LCA 的思想，将树根 $1$ 到 $x$ 上的边都加上一次这条边的权值，然后节点 $y$ 往上爬，途中边排边累加该边的贡献，爬到根后就是 $dep_{\\operatorname{lca}(x,y)}$ 的值。 于是便有了一个新的算法，对于重建快递站到 $u$，直接将 $u$ 往上爬，并更新每条边新的贡献，查询的话就跟刚才一样的往上爬就好了。 暴力往上爬的话可以过数据随机的点，然后结合算法 1,2,3 就能获得 80pts 的好成绩。 正解直接用树链剖分优化即可。 时间复杂度 $\\mathcal{O}(n\\log^2 n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define LL long long#define int long longint n, m, totdep, tot, a[200005], Dep[200005], fa[200005], size[200005], dep[200005], son[200005], seg[200005], rev[200005], top[200005];struct node { int to, w;};vector&lt;node&gt; G[200005];void dfs1(int u, int f) { size[u] = 1, dep[u] = dep[f] + 1, fa[u] = f; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i].to; if (v == f) continue; Dep[v] = Dep[u] + G[u][i].w; a[v] = G[u][i].w; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; }}void dfs2(int u, int f) { if (son[u]) { seg[son[u]] = ++seg[0]; top[son[u]] = top[u]; rev[seg[0]] = son[u]; dfs2(son[u], u); } for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i].to; if (v == f) continue; if (!top[v]) { seg[v] = ++seg[0]; top[v] = v; rev[seg[0]] = v; dfs2(v, u); } }}struct Segment_Tree { struct node { LL xsum, sum, lazy; }; node tree[800005];#define lson(x) x &lt;&lt; 1#define rson(x) x &lt;&lt; 1 | 1 void build(int x, int l, int r) { if (l == r) { tree[x].sum = a[rev[l]]; return; } int mid = (l + r) &gt;&gt; 1; build(lson(x), l, mid); build(rson(x), mid + 1, r); tree[x].sum = tree[lson(x)].sum + tree[rson(x)].sum; tree[x].xsum = tree[lson(x)].xsum + tree[rson(x)].xsum; } void push_down(int x) { if (tree[x].lazy) { tree[lson(x)].lazy += tree[x].lazy; tree[rson(x)].lazy += tree[x].lazy; tree[lson(x)].xsum += tree[x].lazy * tree[lson(x)].sum; tree[rson(x)].xsum += tree[x].lazy * tree[rson(x)].sum; tree[x].lazy = 0; } } void add(int x, int l, int r, int L, int R) { if (L &lt;= l &amp;&amp; r &lt;= R) { tree[x].lazy++; tree[x].xsum += tree[x].sum; return; } push_down(x); int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) add(lson(x), l, mid, L, R); if (mid + 1 &lt;= R) add(rson(x), mid + 1, r, L, R); tree[x].xsum = tree[lson(x)].xsum + tree[rson(x)].xsum; } LL query(int x, int l, int r, int L, int R) { if (L &lt;= l &amp;&amp; r &lt;= R) return tree[x].xsum; LL ans = 0; int mid = (l + r) &gt;&gt; 1; push_down(x); if (L &lt;= mid) ans += query(lson(x), l, mid, L, R); if (mid + 1 &lt;= R) ans += query(rson(x), mid + 1, r, L, R); return ans; }} T;void change(int u) { while (u) { int fu = top[u]; T.add(1, 1, n, seg[fu], seg[u]); u = fa[fu]; }}LL query(int u) { LL ans = 0; while (u) { int fu = top[u]; ans += T.query(1, 1, n, seg[fu], seg[u]); u = fa[fu]; } return ans;}signed main() { scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) { int u, v, w; scanf(&quot;%lld %lld %lld&quot;, &amp;u, &amp;v, &amp;w); G[u].push_back(node{ v, w }); G[v].push_back(node{ u, w }); } dfs1(1, 0); seg[0] = 1, seg[1] = 1, top[1] = rev[1] = 1; dfs2(1, 0); T.build(1, 1, seg[0]); while (m--) { int opt, u; scanf(&quot;%lld %lld&quot;, &amp;opt, &amp;u); if (opt == 1) change(u), totdep += Dep[u], tot++; else printf(&quot;%lld\\n&quot;, totdep + 1ll * tot * Dep[u] - 2 * query(u)); } return 0;} 做法 2 来自巨佬 WY 的做法，cdq 分治+虚树。 B-Rainyrabbit 爱回文很遗憾，因为数据过水，导致有 5 人 AC，但是本质上只有 3 人写的正解，其他的时间复杂度都是错的。 多次询问一个字符串 $s$，问构造若干字符串 $t_1,t_2,\\cdots ,t_k$ 使得 $s=t_1t_2\\cdots t_k$ 并且 $\\forall i \\in [1,k],t_i \\geq 2$ 并且是回文串的方式是否存在。$T \\leq 10,|s| \\leq 10^6$。 首先每次选最大的回文串肯定是错的。具体看这个串 ababallllllab。 先求出 $f$，$f_i$ 为以字符 $i$ 为开头的最短回文串长度。 考虑这个辅助数组的作用。假设我们的合法划分方案，在这里的划分出来的回文串长度是 $d$，那么这个 $f_i$ 与 $d$ 的关系是什么呢？ 首先，显然 $f_i \\leq d$。分类讨论： $f_i = d$：那没事儿了。 $f_i &lt; \\dfrac{d}{2}$：显然我们可以将这个字符串 $d$ 看成三个回文串，也就是一段 $f_i$，以最后一个字符为中心对称过去，或者是再恰一个字符再对称，或者是直接对称过去； 否则这种情况是不可能的，因为这样我们能够找到更小的前缀回文串。可以自行理解。注意这个更小的前缀回文串可能是一个字母，需要特判。 综上，以 $i$ 开头的回文串长度的选择只有四个：$f_i,2f_i-1,2f_i+1,2f_i$。可以证明其可以涵盖所有情况。剩下的工作就是做个 dp。 考虑求出这个 $f$ 数组。有三种做法，时间复杂度分别是 $O(n \\log n),O(n \\alpha(n))$。标程给的是 $O(n\\log n)$ 的做法。$O(n \\alpha(n))$ 做法由 @chihik 提出。 理论上来说有 $O(n)$ 的做法，但是我太菜没听懂 @crashed 再说啥。 $O(n \\log n)$考虑对于每一个字符，求出以它为中心（中心可以是和下一个字符结合也可以是一个字符，这个是两类）的最长回文串，在其左端点打上标记。标记记录三个值，表示其起始位置，有效长度及中心是和下一个字符结合还是一个字符。做法是 hash 二分。你高兴也可以 manacher。 这个东西的意义是，我们选择的 $f_i$，一定是离有效范围内结束最近的那个位置的距离。于是处理三个东西，可以发现这个东西可以全部拍进 set 里面选最小的且合法的。具体处理方法看代码。 代码有个小补丁，就是要处理两个相邻字符相同的情况。这个时候直接把 $f_i$ 设为 $2$ 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/*LL JJ SSSS ii ssss SSSS BBBBLL JJ S s S B BLL JJ SSS ii sss SSS BBBBLL JJ JJ S ii s S B BLLLLLL JJJJ SSSS ii ssss SSSS BBBB SSSS BBBB ii ssss LL JJ SSSSS B B s LL JJ S SSS BBBB ii sss LL JJ SSS S B B ii s LL JJ JJ SSSSS BBBB ii ssss LLLLLL JJJJ SSSS*/#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ULL;const ULL base=10086001;ULL lhsh[3000005],rhsh[3000005],pw[3000005];char s[3000005];ULL getHashL(int l,int r){return lhsh[r]-lhsh[l-1]*pw[r-l+1];}ULL getHashR(int l,int r){return rhsh[l]-rhsh[r+1]*pw[r-l+1];}int n,f[3000005];bool isPalindrome(int l,int r){return getHashL(l,r)==getHashR(l,r);}struct pldrome{ int pos,len,type; pldrome(int R=0,int L=0,int T=0){pos=R,len=L,type=T;} bool operator != (const pldrome ano) const {return pos!=ano.pos || len!=ano.len || type!=ano.type;} bool operator &lt; (const pldrome ano) const { int ps=pos,ln=len,tp=type,pst=ano.pos,lnt=ano.len,tpt=ano.type; if(tp==0) --ln; if(tpt==0) --lnt; int ed1=ps+ln-1,ed2=pst+lnt-1; return ed1&lt;ed2; }};vector&lt;pldrome&gt; G[3000005];bool dp[3000005];int main(){ pw[0]=1; for(int i=1;i&lt;=3000000;++i) pw[i]=pw[i-1]*base; int T; scanf(&quot;%d&quot;,&amp;T); dp[0]=true; while(T--&gt;0) { scanf(&quot;%s&quot;,s+1); n=strlen(s+1); for(int i=1;i&lt;=n;++i) lhsh[i]=lhsh[i-1]*base+ULL(s[i]),f[i]=0; for(int i=n;i&gt;=1;--i) rhsh[i]=rhsh[i+1]*base+ULL(s[i]),dp[i]=false; for(int i=1;i&lt;=n;++i) { if(i==1) { if(isPalindrome(1,2)) G[1].push_back(pldrome(1,1,1)); } else if(i==n-1) { if(isPalindrome(n-1,n)) G[n-1].push_back(pldrome(n-1,1,1)); if(isPalindrome(n-2,n)) G[n-2].push_back(pldrome(n-2,2,0)); } else if(i==n) continue; else { //i is medium int l=0,r=min(i-1,n-i),ans=0; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(isPalindrome(i-mid,i+mid)) ans=mid,l=mid+1; else r=mid-1; } if(ans) G[i-ans].push_back(pldrome(i-ans,ans+1,0)); l=0,r=min(i-1,n-i-1),ans=0; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(isPalindrome(i-mid,i+1+mid)) ans=mid,l=mid+1; else r=mid-1; } if(ans) G[i-ans].push_back(pldrome(i-ans,ans+1,1)); else { if(isPalindrome(i,i+1)) G[i].push_back(pldrome(i,1,1)); } } } set&lt;pldrome&gt; S; for(int i=1;i&lt;=n;++i) { while(!G[i].empty()) S.insert(G[i].back()),G[i].pop_back(); while(!S.empty()) { pldrome st=*S.begin(); int ps=st.pos,ln=st.len,tp=st.type; if(tp==0) --ln; int ed=ps+ln-1; if(ed&lt;i) { S.erase(S.begin()); continue; } if(tp==0) { ++ed; int edTrue=2*ed-i; f[i]=edTrue-i+1; } else { int edTrue=2*ed-i+1; f[i]=edTrue-i+1; } break; } if(S.empty()) f[i]=-1; if(i&lt;=n-1 &amp;&amp; isPalindrome(i,i+1)) f[i]=2; } for(int i=1;i&lt;=n;++i) { if(f[i]==-1 || !dp[i-1]) continue; dp[i+f[i]-1]=true; int sp=2*f[i]-1; if(isPalindrome(i,i+sp-1)) dp[i+sp-1]=true; sp+=2; if(isPalindrome(i,i+sp-1)) dp[i+sp-1]=true; --sp; if(isPalindrome(i,i+sp-1)) dp[i+sp-1]=true; } puts(dp[n]?&quot;YeseY&quot;:&quot;NoN&quot;); } return 0;} $O(n \\alpha (n))$ By @chihik考虑回文自动机。一样的思路，求出以某位为起点的最长回文串。暴力回跳。显然 T，于是并查集优化即可。 $O(n)$ By crashed / LY（初二）本意是选联赛范围考察。但是因为大家都会回文自动机所以被踩了。反正其实我也不会。 具体做法是链上排一次序（基排 By crashed）。 C-Rainyrabbit 爱求和菜鸡出的垃圾套路题。/kk 算法 1测试点 $1$ 随便手玩。 期望得分 4 分。 算法 2测试点 $2\\sim 3$ 按照题意模拟。 期望得分 12 分。 算法 3测试点 $4\\sim 5$ 先在外面直接算然后直接回答。 期望得分 20 分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longconst int mod=998244353;int dec(int x, int y) { return x &gt;= y ? x - y : x + mod - y; }int mul(int x, int y) { return 1ll * x * y % mod; }int add(int x, int y) { if (x + y &gt;= mod) return x + y - mod; return x + y;}int qkpow(LL a, LL b) { int res = 1; for (; b; b &gt;&gt;= 1, a = mul(a, a)) if (b &amp; 1) res = mul(res, a); return res;}int t,mem[105][105][105];LL a,b,c;LL lcm(LL a,LL b){ return a/__gcd(a,b)*b;}LL sigma(LL n,LL k){ LL ans=0; for(int i=1;i&lt;=n;i++){ if(n%i==0)ans=add(ans,qkpow(i,k)); } return ans;}LL f(LL n,LL m,LL k){ LL ans=0; for(LL i=m;i&lt;=n;i+=m)ans=add(ans,sigma(i,k)); return ans;}signed main(){ cin&gt;&gt;t&gt;&gt;c; for(int i=1;i&lt;=100;i++) for(int j=1;j&lt;=100;j++) for(int k=0;k&lt;=c;k++) mem[i][j][k]=k==0?f(i,j,0):add(mem[i][j][k-1],f(i,j,k)); for(int i=1;i&lt;=100;i++){ for(int j=1;j&lt;=100;j++){ mem[i][j][c]=add(mem[i][j][c],add(mem[i][j-1][c],mem[i-1][j][c])); mem[i][j][c]=dec(mem[i][j][c],mem[i-1][j-1][c]); } } while(t--){ cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;mem[a][b][c]&lt;&lt;endl; } return 0;} /*5 54 1 3 6 21 2 42 1 30 0 3 21 1 22 2 4*/ 算法 4送分结束。 来推一推 $f$ 函数。 $$f(n,m,k)=\\sum_{d=1}^n d^k \\lfloor\\dfrac{n}{\\operatorname{lcm}(d,m)}\\rfloor=\\sum_{d=1}^n d^k \\lfloor\\dfrac{\\dfrac{n}{d}}{\\lfloor\\dfrac{m}{\\gcd(d,m)}\\rfloor}\\rfloor$$ 这个东西是有意义的，$\\sum_{d=1}^n d^k \\lfloor\\dfrac{\\dfrac{n}{d}}{\\lfloor\\dfrac{m}{\\gcd(d,m)}\\rfloor}\\rfloor=\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}[id|m]$ 然后拆回来 $$f(n,m,k)=\\sum_{m|i}^n \\sum_{d|i}d^k=\\sum_{m|i}^n \\sigma_k(i)$$ 结论就推完了。 代回去 $$\\sum_{k=0}^c\\sum_{i=1}^a\\sum_{j=1}^b\\sum_{j|p}^i\\sigma_k(p)$$ $$\\sum_{k=0}^c\\sum_{p=1}^a\\sigma_k(p)(a-p+1)\\sum_{j=1}^b[j|p]$$ $\\sigma_k(p)$ 那里可以直接把 $\\sigma_0(p),\\sigma_1(p)…,\\sigma_c(p)$ 都累加到一坨，然后直接 $\\mathcal{O}(n^2)$ 计算即可。 跟刚才一样的操作，先在外面都算出来再回答，可以获得 36pts 的好成绩。 算法 5发现 $b$ 的那个求和并不需要一个一个算，直接调和级数复杂度算就好了，然后就能获得 40 pts。 算法 6$c$ 太大了，推一推怎么算 $\\sum_{i=0}^c \\sigma_i(p)$。 $$\\sum_{i=0}^c \\sum_{d|p}d^i$$ 发现对于每一个因子的贡献都是一个等比数列。 $$\\sum_{d|p}\\dfrac{d^{c+1}-1}{d-1}$$ 线性筛后调和级数算就好了，然后就能获得 68 pts 了。 算法 7发现 $b$ 超过 $a$ 的范围以后是不会有任何贡献的，于是取个 $\\min$ 算，至此就能获得 80 pts 的好成绩。 算法 8这东西并不好多组询问，$a,b$ 变来变去的很烦。 考虑离线，将每一个询问按照 $b$ 排序。当 $b=i$ 时能影响到的位置是 $\\dfrac{n}{i}$ 个，直接树状数组修改即可。修改完后，直接查询就好了。 时间复杂度 $\\mathcal{O}(a\\ln a+T\\log T+\\min(a,b)\\ln \\min(a,b)\\log a+T\\log a)$。 由于这东西并跑不满，跑 $10^6$ 是跑的过的。代码及其好写。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int mod = 998244353;int dec(int x, int y) { return x &gt;= y ? x - y : x + mod - y; }int mul(int x, int y) { return 1ll * x * y % mod; }int add(int x, int y) { if (x + y &gt;= mod) return x + y - mod; return x + y;}int qkpow(LL a, LL b) { int res = 1; for (; b; b &gt;&gt;= 1, a = mul(a, a)) if (b &amp; 1) res = mul(res, a); return res;}int T, cnt, maxa, a[200005], prime[1000005], pw[1000005], inv[1000005], f[1000005], s[1000005], anos[1000005], ans[1000005];bool vis[1000005];LL b[200005], c;struct node { int id, a;};vector&lt;node&gt; G[1000005];struct BIT { int tree[1000005]; void Add(int x, int val) { while (x &lt;= maxa) { tree[x] = add(tree[x], val); x += x &amp; (-x); } } int query(int x) { int Ans = 0; while (x) { Ans = add(Ans, tree[x]); x -= x &amp; (-x); } return Ans; }} T1, T2;void seive() { pw[1] = 1; for (int i = 2; i &lt;= 1000000; i++) { if (!vis[i]) prime[++cnt] = i, pw[i] = qkpow(i, c + 1); for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= 1000000; j++) { vis[i * prime[j]] = 1; pw[i * prime[j]] = mul(pw[i], pw[prime[j]]); if (i % prime[j] == 0) break; } } inv[1] = 1; for (int i = 2; i &lt;= 1000000; i++) inv[i] = (LL)(mod - mod / i) * inv[mod % i] % mod; f[1] = add(c % mod, 1); for (int i = 2; i &lt;= 1000000; i++) f[i] = mul(dec(pw[i], 1), inv[i - 1]); for (int i = 1; i &lt;= 1000000; i++) for (int j = i; j &lt;= 1000000; j += i) s[j] = add(s[j], f[i]); for (int i = 1; i &lt;= 1000000; i++) anos[i] = mul(s[i], i);}signed main() { scanf(&quot;%d %lld&quot;, &amp;T, &amp;c); seive(); for (int i = 1; i &lt;= T; i++) scanf(&quot;%d %lld&quot;, &amp;a[i], &amp;b[i]), maxa = max(maxa, a[i]), b[i] = min(b[i], 1ll * a[i]); for (int i = 1; i &lt;= T; i++) G[b[i]].push_back(node{ i, a[i] }); for (int i = 1; i &lt;= maxa; i++) { for (int j = i; j &lt;= maxa; j += i) T1.Add(j, s[j]), T2.Add(j, anos[j]); for (int j = 0; j &lt; G[i].size(); j++) { node now = G[i][j]; ans[now.id] = dec(mul(now.a + 1, T1.query(now.a)), T2.query(now.a)); } } for (int i = 1; i &lt;= T; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;} D-Rainyrabbit 爱染色本场比赛的防 AK 题。其实思维难度不算太大，只是极其难写。 算法 1爆搜即可。可以获得 10 pts。 算法 2考虑 $\\mathcal{O}(nm)$ 的做法。 考虑贪心，每次选择只由该关键点覆盖的节点个数最多的关键点拿来染色，选完后重新更新一下（因为选了一个关键点染色），重复以上步骤 $m$ 次，期间更新一下答案就好了，容易证明得出的答案一定是最优的。 期望得分 40 pts。 算法 3先来考虑优化链的情况。 发现每个关键点控制的范围都是一个连续的区间，用一棵线段树维护即可。 菊花图就更简单了，如果花心 $d_i\\ge 1$ 全部都能控制到，其他的点如果 $d_i=1$ 就只能控制花心，$d_i=2$ 就能控制所有的点。随便更新一下就好了。 结合算法 2 期望得分 60pts。 算法 4发现复杂度瓶颈在于怎么快速找到只由该关键点覆盖的节点个数最多的关键点及其更新。 先来看看 $d_i\\in{0,1}$ 的情况，因为每个关键点能覆盖的节点是散开的，不好处理。于是考虑将树从上到下每一层从左到右编个号，然后你会惊奇的发现对于 $d_i=1$ 的关键点能染到的点可以看成一个连续的区间和该关键点父亲的编号。于是可以想到用线段树维护，用每一个点的编号建树，但是发现不太好维护，因为要知道是哪一个关键点，而不是最多的点数，于是想到在线段树的每一个节点上都开一个 set 维护这个区间编号的节点有哪些关键点能够染到，找到后删除的话就直接 erase 就好了。现在的问题，怎么找？？？？考虑直接从根节点往下搜，直接暴力找肯定会 T，考虑对于线段树上的每一个节点都维护一个区间最小值，表示这个区间至少有多少个关键点覆盖，如果关键点个数大于 $1$ 或者已经被选过的关键点染过就不搜了，否则就拿出 set 里的关键点，往下搜，搜到 $l=r$ 时就将该关键点的 $cnt$ 加一，放进堆里就好了。 关于找最小字典序的序列也很简单，每次选个数最多编号最小的关键点就好了，然后跟上面一样跑。 期望得分 70pts。 算法 5现在来玩 $d_i=2$ 的情况，发现也可以拆分成几个编号连续的区间。该关键点的下面两层，它的父亲的父亲，它的父亲的父亲下面那一层。然后跟上面那样一样做就行。 时间复杂度 $\\mathcal{O}(m\\log^2 n\\sim m\\log^3n )$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, Cnt, ans = 1e9;int im_node[3][200005], cnt[200005], fa[200005], L1[200005], R1[200005], L2[200005], R2[200005], dep[200005], dfn[200005];bool isdead[200005];#define pi pair&lt;int, int&gt;#define lson(x) x &lt;&lt; 1#define rson(x) x &lt;&lt; 1 | 1struct node { int minn, lazy;} tree[400005];set&lt;int&gt;::iterator it;set&lt;int&gt; cover[400005];vector&lt;int&gt; G[200005], g[200005];priority_queue&lt;pi&gt; Q1;priority_queue&lt;int&gt; Q2;void dfs1(int u, int f) { dep[u] = dep[f] + 1, fa[u] = f; g[dep[u]].push_back(u); for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == f) continue; dfs1(v, u); }}void dfs2(int u, int f) { L1[u] = L2[u] = 1e9, R1[u] = R2[u] = 0; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == f) continue; dfs2(v, u); L1[u] = min(L1[u], dfn[v]); L2[u] = min(L2[u], L1[v]); R1[u] = max(R1[u], dfn[v]); R2[u] = max(R2[u], R1[v]); }}void rebuild(int x, int l, int r) { tree[x].lazy = tree[x].minn = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; rebuild(lson(x), l, mid); rebuild(rson(x), mid + 1, r);}void push_down(int x) { if (tree[x].lazy) { tree[lson(x)].lazy += tree[x].lazy; tree[rson(x)].lazy += tree[x].lazy; tree[lson(x)].minn += tree[x].lazy; tree[rson(x)].minn += tree[x].lazy; tree[x].lazy = 0; }}void Updata(int x, int l, int r, int u) { if (tree[x].minn &gt; 1) return; if (cover[x].size()) u = *cover[x].begin(); if (l == r) { if (tree[x].minn == 0) tree[x].minn = 1e9; else if (tree[x].minn == 1) { cnt[u]++; Q1.push(make_pair(cnt[u], u)); tree[x].minn = 1e9; } return; } push_down(x); int mid = (l + r) &gt;&gt; 1; Updata(lson(x), l, mid, u); Updata(rson(x), mid + 1, r, u); tree[x].minn = min(tree[lson(x)].minn, tree[rson(x)].minn);}void sub(int x, int l, int r, int L, int R, int u) { if (L &lt;= l &amp;&amp; r &lt;= R) { tree[x].lazy--, tree[x].minn--; it = cover[x].find(u); cover[x].erase(it); return; } push_down(x); int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) sub(lson(x), l, mid, L, R, u); if (mid + 1 &lt;= R) sub(rson(x), mid + 1, r, L, R, u); tree[x].minn = min(tree[lson(x)].minn, tree[rson(x)].minn) + tree[x].lazy;}void add(int x, int l, int r, int L, int R, int u) { if (L &lt;= l &amp;&amp; r &lt;= R) { tree[x].lazy++, tree[x].minn++; cover[x].insert(u); return; } push_down(x); int mid = (l + r) &gt;&gt; 1; if (L &lt;= mid) add(lson(x), l, mid, L, R, u); if (mid + 1 &lt;= R) add(rson(x), mid + 1, r, L, R, u); tree[x].minn = min(tree[lson(x)].minn, tree[rson(x)].minn);}void updata(int opt, int u, int l, int r) { if (l &gt; r) return; if (opt == 1) add(1, 1, n, l, r, u); else sub(1, 1, n, l, r, u);}void add_or_sub_im_node(int x, int opt) { int u = im_node[0][x], d = im_node[1][x]; if (d == 0) updata(opt, x, dfn[u], dfn[u]); else if (d == 1) { updata(opt, x, L1[u], R1[u]); updata(opt, x, dfn[u], dfn[u]); if (fa[u]) updata(opt, x, dfn[fa[u]], dfn[fa[u]]); } else { updata(opt, x, L1[u], R1[u]); updata(opt, x, L2[u], R2[u]); if (fa[u]) { int v = fa[u]; updata(opt, x, L1[v], R1[v]); updata(opt, x, dfn[v], dfn[v]); if (fa[v]) updata(opt, x, dfn[fa[v]], dfn[fa[v]]); } else updata(opt, x, dfn[u], dfn[u]); }}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) { int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } dfs1(1, 0); for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt; g[i].size(); j++) dfn[g[i][j]] = ++Cnt; dfs2(1, 0); for (int i = 1; i &lt;= m; i++) { scanf(&quot;%d %d&quot;, &amp;im_node[0][i], &amp;im_node[1][i]); add_or_sub_im_node(i, 1); } for (int i = 1; i &lt;= m; i++) Q1.push(make_pair(0, i)); Updata(1, 1, n, -1); for (int i = 1; i &lt;= m; i++) { while (isdead[Q1.top().second] || Q1.top().first != cnt[Q1.top().second]) Q1.pop(); pi now = Q1.top(); Q1.pop(); ans = min(ans, now.first); isdead[now.second] = 1; add_or_sub_im_node(now.second, -1); Updata(1, 1, n, -1); } printf(&quot;%d\\n&quot;, ans); rebuild(1, 1, n); while (!Q1.empty()) Q1.pop(); for (int i = 1; i &lt;= m; i++) isdead[i] = 0, cnt[i] = 0, add_or_sub_im_node(i, 1), Q1.push(make_pair(0, i)); Updata(1, 1, n, -1); int choose = 0; for (int i = 1; i &lt;= m; i++) { while (choose &lt; m) { while (isdead[Q1.top().second] || Q1.top().first != cnt[Q1.top().second]) Q1.pop(); if (Q1.top().first &lt; ans) break; Q2.push(-Q1.top().second); isdead[Q1.top().second] = 1; Q1.pop(); choose++; } add_or_sub_im_node(-Q2.top(), -1); Q2.pop(); Updata(1, 1, n, -1); } for (int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, cnt[i]); return 0;}","link":"/2021/02/04/2021-02-04-%E5%8F%8B%E8%B0%8A%E8%B5%9B%E9%A2%98%E8%A7%A3/"},{"title":"「Summary」寒假第一期集训小结","text":"寒假第一期小结 总结感觉最大的进步是学会了卡常。 这一期主要学了和单调队列有关的dp优化和各种高级搜索，合起来无非是优雅的暴力。。。 dp优化单调队列优化学得还好，斜率优化硬是花了一天半的时间才想明白，但是如果模式化地去理解，还是比较好懂。 单调队列优化单调队列优化针对于普通版本的，没有 $i \\times j$ 这样的结构的状态转移方程。如果将其看作函数，真正影响其值的大小的量其实是于 $i$ 无关的变量(可以把含有$i$的值看作常量)，那么就可以用单调队列去维护区间的最值。 常规操作1234while (head &lt;= tail &amp;&amp; q[head] 的值不在可更新的范围内) head++; // 踢队头dp[...] = dp[q[head]] ...;while (head &lt;= tail &amp;&amp; i 的贡献比 q[head] 的贡献更大) tail--; // 踢队尾q[++tail] = i; 斜率优化当状态转移方程中出现了 $i$ 与其它变量的乘积的时候，单调队列无法单纯的去维护时，就需要斜率优化。个人认为代数法是最好理解的。。。举个例子？以Cats Transport一题为例:怎么又是这道$dp_{i,j} = min_{0 &lt; k} ^{j-1}(dp_{i-1,k} + (j - k) * a_j - sum_j + sum_k)$$dp_{i,j} = dp_{i-1,k} + (j - k) * a_j - sum_j + sum_k$假设有$k_1$、$k_2$两个状态点, $k_2$在$k_1$后，且$k_2$比$k_1$更优。则可以知道:$dp_{i-1,{k_1}} + (j - k_1) * a_j - sum_j + sum_{k_1} \\geq dp_{i-1,{k_2}} + (j - k_2) * a_j - sum_j + sum_{k_2}$化简:$dp_{i-1,{k_1}} + (j - k_1) * a_j + sum_{k_1} \\geq dp_{i-1,{k_2}} + (j - k_2) * a_j + sum_{k_2}$将带有$i$的和没有的整理得：$ (dp_{i-1,{k_2}} + sum_{k_2}) - (dp_{i-1,{k_1}} + sum_{k_1}) \\leq a_j \\times (k_2 - k_1)$因为$k_2$在$k_1$后，所以$(k_2 - k_1) \\geq 1$。将$(k_2 - k_1)$移到左边:$ \\frac{(dp_{i-1,{k_2}} + sum_{k_2}) - (dp_{i-1,{k_1}} + sum_{k_1})}{(k_2 - k_1)} \\leq a_j$所以得到了啥？。。。当初一直不懂为啥要推式子，想了很久终于明白了它的意义。。。回忆单调队列的操作，首先维护队头的最优解，然后去掉队尾的亢余那么按照操作来可以知道：$q[head + 1]$和$q[head]$在满足上面的公式的时候，$q[head + 1]$比$q[head]$更优。所以可以踢掉队头。那么可以通过状态转移方程知道解的单调性。回忆$ZSJ$在数学课上讲的线性规划 (当时就看到他用一根线在坐标系上移来移去，不知道在干啥。。。) 要是最后的答案最小，那么就要让基准线的截距最小(不考虑交点在2、3、4象限)而基准线要经过其中的一个决策点：那么如下图： 可以看出无论是选择$q[tail - 1]$或者$i$，得到的答案都会比选择$q[tail]$优，那么此时，利用点连线间的斜率关系，就可以把$q[tail]$弹出去。可以有： 123456789101112131415161718192021#int X(int i) { return ...; }int Y(int i) { return ...; }long double K(int i, int j) { return (Y(j) - Y(i)) / (X(j) - X(i));}int main() { /*单调队列*/ head = 1, tail = 1; q[tail] = 0; for (int i = 1; i &lt;= n; i++) { while (head &lt; tail &amp;&amp; head 与 head + 1 的关系满足你推出的式子) head++; dp[i] = ...; while (head &lt; tail &amp;&amp; tail不可能成为决策点(用K(i, q[tail - 1]) 和 K(q[tail - 1], q[tail])的大小关系)) tail--; q[++tail] = i; //不要忘记。。。 } /*单调栈*/ return 0;} 高级搜索首先说明：其实所学内容并非高级搜索，而且我也不是十分赞同这个名字，但是为了与gm所讲的内容大致合拍，我使用了这个标题。 我认为这些搜索算法应该分为基于合理预判的贪心性搜索算法、对于可不完全合并性题目的折半搜索，和已知明确终态的双向搜索名字取得有点儿奇怪，但他们的本质的确如此。因而，总结的逻辑也出来了。 基于合理预判的贪心性搜索算法忽略掉iddfs，它只不过是应付那些不用idAstar就能水过去的题目而已了。说白了，就是个低配版本的idAstar所以，总结Astar和idAstar即可。关系其实和bfs和dfs差不多分开写也没必要。。。所谓基于合理预判，其实就是指的算法中的h()函数。h()函数满足一个要求 $h(x) \\leq f(x)$ 即估计值要小于实际的权值。简单说一下：假如没有遵循这个原则，可以预见到某些最优状态将会一直被压在队底而弹不出来，导致扩展出来的路径并非最优解。所以，写一个比较好的估价函数是整个算法的关键。而且估价函数的值越接近实际值，算法的效率越高。估价函数的值可以定义为与目标状态不同点的个数 或是 不同点之间的距离。给出两种算法的伪代码:Astar 123456789101112131415161718192021222324252627struct state { int g, h; int H() { ... return 估价函数; } bool operator &lt; (node other) const { return (g + h) &gt; (other.g + other.h); }}priority_queue&lt;state&gt; q;int Astar() { q.push(s); while (q.size()) { state u = q.top(); q.pop(); if (达到目标状态) { return ...; } for (每一个分支) { state v = ...; q.push(v); } } return -1;} idAstar 123456789101112131415161718192021int H() { ... return 估价函数;}bool Check() { if (...) return 1; else return 0;}bool idAstar(int step, int limit) { if (H() + step &gt; limit) return 0; if (Check()) return 1; for (每一个分支) { ... if (idAstar(step + 1, limit)) return 1; ... } return 1;} 对于可不完全合并性题目的折半搜索 在一般情况下，你会算出暴力的时间复杂度在 $2^40$ 左右。。。 折半搜索可分为方程模型和选择模型，方程模型一般可以将式子拆成等价的两边，在集合一半的范围类进行搜索，在此基础对两个结果集合合并(不完全合并)，从而减少时间复杂度。选择模型思路也大致类似. 伪代码如下: 12345678910111213141516void dfs(int* ans, int&amp; size, int now, int sum, int limit) { if (now &gt; limit) { ans[++size] = sum; return; } if (sum + p[now] &lt;= m) dfs(ans, size, now + 1, ..., limit); dfs(ans, size, now + 1, sum, limit);}dfs(lans, cnt1, 1, 0, n / 2);dfs(rans, cnt2, n / 2 + 1, 0, n);sort(rans + 1, rans + 1 + cnt2);for (int i = 1; i &lt;= cnt1; i++) { int sum = upper_bound(rans + 1, rans + 1 + cnt2, m - lans[i]) - rans - 1; ans += sum;} 已知明确终态的双向搜索使用前提是有明确的终态。那么可以从起点和终点同时开始搜索，在理论上可以将搜索树减少。实现与bfs相似: 12345678910111213141516171819202122232425262728293031323334int bfs() { s.opt = 1, t.opt = 0; q.push(s); q.push(t); int ss = p.hash(s.m), tt = p.hash(t.m); ans[s.opt][ss] = 0; ans[t.opt][tt] = 0; vis[s.opt][ss] = 1; vis[t.opt][tt] = 1; while (q.size()) { node u = q.front(); q.pop(); int now = p.hash(u.m); if (vis[!u.opt][now] == 1) { return ans[!u.opt][now] + ans[u.opt][now]; } for (int i = 1; i &lt;= 4; i++) { int nx = u.x + dx[i]; int ny = u.y + dy[i]; if (nx &lt; 1 || nx &gt; 3 || ny &lt; 1 || ny &gt; 3) continue; node v; v.coopy(u); v.x = nx, v.y = ny; swap(v.m[nx][ny], v.m[u.x][u.y]); int tmp = p.hash(v.m); if (vis[v.opt][tmp] == 0) { vis[v.opt][tmp] = 1; q.push(v); ans[v.opt][tmp] = v.step; } } } return -1;} END终究是写完了。。。如有不妥当之处，还请各位路过高手不惜赐教。","link":"/2021/02/08/2021-02-8-%E5%AF%92%E5%81%87%E7%AC%AC%E4%B8%80%E6%9C%9F%E9%9B%86%E8%AE%AD%E5%B0%8F%E7%BB%93/"},{"title":"「Note」斜率优化dp","text":"斜率优化简单总结 优化原理斜率优化基于单调队列/单调栈。可以再 $O(1)$ 的时间复杂度内找到最优的状态。 如何优化以Cats Transport一题为例。首先设：$d[i] = d[i - 1] + x$(即当前山与第一号山的距离)$a[i] = t - d[h]$(能接到$i$号猫的最早出发时间)$sum[i] = sum[i - 1] + a[i]$($a[]$的前缀和)可以得到方程:$$dp_{i,j} = min_{0 &lt; k} ^{j-1}(dp_{i-1,k} + (j - k) * a_j - sum_j + sum_k)$$时间复杂度为$pm^2$。亲测30pts那么导致时间复杂度增高的原因是在寻找最优的$k$时多跑了一重循环。尝试去掉这重循环。。。将原式子展开可以有:$$dp_{i,j} = dp_{i-1,k} + (j - k) * a_j - sum_j + sum_k$$假设有$k_1$、$k_2$两个状态点, $k_2$在$k_1$后，且$k_2$比$k_1$更优。则可以知道:$$dp_{i-1,{k_1}} + (j - k_1) * a_j - sum_j + sum_{k_1} \\geq dp_{i-1,{k_2}} + (j - k_2) * a_j - sum_j + sum_{k_2}$$化简:$$dp_{i-1,{k_1}} + (j - k_1) * a_j + sum_{k_1} \\geq dp_{i-1,{k_2}} + (j - k_2) * a_j + sum_{k_2}$$将带有$i$的和没有的整理得：$$ (dp_{i-1,{k_2}} + sum_{k_2}) - (dp_{i-1,{k_1}} + sum_{k_1}) \\leq a_j \\times (k_2 - k_1)$$因为$k_2$在$k_1$后，所以$(k_2 - k_1) \\geq 1$。将$(k_2 - k_1)$移到左边:$$ \\frac{(dp_{i-1,{k_2}} + sum_{k_2}) - (dp_{i-1,{k_1}} + sum_{k_1})}{(k_2 - k_1)} \\leq a_j$$将$(dp_{i-1,k2},k_2)$看做一个点，可知此题应维护一个下凸壳。于是套上板子即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;const int MAXP = 105;int n, m, p;int d[MAXN], sum[MAXN], a[MAXN], dp[MAXP][MAXN];int head, tail, q[MAXN];int Y(int id, int i) { return dp[id - 1][i];}int X(int i) { return i;}long double K(int id, int i, int j) { return double(Y(id, j) - Y(id, i)) / (X(j) - X(i));}int main() { scanf (&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;p); for (int i = 2, x; i &lt;= n; i++) { scanf (&quot;%d&quot;, &amp;x); d[i] = d[i - 1] + x; } for (int i = 1, h, t; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;h, &amp;t); a[i] = t - d[h]; } sort (a + 1, a + 1 + m); for (int i = 1; i &lt;= m; i++) sum[i] = sum[i - 1] + a[i]; for (int i = 1; i &lt;= p; i++) { head = 1, tail = 1, q[1] = 0; for (int j = 1; j &lt;= m; j++) { while (K(i, q[head], q[head + 1]) &lt;= a[j] &amp;&amp; head &lt; tail) head++; int k = q[head]; dp[i][j] = dp[i - 1][k] + (j - k) * a[j] - sum[j] + sum[k]; while (K(i, q[tail - 1], q[tail]) &gt;= K(i, q[tail - 1], j)) tail--; q[++tail] = j; } } printf (&quot;%d\\n&quot;, dp[p][m]); return 0;}","link":"/2021/02/03/2021-02-03-%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%E5%B0%8F%E7%BB%93/"},{"title":"「Solution」秦始皇的国道","text":"最小生成树 思路要使$A/B$最大化。就要想办法让$A$尽量大，同时让$B$变小。 先考虑让$B$变小。那么可以想到在保证连通性的情况下最小生成树的权长肯定最小。 所以先跑一遍Kruskal或Prime求出最小生成树。 然后枚举最小生成树上的边，考虑删掉，即在余下的边上换上一条魔道。 如果最小生成树如上图。 那么删掉一条边之后，它会分裂成两棵子树。 为了使它联通并让魔道两边的城市的人口最多。则要在两棵子树中分别找到人口最多的那个节点，再将找到的两个节点连起来作为魔道，去更新答案即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1005;const int MAXM = MAXN * MAXN + 5;int t, n, m, fa[MAXN], u[MAXN], v[MAXN], cnt;double len, ans;vector&lt;int&gt; G[MAXN];bool vis[MAXN];struct node { double x, y; int p;} c[MAXN];struct edge { int u, v; double w; edge(){} edge(int U, int V, double W) { u = U, v = V, w = W; }} dis[MAXM];bool cmp(edge x, edge y) { return x.w &lt; y.w;}double dist(int x, int y) { return sqrt((c[x].x - c[y].x) * (c[x].x - c[y].x) + (c[x].y - c[y].y) * (c[x].y - c[y].y));}int FindSet(int v) { if (fa[v] == v) return fa[v]; else return fa[v] = FindSet(fa[v]);}bool UnionSet(int u, int v) { int x = FindSet(u), y = FindSet(v); if (x == y) return 0; fa[x] = y; return 1;}void Kruskal() { for (int i = 1; i &lt;= n; i++) fa[i] = i; sort (dis + 1, dis + 1 + m, cmp); cnt = 0, len = 0; for (int i = 1; i &lt;= m; i++) { if (UnionSet(dis[i].u, dis[i].v)) { len += dis[i].w, u[++cnt] = dis[i].u, v[cnt] = dis[i].v; G[dis[i].u].push_back(dis[i].v), G[dis[i].v].push_back(dis[i].u); } }}void dfs(int u, int&amp; val) { vis[u] = 1; val = max(c[u].p, val); for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v] == 1) continue; dfs(v, val); }}int main() { scanf (&quot;%d&quot;, &amp;t); while (t--) { scanf (&quot;%d&quot;, &amp;n); m = 0, ans = 0; for (int i = 1; i &lt;= n; i++) { scanf (&quot;%lf %lf %d&quot;, &amp;c[i].x, &amp;c[i].y, &amp;c[i].p); G[i].clear(); } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { dis[++m] = edge(i, j, dist(i, j)); } } Kruskal(); for (int i = 1; i &lt;= cnt; i++) { memset(vis, 0, sizeof(vis)); vis[v[i]] = 1; int a = 0, tmp = 0; dfs(u[i], tmp); a += tmp; memset(vis, 0, sizeof(vis)); vis[u[i]] = 1; tmp = 0; dfs(v[i], tmp); a += tmp; double now = a * 1.0 / (len - dist(u[i], v[i])); ans = max(ans, now); } printf (&quot;%.2lf\\n&quot;, ans); } return 0;}","link":"/2021/03/12/2021-03-12-%E7%A7%A6%E5%A7%8B%E7%9A%87%E7%9A%84%E5%9B%BD%E9%81%93/"},{"title":"「Note」Tarjan","text":"一些有用的模板 割点割边12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5005;int n, m, tot, bans, pans, dfn[MAXN], low[MAXN], root;vector&lt;int&gt; G[MAXN];bool b[MAXN][MAXN], p[MAXN];void tarjan (int u, int fa) { dfn[u] = low[u] = ++tot; int cnt = 0; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!dfn[v]) { tarjan (v, u); low[u] = min (low[u], low[v]); if (low[v] &gt; dfn[u]) { if (b[u][v] || b[v][u]) continue; b[u][v] = b[v][u] = 1; bans++; } if (low[v] &gt;= dfn[u]) { cnt++; if ((cnt &lt;= 1 &amp;&amp; u == root) || p[u]) continue; p[u] = 1; pans++; } } else if (v != fa) { low[u] = min (low[u], dfn[v]); } }}int main () { scanf (&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, u, v; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) { root = i; tarjan (i, 0); } printf (&quot;%d\\n%d\\n&quot;, pans, bans); return 0;} 双连通分量点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100005;int n, m, dfn[MAXN], low[MAXN], tot, cnt;vector&lt;int&gt; G[MAXN];stack&lt;pair&lt;int, int&gt; &gt; s;vector&lt;pair&lt;int, int&gt; &gt; dcc[MAXN];void tarjan (int u, int fa) { dfn[u] = low[u] = ++tot; int flag = 0; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!dfn[v]) { s.push(make_pair (u, v)); tarjan (v, u); low[u] = min (low[u], low[v]); if (low[v] &gt;= dfn[u]) { cnt++; pair&lt;int, int&gt; y; do { y = s.top(); s.pop(); dcc[cnt].push_back(make_pair (min (y.first, y.second), max (y.first, y.second))); } while (y.first != u || y.second != v); } } else if (v != fa) { low[u] = min (low[u], dfn[v]); if (dfn[u] &gt;= dfn[v]) { s.push(make_pair (u, v)); } } }}bool check (int x, int y) { for (int i = 0; i &lt; dcc[x].size(); i++) { if (dcc[x][i] &lt; dcc[y][i]) return 1; if (dcc[x][i] &gt; dcc[y][i]) return 0; } return 1;}int main () { scanf (&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, u, v; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) { tarjan (i, 0); } int id = 0; for (int i = 1; i &lt;= cnt; i++) { sort (dcc[i].begin(), dcc[i].end()); if (dcc[i].size() &gt; dcc[id].size()) { id = i; } else if (dcc[i].size() == dcc[id].size() &amp;&amp; check (i, id)) { id = i; } } printf (&quot;%d\\n%d\\n&quot;, cnt, dcc[id].size()); for (int i = 0; i &lt; dcc[id].size(); i++) { printf (&quot;%d %d\\n&quot;, dcc[id][i].first, dcc[id][i].second); } return 0;} 边dfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5005;int n, m, tot, dfn[MAXN], low[MAXN], root, ans, dcc, deg[MAXN];vector&lt;int&gt; G[MAXN];bool b[MAXN][MAXN], p[MAXN][MAXN];int vis[MAXN];void tarjan (int u, int fa) { dfn[u] = low[u] = ++tot; int cnt = 0; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!dfn[v]) { tarjan (v, u); low[u] = min (low[u], low[v]); if (low[v] &gt; dfn[u]) { if (b[u][v] || b[v][u]) continue; b[u][v] = b[v][u] = 1; } } else if (v != fa) { low[u] = min (low[u], dfn[v]); } }}void dfs (int u) { vis[u] = dcc; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v] || b[u][v]) continue; dfs (v); }}int main () { scanf (&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, u, v; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); if (p[u][v] || p[v][u]) continue; p[u][v] = p[v][u] = 1; G[u].push_back(v), G[v].push_back(u); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) { tarjan (i, 0); } for (int i = 1; i &lt;= n; i++) if (!vis[i]) { dcc++; dfs (i); } for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; G[i].size(); j++) { int v = G[i][j]; if (vis[i] != vis[v]) { deg[vis[v]]++; } } } for (int i = 1; i &lt;= dcc; i++) { if (deg[i] == 1) ans++; } printf (&quot;%d\\n&quot;, (ans + 1) / 2); return 0;} tarjan123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5005;int n, m, tot, dfn[MAXN], low[MAXN], root, ans, dcc, deg[MAXN];vector&lt;int&gt; G[MAXN];bool b[MAXN][MAXN], p[MAXN][MAXN];int vis[MAXN], s[MAXN], top;void tarjan (int u, int fa) { dfn[u] = low[u] = ++tot; s[++top] = u; int cnt = 0; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!dfn[v]) { tarjan (v, u); low[u] = min (low[u], low[v]); } else if (v != fa) { low[u] = min (low[u], dfn[v]); } } if (low[u] == dfn[u]) { int v; dcc++; do { v = s[top--]; vis[v] = dcc; } while (v != u); }}int main () { scanf (&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, u, v; i &lt;= m; i++) { scanf (&quot;%d %d&quot;, &amp;u, &amp;v); if (p[u][v] || p[v][u]) continue; p[u][v] = p[v][u] = 1; G[u].push_back(v), G[v].push_back(u); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) { tarjan (i, 0); } for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; G[i].size(); j++) { int v = G[i][j]; if (vis[i] != vis[v]) { deg[vis[v]]++; } } } for (int i = 1; i &lt;= dcc; i++) { if (deg[i] == 1) ans++; } printf (&quot;%d\\n&quot;, (ans + 1) / 2); return 0;}","link":"/2021/04/10/2021-04-10-Tarjan/"},{"title":"「Solution」平面最近点对","text":"分治 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5; const double INF = 0x3f3f3f3f;const double eps = 1e-7;int t, n;double ans;struct node { int x, y, z;} p[MAXN * 2];bool cmp (node a, node b) { return a.x &lt; b.x;}double dis (int a, int b) { if (p[a].z == p[b].z) return INF; return sqrt (double(p[a].x - p[b].x) * (p[a].x - p[b].x) + double(p[a].y - p[b].y) * (p[a].y - p[b].y)); //double 不能丢}double Dist (int l, int r) { if (l == r) return INF; if (r - l == 1) return dis (l, r); int mid = (l + r) &gt;&gt; 1; double tmp = min (Dist (l, mid), Dist (mid, r)); for (int i = mid - 1; i &gt;= l; i--) { if (p[mid].x - p[i].x + eps &gt; tmp) break; for (int j = mid + 1; j &lt;= r; j++) { if (p[j].x - p[i].x + eps &gt; tmp) break; tmp = min (tmp, dis (i, j)); } } return tmp;}int main () { scanf (&quot;%d&quot;, &amp;t); while (t--) { scanf (&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d %d&quot;, &amp;p[i].x, &amp;p[i].y); p[i].z = 0; } for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d %d&quot;, &amp;p[i + n].x, &amp;p[i + n].y); p[i + n].z = 1; } sort (p + 1, p + 1 + 2 * n, cmp); printf (&quot;%.3lf\\n&quot;, Dist (1, 2 * n)); } return 0;}","link":"/2021/05/14/2021-05-13-%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/"},{"title":"「Solution」ABC209","text":"赛后总结 其实题目都不算难，但是比赛的时候都只想了一半的正解。考虑也不周全，T3还把数组开小 Re 了一发。要多见见题目，思维要开阔一点。 A Counting题意给出A, B, 求 $[A, B]$ 中整数元素个数。 题解1cout &lt;&lt; ((b - a + 1 &lt; 0) ? 0 : (b - a + 1)); B Can you buy them all?题意给出一堆数，下标为偶数的数的数值均减一，询问总和与x的大小关系。 题解按题意模拟即可。 12345678910111213141516171819#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int x, n, sum;int main () { cin &gt;&gt; n &gt;&gt; x; for (int i = 1, y; i &lt;= n; i++) { cin &gt;&gt; y; sum += y; if (i % 2 == 0) sum--; } if (sum &lt;= x) { printf (&quot;Yes\\n&quot;); } else printf (&quot;No\\n&quot;); return 0;} C Not Equal题意给出C数列，构造A数列，满足A中元素互不相同，且a[i] &lt;= c[i]。 求A数列的个数。 题解针对于每个a[i]，若不考虑相同元素，有a[i]种选择，考虑相同元素，即只有a[i] - k种选择，k是比c[i]小的元素个数。 123456789101112131415161718192021222324#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int Mod = 1e9 + 7;const int MAXN = 2e5 + 5;int n, c[MAXN];long long ans;int main () { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; c[i]; } ans = 1; sort (c + 1, c + 1 + n); for (int i = 1; i &lt;= n; i++) { ans = (ans % Mod * (c[i] - i + 1) % Mod) % Mod; } cout &lt;&lt; (ans % Mod) &lt;&lt; endl; return 0;} D Collision题意两个人在树上走，询问距离是奇数是偶数。 题解lca板题。","link":"/2021/06/19/2021-06-19-Atcoder%5Babc209%5DSummary/"},{"title":"「Solution」Atcoder ABC Unfair Nim","text":"题解？ 题意两个人玩 石头 。规则自已看。。。然后可以知道简化后就是给你两个数的和，与异或和，问拆分方案。即是:已知$a + b$ 和 $a \\bigoplus b$.求与 小于等于$x_1$的最大的 $a$. 分析因为已知 $a + b$ 和 $a \\bigoplus b$.所以可知 $a &amp; b$ $a &amp; b = \\frac{a+b-a \\bigoplus b}{2}$ 然后就完了。 记 $x = a &amp; b, y = a \\bigoplus b, tmp = x$ $tmp$ 是$a$最小值。 那么把$x,y$都转二进制。 考虑每一位。 分类讨论一下： 下面的$x,y$都表示$x,y$的二进制下同一位 $1: x = 1, y = 1$ 这种情况是不合法的，直接判$-1$. $2:x = 1, y = 0$ 两个数都为1. $tmp += (1 &lt;&lt; pos)$ $3:x = 0,y = 0$ 不干啥。 $4:x = 0,y = 1$ 因为要使$a$最大，所以如果$tmp + (1 &lt;&lt; pos) \\leq x_1$ 就完了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 45; int n, x, y, all, m, pos, tmp, nx, ny, delta;int a[MAXN], b[MAXN];bool satis[MAXN], vis[MAXN];signed main () { scanf (&quot;%lld&quot;, &amp;n); scanf (&quot;%lld %lld&quot;, &amp;x, &amp;y); m = x + y; for (int i = 3, k; i &lt;= n; i++) { scanf (&quot;%lld&quot;, &amp;k); all ^= k; } delta = (m - all); if (delta &lt; 0 || delta % 2 == 1) { printf (&quot;-1\\n&quot;); return 0; } tmp = delta &gt;&gt; 1; delta &gt;&gt;= 1; for (int i = 40; i &gt;= 0; i--) { int b = (delta &gt;&gt; i) &amp; 1; int a = (all &gt;&gt; i) &amp; 1; if (b == 1 &amp;&amp; a == 1) { printf (&quot;-1\\n&quot;); return 0; } if (a == 1 &amp;&amp; (tmp | (1ll &lt;&lt; i)) &lt;= x) { tmp |= (1ll &lt;&lt; i); } } if (x &lt; tmp || tmp == 0) { printf (&quot;-1\\n&quot;); } else { printf (&quot;%lld\\n&quot;, x - tmp); } return 0;}","link":"/2021/07/13/2021-07-13-Unfair%20Nim/"},{"title":"「Solution」宠物收留所 &amp; GSS6","text":"At the Beginning写平衡树有点想吐，过来码两篇题解 最近写题写得有点儿乱，整理一下。。。 宠物收留所link 分析乍一看，好像要两个平衡树。 但仔细读题可以发现： 在任意时刻，平衡树里只会全部保留其中一类（人 或 宠物） 那么用一颗平衡树维护即可 并且对于人和动物，操作都一样。 具体如下： 若当前是人，如果没有宠物，直接加入平衡树，否则就直接查询前驱|后继统计即可，宠物同理 代码代码略丑。。。fhq_treap跑得很慢。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1e5 + 5;const int Mod = 1000000;int n, tot, root, tmp1, tmp2, tmp3, ans;struct Treap { int l, r, val, key, siz;} s[MAXN];int newnode (int val) { s[++tot].val = val, s[tot].key = rand (), s[tot].siz = 1; return tot;}void push_up (int p) { s[p].siz = s[s[p].l].siz + s[s[p].r].siz + 1;}void split (int p, int val, int&amp; x, int&amp; y) { if (p == 0) { x = y = 0; return; } if (s[p].val &lt;= val) { x = p, split (s[p].r, val, s[p].r, y); } else { y = p, split (s[p].l, val, x, s[p].l); } push_up (p);}int merge (int x, int y) { if (!x || !y) return x + y; if (s[x].key &lt; s[y].key) { s[x].r = merge (s[x].r, y); push_up(x); return x; } else { s[y].l = merge (x, s[y].l); push_up(y); return y; }}void insert (int val) { split (root, val, tmp1, tmp2); root = merge (merge (tmp1, newnode (val)), tmp2);}void remove (int val) { split (root, val, tmp1, tmp3); split (tmp1, val - 1, tmp1, tmp2); tmp2 = merge (s[tmp2].l, s[tmp2].r); root = merge (merge(tmp1, tmp2), tmp3);}int queryrnk (int val) { split (root, val - 1, tmp1, tmp2); int res = s[tmp1].siz + 1; root = merge (tmp1, tmp2); return res;}int querykth (int p, int k) { while (1) { if (s[s[p].l].siz &gt;= k) { p = s[p].l; continue; } if (s[s[p].l].siz + 1 == k) { return p; } k -= s[s[p].l].siz + 1, p = s[p].r; }}int querypre (int val) { split (root, val - 1, tmp1, tmp2); if (tmp1 == 0) return INF; int res = s[querykth (tmp1, s[tmp1].siz)].val; root = merge (tmp1, tmp2); return res;}int querynxt (int val) { split (root, val, tmp1, tmp2); if (tmp2 == 0) return INF; int res = s[querykth (tmp2, 1)].val; root = merge (tmp1, tmp2); return res;}int Abs (int x) { return (x &lt; 0) ? -x : x;}int main () { scanf (&quot;%d&quot;, &amp;n); int cnt1, cnt2; cnt1 = cnt2 = 0; while (n--) { int opt, k; scanf (&quot;%d %d&quot;, &amp;opt, &amp;k); if (opt == 0) { if (cnt2 == 0) { insert (k); cnt1++; } else { int pre = querypre (k); int nxt = querynxt (k); int val = (Abs (pre - k) &lt;= Abs (nxt - k)) ? pre : nxt; remove (val); ans = (ans + Abs (val - k)) % Mod; cnt2--; } } else { if (cnt1 == 0) { insert (k); cnt2++; } else { int pre = querypre (k); int nxt = querynxt (k); int val = (Abs (pre - k) &lt;= Abs (nxt - k)) ? pre : nxt; remove (val); ans = (ans + Abs (val - k)) % Mod; cnt1--; } } // printf (&quot;ans = %d\\n&quot;, ans); } printf (&quot;%d\\n&quot;, ans); return 0;} ​ GSS 6 - Can you answer these queries VIlink 分析其实就是个最大字段和问题，和GSS1类似。 关于线段树维护最大字段和的方式再写一遍吧。 看图应该可以理解，即是对于当前区间，它的最大字段和可以由三种方式去更新： 当前节点的左儿子的最大字段和 当前节点的右儿子的最大字段和 当前节点的左儿子的右端连续最大和加右儿子的左端连续最大和 那么再去多维护两个值即可(lmax, rmax) 对于维护lmax，有两种方式去更新： 当前节点的左儿子的lmax 当前节点的左儿子的区间和加当前节点的右儿子的lmax 对于rmax也同理 push_up的代码不难写出 123456void push_up (int p) { s[p].sum = s[p * 2].sum + s[p * 2 + 1].sum; s[p].lmax = max(s[p * 2].lmax, s[p * 2].sum + s[p * 2 + 1].lmax); s[p].rmax = max(s[p * 2 + 1].rmax, s[p * 2 + 1].sum + s[p * 2].rmax); s[p].dat = max(s[p * 2].dat, max(s[p * 2 + 1].dat, s[p * 2].rmax + s[p * 2 + 1].lmax));} 然后GSS1就可以顺利AC,GSS6也同理，只是将线段树的操作搬到了平衡树上。 push_up的代码变成 1234567void push_up (int p) { s[p].siz = s[s[p].l].siz + s[s[p].r].siz + 1; s[p].sum = s[s[p].l].sum + s[s[p].r].sum + s[p].val; s[p].pre = max (s[s[p].l].pre, s[s[p].l].sum + s[p].val + s[s[p].r].pre); s[p].nxt = max (s[s[p].r].nxt, s[s[p].r].sum + s[p].val + s[s[p].l].nxt); s[p].maxl = max (max (s[s[p].l].maxl, s[s[p].r].maxl), s[s[p].l].nxt + s[p].val + s[s[p].r].pre);} 然后需要注意的是平衡树要写成区间树，即要用下标作为分裂的标准，在线段树的基础上要加上自身的权值，且要在初始的时候塞一个空节点，权值为-INF。 split的代码较按权值分裂略有不同。 1234567891011void split (int p, int k, int&amp; x, int&amp; y) { if (p == 0) { x = y = 0; return; } if (s[s[p].l].siz &lt; val) { x = p, split (s[p].r, val - s[s[p].l].siz - 1, s[p].r, y); } else { y = p, split (s[p].l, val, x, s[p].l); } push_up (p);} 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2e5 + 5;const int INF = 0x3f3f3f3f;int n, m, root, tot, tmp1, tmp2, tmp3;struct Treap { int l, r, val, key, siz; int pre, nxt; // 区间前(后)缀 int maxl, sum; // 区间最大字段和 | 区间和 } s[MAXN]; int newnode (int val) { tot++; s[tot].sum = s[tot].maxl = s[tot].val = val, s[tot].key = rand (), s[tot].siz = 1; s[tot].pre = s[tot].nxt = max (val, 0); return tot;}void push_up (int p) { s[p].siz = s[s[p].l].siz + s[s[p].r].siz + 1; s[p].sum = s[s[p].l].sum + s[s[p].r].sum + s[p].val; s[p].pre = max (s[s[p].l].pre, s[s[p].l].sum + s[p].val + s[s[p].r].pre); s[p].nxt = max (s[s[p].r].nxt, s[s[p].r].sum + s[p].val + s[s[p].l].nxt); s[p].maxl = max (max (s[s[p].l].maxl, s[s[p].r].maxl), s[s[p].l].nxt + s[p].val + s[s[p].r].pre);}void split (int p, int val, int&amp; x, int&amp; y) { if (p == 0) { x = y = 0; return; } if (s[s[p].l].siz &lt; val) { x = p, split (s[p].r, val - s[s[p].l].siz - 1, s[p].r, y); } else { y = p, split (s[p].l, val, x, s[p].l); } push_up (p);}int merge (int x, int y) { if (!x || !y) return x + y; if (s[x].key &lt; s[y].key) { s[x].r = merge (s[x].r, y); push_up (x); return x; } else { s[y].l = merge (x, s[y].l); push_up (y); return y; }}void insert (int p, int val) { split (root, p, tmp1, tmp2); root = merge (merge (tmp1, newnode (val)), tmp2);}void remove (int p) { split (root, p, tmp1, tmp3); split (tmp1, p - 1, tmp1, tmp2); tmp2 = merge (s[tmp2].l, s[tmp2].r); root = merge (tmp1, merge (tmp2, tmp3));}void change (int p, int val) { split (root, p, tmp1, tmp3); split (tmp1, p - 1, tmp1, tmp2); s[tmp2].sum = s[tmp2].maxl = s[tmp2].val = val; s[tmp2].pre = s[tmp2].nxt = max (val, 0); root = merge (merge (tmp1, tmp2), tmp3);}int query (int l, int r) { split (root, r, tmp1, tmp3); split (tmp1, l - 1, tmp2, tmp1); int res = s[tmp1].maxl; root = merge (merge (tmp2, tmp1), tmp3); return res;}void print (int p) { if (!p) return; print (s[p].l); printf (&quot;p = %d, val = %d, l = %d, r = %d, siz = %d\\n&quot;, p, s[p].val, s[p].l, s[p].r, s[p].siz); print (s[p].r);}void debug () { printf (&quot;\\n----------------WAll---------------\\n&quot;); print (root); printf (&quot;\\n----------------WAll---------------\\n\\n&quot;);}int main () { scanf (&quot;%d&quot;, &amp;n); s[0].maxl = -INF; for (int i = 1, x; i &lt;= n; i++) { scanf (&quot;%d&quot;, &amp;x); root = merge (root, newnode (x)); } scanf (&quot;%d&quot;, &amp;m); while (m--) { char opt; cin &gt;&gt; opt; int l, r, p, x; switch (opt) { case 'I' : { scanf (&quot;%d %d&quot;, &amp;p, &amp;x); insert (p - 1, x); break; } case 'D' : { scanf (&quot;%d&quot;, &amp;p); remove (p); break; } case 'R' : { scanf (&quot;%d %d&quot;, &amp;p, &amp;x); change (p, x); break; } case 'Q' : { scanf (&quot;%d %d&quot;, &amp;l, &amp;r); printf (&quot;%d\\n&quot;, query (l, r)); break; } }// debug (); } return 0;}","link":"/2021/08/05/2021-08-05-%E5%AE%A0%E7%89%A9%E6%94%B6%E7%95%99%E6%89%80&GSS6%E9%A2%98%E8%A7%A3/"},{"title":"「Note」线性基","text":"模板 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 65; const int BIT = 62;int n, base[MAXN];void insert (int x) { for (int i = BIT; i &gt;= 0; i--) { if ((1ll &lt;&lt; i) &amp; x) { if (base[i] == 0) { base[i] = x; break; } else x ^= base[i]; } }}int Maxval () { int res = 0; for (int i = BIT; i &gt;= 0; i--) { res = max (res, res ^ base[i]); } return res;}signed main () { scanf (&quot;%lld&quot;, &amp;n); for (int i = 1, x; i &lt;= n; i++) { scanf (&quot;%lld&quot;, &amp;x); insert (x); } printf (&quot;%lld\\n&quot;, Maxval ()); return 0;}","link":"/2021/05/15/2021-05-15-%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"title":"「Solution」异象石","text":"真·恶心题目, 调了两天。。。 异象石link 分析这道题即是求树上点集的最小覆盖边集合。 关键即是要考虑应该选择哪些边废话，这道题可以看作是「SDOI2015」寻宝游戏 的题面恶心版，问题的答案即是「SDOI2015」寻宝游戏 的答案的二分之一，因为你需要回到初始点，即每条在集合里的边都要走两遍。 转化后思路可以变得比较简单。 设当前新加入了一个点 x, 为了使x被覆盖掉，那么必定选从x出发到已经在已选中的路径上的距离x最近的点y(目标点)。 关键是求出该目标点。 画个草图(橙点是当前点x，红点是目标点，两个黑点分别是已插入的两个关键点pre, nxt)可以观察到： 新增的路径长为$add_1 + add_2 - del$即是$Dist(x, pre) + Dist (x,nxt) - Dist (pre, nxt)$。 问题即是求出pre和nxt. 根据dfs序可知，pre和nxt分别是dfn与dfn[x]相邻的两个点。 那么当当前点x处在最后或开头时就要再绕回开头或结尾(写得不清楚，自己理解。。。)。 就完了。 结论即是先求出所有点的dfn，把dfn围成一圈，答案是每相邻两个点的距离的和的一半。 然后我忘了可以用set，就调了两天的平衡树。。。 主要是脑抽把dfn求错了没有发现。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 5e5 + 5;const int MAXM = 25;int n, m, tot, t, st, fa[MAXN][MAXM], d[MAXN], dep[MAXN], dfn[MAXN], h[MAXN];int root, tmp1, tmp2, tmp3, ans;struct edge { int v, w; edge () {} edge (int V, int W) { v = V, w = W; }};vector&lt;edge&gt; G[MAXN];void Addedge (int u, int v, int w) { G[u].push_back (edge (v, w)); G[v].push_back (edge (u, w));}void dfs (int u, int fath, int s) { d[u] = s, dfn[u] = ++st, h[st] = u, dep[u] = dep[fath] + 1; for (int i = 1; i &lt;= t; i++) { fa[u][i] = fa[fa[u][i - 1]][i - 1]; } for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i].v, w = G[u][i].w; if (v == fath) continue; fa[v][0] = u; dfs (v, u, s + w); }}int Lca(int x, int y) { if (dep[x] &gt; dep[y]) { swap(x, y); } for (int i = t; i &gt;= 0; i--) { if (dep[fa[y][i]] &gt;= dep[x]) { y = fa[y][i]; } } if (x == y) return x; for (int i = t; i &gt;= 0; i--) { if (fa[x][i] != fa[y][i]) { x = fa[x][i]; y = fa[y][i]; } } return fa[x][0];}int Dist (int x, int y) { return d[x] + d[y] - 2 * d[Lca (x, y)];}struct Treap { int val, key, l, r, siz;} s[MAXN];void push_up (int p) { s[p].siz = s[s[p].l].siz + s[s[p].r].siz + 1;}void split (int p, int val, int&amp; x, int&amp; y) { if (p == 0) { x = y = 0; return; } if (s[p].val &lt;= val) { x = p; split (s[p].r, val, s[p].r, y); } else { y = p; split (s[p].l, val, x, s[p].l); } push_up (p);}int merge (int x, int y) { if (!x || !y) return x + y; if (s[x].key &lt; s[y].key) { s[x].r = merge (s[x].r, y); push_up (x); return x; } else { s[y].l = merge (x, s[y].l); push_up (y); return y; }}int newnode (int val) { s[++tot].val = val, s[tot].key = rand (), s[tot].siz = 1; return tot;}void insert (int val) { split (root, val, tmp1, tmp2); root = merge (merge (tmp1, newnode (val)), tmp2);}void remove (int val) { split (root, val, tmp1, tmp3); split (tmp1, val - 1, tmp1, tmp2); tmp2 = merge (s[tmp2].l, s[tmp2].r); root = merge (tmp1, merge (tmp2, tmp3));}int querykth (int p, int k) { while (1) { if (s[s[p].l].siz &gt;= k) { p = s[p].l; continue; } if (s[s[p].l].siz + 1 == k) { return p; } k -= s[s[p].l].siz + 1, p = s[p].r; }}int querymin (int p) { int res = INF; while (p) { res = min (res, s[p].val); p = s[p].l; } return res;}int querymax (int p) { int res = -INF; while (p) { res = max (res, s[p].val); p = s[p].r; } return res;}int querypre (int val) { tmp1 = 0, tmp2 = 0; split (root, val - 1, tmp1, tmp2); if (tmp1 == 0) { return querymax (root); } int res = s[querykth (tmp1, s[tmp1].siz)].val; root = merge (tmp1, tmp2); return res;}int querynxt (int val) { tmp1 = 0, tmp2 = 0; split (root, val, tmp1, tmp2); if (tmp2 == 0) { return querymin (root); } int res = s[querykth (tmp2, 1)].val; root = merge (tmp1, tmp2); return res;}void insert_tree (int x) { if (s[root].siz + 1 &lt;= 1) { insert (dfn[x]); ans = 0; return; } int pre = h[querypre (dfn[x])]; int nxt = h[querynxt (dfn[x])]; insert (dfn[x]); int add = Dist (pre, x) + Dist (nxt, x); int del = Dist (pre, nxt); ans = ans + add - del;}void remove_tree (int x) { if (s[root].siz - 1 &lt;= 1) { remove (dfn[x]); ans = 0; return; } int pre = h[querypre (dfn[x])]; int nxt = h[querynxt (dfn[x])]; remove (dfn[x]); int del = Dist (pre, x) + Dist (nxt, x); int add = Dist (pre, nxt); ans = ans + add - del;}signed main () {// freopen (&quot;data.in&quot;, &quot;r&quot;, stdin);// freopen (&quot;data.out&quot;, &quot;w&quot;, stdout); scanf (&quot;%lld&quot;, &amp;n); t = 22; for (int i = 1, u, v, w; i &lt; n; i++) { scanf (&quot;%lld %lld %lld&quot;, &amp;u, &amp;v, &amp;w); Addedge (u, v, w); } dfs (1, 0, 0); scanf (&quot;%lld&quot;, &amp;m); while (m--) { char opt; cin &gt;&gt; opt; int x; if (opt == '+') { scanf (&quot;%lld&quot;, &amp;x); insert_tree (x); } else if (opt == '-') { scanf (&quot;%lld&quot;, &amp;x); remove_tree (x); } else { printf (&quot;%lld\\n&quot;, ans / 2); }// cout &lt;&lt; &quot;==&quot; &lt;&lt; ans / 2 &lt;&lt; endl; } return 0;}","link":"/2021/08/10/2021-08-19-%E5%BC%82%E8%B1%A1%E7%9F%B3%20%E9%A2%98%E8%A7%A3/"},{"title":"「Note」2021-08-19 做题记录","text":"咕咕了一天，来写一个 A-F例题果断咕咕。 Glink 分析由裴蜀定理:$ax+by=d\\times \\gcd(a, b)$。可知$\\min (ax+by) = \\gcd(a,b)$ 那么从两个数推广到$n$个数可知$\\min(A_1X_1+A_2X_2+A_3X_3+…+A_nX_n)=\\gcd(A_1, A_2, A_3, \\dots ,A_n)$ Code123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;int n, ans;int gcd (int x, int y) { if (y == 0) return x; else return gcd (y, x % y);} signed main () { scanf (&quot;%lld&quot;, &amp;n); for (int i = 1, x; i &lt;= n; i++) { scanf (&quot;%lld&quot;, &amp;x); ans = gcd (ans, x); } printf (&quot;%lld\\n&quot;, ans &lt; 0 ? -ans : ans); return 0;} Borderlink 分析即使要求$(A_1X_1+A_2X_2+A_3X_3+…+A_nX_n) \\mod k$的所有值。 由上一题可知：$\\min(A_1X_1+A_2X_2+A_3X_3+…+A_nX_n)=\\gcd(A_1, A_2, A_3, \\dots ,A_n)$ 那么$(A_1X_1+A_2X_2+A_3X_3+…+A_nX_n) = d \\times \\gcd(A_1, A_2, A_3, \\dots ,A_n)$ 求出$\\gcd$后枚举即可。 C Looooopslink 开始一直没看懂题 分析即是求$a+cx $","link":"/2021/08/19/2021-08-19-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"「Solution」神秘博士","text":"咕咕了一天，来写一个","link":"/2021/08/19/2021-08-19-%E7%A5%9E%E7%A7%98%E5%8D%9A%E5%A3%AB%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」ABC215.F.Dist Max 2","text":"I’m good at making everything difficult! 提供一种线段树解法 link 分析考试时确实没想到二分，结果整了个线段树解法恶心自己，二分已经在课上讲了，此处不再赘述。 如果我们把问题简化，考虑如下图两个点的位置关系。 如果当前两点的距离为$tx-x$,那么由题目可知$ty-y&gt;tx-x$,移项得到$ty-tx&gt;y-x$ 如此，我们可以把分别维护两个点的横纵坐标差，变成维护一个点的横纵坐标之差。 那么若当前点为$(x_1, y_1)$,要使另一个点$(x_2, y_2)$ $(x_1\\leq x_2,y_1\\leq y_2)$与当前点之间的贡献为$x_2 - x_1$,必须满足的条件就是$y_1-x_1\\leq y_2-x_2$. 然后我们可以定义一个$d=y-x$,每个点按$d$升序排序，对于当前点$(x_i, y_i)$能在横坐标上产生的最大贡献是$\\max (x_i-x_j) | 1\\leq j &lt; i$. 那么只需要找到$[1,i-1]$中横坐标的最小值与当前点的横坐标做差即可。 这个地方就需要用到线段树。 但是会发现如此一来，我们只能统计到横纵坐标均小于等于当前点的点与当前点产生的贡献。 为了方便，我们假设所有点在第一象限，那么我们只需要按$x$轴、$y$轴分别将所有点翻转到另外三个象限再次统计答案即可。 如果是在纵坐标上产生贡献，统计方法与横坐标同理。 然后考场上没调出来。。。 后来发现是忘了初始化。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 200005;const int INF = 0x3f3f3f3f;int n, cnt, ans, tx[MAXN], ty[MAXN];map&lt;int, int&gt; h;struct node { int x, y, d;} a[MAXN];int Abs (int x) { if (x &lt; 0) return -x; else return x;}bool cmp1 (node p, node q) { if (p.d == q.d) { return p.x &gt; q.x; } else return p.d &lt; q.d;}bool cmp2 (node p, node q) { if (p.d == q.d) { return p.y &gt; q.y; } else return p.d &lt; q.d;}struct SegmentTree { int l, r, dat;} s[MAXN * 4];void push_up (int p) { s[p].dat = max (s[p &lt;&lt; 1].dat, s[p &lt;&lt; 1 | 1].dat);}void build (int p, int l, int r) { s[p].l = l, s[p].r = r; if (l == r) { s[p].dat = -INF; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; build (p &lt;&lt; 1, l, mid); build (p &lt;&lt; 1 | 1, mid + 1, r);}void update (int p, int x, int val) { if (s[p].l == s[p].r) { s[p].dat = val; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (x &lt;= mid) update (p &lt;&lt; 1, x, val); else update (p &lt;&lt; 1 | 1, x, val); push_up (p);}int query (int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) { return s[p].dat; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; int res = -INF; if (l &lt;= mid) res = max (res, query (p &lt;&lt; 1, l, r)); if (r &gt; mid) res = max (res, query (p &lt;&lt; 1 | 1, l, r)); return res;}void Find () { build (1, 1, n); for (int i = 1; i &lt;= n; i++) a[i].d = a[i].x - a[i].y; sort (a + 1, a + 1 + n, cmp1); cnt = 0; h.clear(); for (int i = 1; i &lt;= n; i++) { if (a[i].d != a[i - 1].d) { h[a[i].d] = ++cnt; update (1, cnt, a[i].x); } } for (int i = 1; i &lt;= n; i++) { int hdi = h[a[i].d]; ans = max (ans, query (1, 1, hdi) - a[i].x); } for (int i = 1; i &lt;= n; i++) a[i].d = a[i].y - a[i].x; build (1, 1, n); sort (a + 1, a + 1 + n, cmp2); cnt = 0; h.clear(); for (int i = 1; i &lt;= n; i++) { if (a[i].d != a[i - 1].d) { h[a[i].d] = ++cnt; update (1, cnt, a[i].y); } } for (int i = 1; i &lt;= n; i++) { int hdi = h[a[i].d]; ans = max (ans, query (1, 1, hdi) - a[i].y); }}void Forward () { for (int i = -1; i &lt;= 1; i += 2) { for (int j = -1; j &lt;= 1; j += 2) { for (int k = 1; k &lt;= n; k++) { a[k].x = i * tx[k]; a[k].y = j * ty[k];// printf (&quot;%d %d\\n&quot;, a[k].x, a[k].y); }// printf (&quot;-------------\\n&quot;); Find (); } }}int main () { scanf (&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf (&quot;%d %d&quot;, &amp;a[i].x, &amp;a[i].y); tx[i] = a[i].x, ty[i] = a[i].y; } Forward (); printf (&quot;%d\\n&quot;, ans); return 0;}","link":"/2021/08/23/2021-08-23-ABC215.F.Dist%20Max%202%E9%A2%98%E8%A7%A3/"},{"title":"「Summary」数论究极整理","text":"I’m good at making everything difficult! 前几天懒得写，只有累到今天来补一下。。。。。。 线性筛咕掉埃氏筛 欧拉筛即是线性筛，可以在$\\Theta(n)$的时间复杂度里筛出质数。 123456789for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { pr[++cnt] = i; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= n; j++) { vis[i * pr[j]] = 1; if (i % pr[j] == 0) break; }} 积性函数 积性函数 $$\\forall x,y.\\ \\gcd(x, y) = 1 \\rightarrow f(x\\times y)=f(x)\\times f(y)$$ 完全积性函数 $$\\forall x, y.\\f(x\\times y) = f(x)\\times f(y)$$ 对于积性函数，我们可以通过线性筛计算，下面给出一些常见的积性函数计算方法。 欧拉函数定义:$\\phi(n)=\\sum_{i= 1}^n(\\gcd(i, n) = 1)$ 123456789101112131415phi[1] = 1;for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { pr[++cnt] = i; phi[i] = i - 1; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= n; j++) { vis[i * pr[j]] = 1; if (i % pr[j] == 0) { phi[i * pr[j]] = pr[j] * phi[i]; break; } phi[i * pr[j]] = phi[i] * phi[pr[j]]; }} 约数个数定义:$d(n)=\\sum_{i=1}^n((n\\mod i) = 0)$ 设$num(i)$为$i$的最小质因子出现次数。 约数个数定理$$n=\\prod_{i=1}^m p_i^{q_i}\\ \\rightarrow d(n)=\\prod_{i=1}^m(q_i + 1)$$ 12345678910111213141516171819d[1] = 1, num[1] = 1;for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { pr[++cnt] = i; d[i] = 2; num[i] = 1; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= n; j++) { vis[i * pr[j]] = 1; if (i % pr[j] == 0) { num[i * pr[j]] = num[i] + 1; d[i * pr[j]] = d[i] / num[i * pr[j]] * (num[i * pr[j]] + 1); break; } else { num[i * pr[j]] = 1; d[i * pr[j]] * 2; } }} 约数和定义:$f(n)=\\sum_{i = 1}^n((n\\mod i) = 0)\\times i$ 123456789101112131415161718g[1] = g[1] = 1;for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { pr[++cnt] = i; f[i] = g[i] = i + 1; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= n; j++) { vis[pr[j] * i] = 1; if (i % pr[j] == 0) { g[i * pr[j]] = g[i] * pr[j] + 1; f[i * pr[j]] = f[i] / g[i] * g[i * pr[j]]; break; } else { f[i * pr[j]] = f[i] * f[pr[j]]; g[i * pr[j]] = 1 + pr[j]; } }} 欧拉定理若$\\gcd(a, m) = 1 \\rightarrow a^{\\varphi(m)} \\equiv 1\\pmod m$ 原根 阶：由欧拉定理可知，对 $a\\in \\mathbb{Z}$，$m\\in\\mathbb{N}^{*}$，若 $\\gcd(a,m)=1$，则 $a^{\\varphi(m)}\\equiv 1\\pmod m$。 因此满足同余式 $a^n \\equiv 1 \\pmod m$ 的最小正整数 $n$ 存在，这个 $n$ 称作 $a$ 模 $m$ 的阶，记作 $\\delta_m(a)$。 性质$$a,a^2,a^3,…,a^{\\delta_m(a)}模m不同余$$ $$若a^n \\equiv 1 \\pmod m \\rightarrow \\delta_m(a)|n$$ 威尔逊定理当$p$时素数时,$(p-1)! \\equiv p - 1\\pmod p$ 裴蜀定理$\\forall x, y$当$\\gcd(x,y)|m$时,方程$k_1x+k_2y=m$有解。 扩展欧几里得12345678910int exgcd (int&amp; x, int&amp; y, int a, int b) { if (b == 0) { x = 1, y = 0; return a; } int t, res; res = exgcd (x, y, b, a % b); t = x, x = y, y = t - a / b * x; return res;} CRT &amp; ExCRT扩展中国剩余定理用于求解模线性同余方程组。 其思想是依次合并两个方程直到剩下一个方程，就是解系。 123456789101112131415161718void ExCRt () { int m1 = m[1], r1 = r[1]; for (int i = 2; i &lt;= n; i++) { int m2 = m[i], r2 = r[i]; int k1, k2; int tmp = r2 - r1; int g = exgcd (k1, k2, m1, m2); if (tmp % g != 0) { printf (&quot;-1\\n&quot;); break; } exgcd (k1, k2, m1 / g, m2 / g); k1 = (tmp / g * k1) % (m2 / g); r1 += k1 * m1; m1 = m1 / g * m2; r1 = (r1 + m1) % m1; }} 以上所有定理证明先占坑。","link":"/2021/08/23/2021-08-23-%E6%95%B0%E8%AE%BA%E7%A9%B6%E6%9E%81%E6%95%B4%E7%90%86/"},{"title":"「Note」状压dp","text":"近期学习了状压dp,简单做一个小结。 定义状压dp是动态规划的一种，它通过将多维的状态压缩成一个具有映射关系的数字来实现降维，从而简化代码实现难度。 优点可以通过位运算判断的高效性降低时间，但是当状态的情况无法转换成二进制数的时候会变得比较麻烦。 例题糖果link此题并非真正的状压dp，而是一道二进制压缩的板题。可以用 $|$ 运算求出并集。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1005;const int MAXM = 1e5 + 5; int n, m, sum;int dp[MAXM], w[MAXN], a[MAXN];int main() { memset(dp, 0x3f, sizeof(dp)); scanf (&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, k; i &lt;= n; i++) { scanf (&quot;%d %d&quot;, &amp;a[i], &amp;k); w[i] = 0; for (int j = 1, x; j &lt;= k; j++) { scanf (&quot;%d&quot;, &amp;x); w[i] |= (1 &lt;&lt; x); } } dp[0] = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; (1 &lt;&lt; m); j++) { dp[j | w[i]] = min(dp[j | w[i]], dp[j] + a[i]); } } printf (&quot;%d\\n&quot;, dp[(1 &lt;&lt; m) - 1]); return 0;} 最短Hamilton路径link暴力枚举状态 $w$, $dp[w][i] = dp[w][i] = min(dp[w][i], dp[w &amp; (~(1 &lt;&lt; i))][j] + dis[j][i])$稍稍处理细节即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 25;const int MAXM = 1 &lt;&lt; 20 + 3;void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f - f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); } x *= f;}void write(int x) { if (x &lt; 0) { putchar('-'); x = (~x) + 1; } if (x &gt; 9) { write(x / 10); } putchar(x % 10 + '0');}int n;int dis[MAXN][MAXN], dp[MAXM][MAXN];int main() { read(n); for (int i = 0; i &lt; (1 &lt;&lt; n); i++) for (int j = 0; j &lt; n; j++) dp[i][j] = INF; for (int i = 0; i &lt; n; i++) { for (int j = 0, x; j &lt; n; j++) { read(x); dis[i][j] = dis[j][i] = x; } } dp[1][0] = 0; for (int w = 0; w &lt; (1 &lt;&lt; n); w++) { for (int i = 0; i &lt; n; i++) { if (w &amp; (1 &lt;&lt; i) == 0) continue; for (int j = 0; j &lt; n; j++) { if (w &amp; (1 &lt;&lt; j) == 0 || i == j) continue; dp[w][i] = min(dp[w][i], dp[w &amp; (~(1 &lt;&lt; i))][j] + dis[j][i]); } } } printf(&quot;%d\\n&quot;, dp[(1 &lt;&lt; n) - 1][n - 1]); return 0;} Mondriaan’s Dreamlink开始有点难度了。按格dp，对上方和左方的格子的占用情况进行讨论转移。0表示已放置，1表示未放置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXM = 1 &lt;&lt; 11;const int MAXN = 15;void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f - f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; c = getchar(); } x *= f;}void write(int x) { if (x &lt; 0) { putchar('-'); x = (~x) + 1; } if (x &gt; 9) { write(x / 10); } putchar(x % 10 + '0');}int n, m;bool in_s[MAXM];long long dp[MAXN][MAXM];int main() { while (scanf (&quot;%d %d&quot;, &amp;n, &amp;m), n, m) { for (int i = 0; i &lt; (1 &lt;&lt; m); i++) { bool cnt = 0, has_odd = 0; for (int j = 0; j &lt; m; j++) { if (i &amp; (1 &lt;&lt; j)) has_odd |= cnt, cnt = 0; else cnt ^= 1; } in_s[i] = cnt | has_odd ? 0 : 1; } dp[0][0] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; (1 &lt;&lt; m); j++) { dp[i][j] = 0; for (int k = 0; k &lt; (1 &lt;&lt; m); k++) { if (in_s[j | k] &amp;&amp; (j &amp; k) == 0) { dp[i][j] += dp[i - 1][k]; } } } } printf (&quot;%lld\\n&quot;, dp[n][0]); } return 0;} working…","link":"/2021/01/14/2021-1-14-%E7%8A%B6%E5%8E%8Bdp%E5%B0%8F%E7%BB%93/"},{"title":"「Summary」初二20210619综合测试","text":"赛后总结 流水账0-5min看完题, 定了顺序题目难度应该是 : 2 1 3 4 5-20min写完了T2。 20-30min对T2进行静态查错 30-50min想了T3的《正解》，但证明不会。 50-75min写完了T3的《正解》，过了样例 75-90min谢了T3的对拍 90-100min对拍出错了。 是 对拍 出错了 100-101min光速修对拍，原因是在生成 l和r时，忘了交换大小。。。 101-102min对拍出错了。 这次是对拍出 错 了。 102-115min开始质疑T3《正解》。 然后看了看 Hack 数据。 但是貌似我修不好T3。 然后进行了《正确率分析》 用对拍算了一下，大概只有 $60 - 70 % $的正确率。 115-120min乱搞T4。 120-130min读懂了第一题 130-150min写完了正解。 150-175min开始瞎搞打表。。。 step1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 6;const char table[10] = {0, 'I', 'V', 'X', 'L', 'C', 'D', 'M'};int n, cnt, a[MAXN], t[MAXN * 2];void change (int x) { cnt = 0; while (x) { a[++cnt] = x % 10; x /= 10; }}void print (int x) { for (int i = cnt; i &gt;= 1; i--) { if (i == 1) { if (a[i] == 4) { printf (&quot;VI&quot;); t[1]++, t[2]++; } if (a[i] == 5) { printf (&quot;V&quot;); t[2]++; } if (a[i] == 9) { printf (&quot;IX&quot;); t[1]++, t[3]++; } if (a[i] &lt;= 3) { for (int j = 1; j &lt;= a[i]; j++) { printf (&quot;I&quot;); t[1]++; } } if (a[i] &gt; 5 &amp;&amp; a[i] &lt; 9) { printf (&quot;V&quot;); t[2]++; for (int j = 6; j &lt;= a[i]; j++) { printf (&quot;I&quot;); t[1]++; } } } if (i == 2) { if (a[i] == 4) { printf (&quot;LX&quot;); t[4]++, t[3]++; } if (a[i] == 5) { printf (&quot;L&quot;); t[4]++; } if (a[i] == 9) { printf (&quot;XC&quot;); t[3]++, t[5]++; } if (a[i] &lt;= 3) { for (int j = 1; j &lt;= a[i]; j++) { printf (&quot;X&quot;); t[3]++; } } if (a[i] &gt; 5 &amp;&amp; a[i] &lt; 9) { printf (&quot;L&quot;); t[4]++; for (int j = 6; j &lt;= a[i]; j++) { printf (&quot;X&quot;); t[3]++; } } } if (i == 3) { if (a[i] == 4) { printf (&quot;DC&quot;); t[6]++, t[5]++; } if (a[i] == 5) { printf (&quot;D&quot;); t[6]++; } if (a[i] == 9) { printf (&quot;CM&quot;); t[5]++, t[7]++; } if (a[i] &lt;= 3) { for (int j = 1; j &lt;= a[i]; j++) { printf (&quot;C&quot;); t[5]++; } } if (a[i] &gt; 5 &amp;&amp; a[i] &lt; 9) { printf (&quot;D&quot;); t[6]++; for (int j = 6; j &lt;= a[i]; j++) { printf (&quot;C&quot;); t[5]++; } } } if (i == 4) { for (int j = 1; j &lt;= a[i]; j++) { printf (&quot;M&quot;); t[7]++; } } } printf (&quot;\\n&quot;);}int main () { freopen (&quot;table.in&quot;, &quot;w&quot;, stdout); n = 3500; for (int i = 1; i &lt;= n; i++) { change (i); print (i); } for (int i = 1; i &lt;= 7; i++) { if (t[i] != 0) { printf (&quot;%c %d\\n&quot;, table[i], t[i]); } } return 0;} step2 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int t[10][3500];char s[100];int main () { freopen (&quot;table.in&quot;, &quot;r&quot;, stdin); freopen (&quot;table.out&quot;, &quot;w&quot;, stdout); for (int i = 1; i &lt;= 3500; i++) { scanf (&quot;%s&quot;, s + 1); int len = strlen (s + 1); for (int j = 1; j &lt;= 7; j++) t[j][i] = t[j][i - 1]; for (int j = 1; j &lt;= len; j++) { if (s[j] == 'I') t[1][i]++; if (s[j] == 'V') t[2][i]++; if (s[j] == 'X') t[3][i]++; if (s[j] == 'L') t[4][i]++; if (s[j] == 'C') t[5][i]++; if (s[j] == 'D') t[6][i]++; if (s[j] == 'M') t[7][i]++; } } for (int i = 1; i &lt;= 7; i++) { printf (&quot;const int t%d[3505] = {0, &quot;, i); for (int j = 1; j &lt; 3500; j++) { printf (&quot;%d, &quot;, t[i][j]); } printf (&quot;%d&quot;, t[i][3500]); printf (&quot;};\\n&quot;); } return 0;} 然后。。。 10k code 警告 175-200min开始检查细节。 resultOJ: 100+100+79+29=308 Lemon: 0+100+60+10=170 打表代码太长结果找不到源程序。 然后重新交了一份正解。 Lemon:100+100+60+10=270 summary不该写T1的打表。 花了30min，结果还是徒劳。 反而T4的暴力翻车了。。。 T3其实是接近正解，但是没把特殊情况讨论出来。 教训有把握的题就不要写得太zuo，把时间留给难题。 题解先贴代码。 T1 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int t1[3510] = {0, 1, 3, 6, 7, 7, 8, 10, 13, 14, 14, 15, 17, 20, 21, 21, 22, 24, 27, 28, 28, 29, 31, 34, 35, 35, 36, 38, 41, 42, 42, 43, 45, 48, 49, 49, 50, 52, 55, 56, 56, 57, 59, 62, 63, 63, 64, 66, 69, 70, 70, 71, 73, 76, 77, 77, 78, 80, 83, 84, 84, 85, 87, 90, 91, 91, 92, 94, 97, 98, 98, 99, 101, 104, 105, 105, 106, 108, 111, 112, 112, 113, 115, 118, 119, 119, 120, 122, 125, 126, 126, 127, 129, 132, 133, 133, 134, 136, 139, 140, 140, 141, 143, 146, 147, 147, 148, 150, 153, 154, 154, 155, 157, 160, 161, 161, 162, 164, 167, 168, 168, 169, 171, 174, 175, 175, 176, 178, 181, 182, 182, 183, 185, 188, 189, 189, 190, 192, 195, 196, 196, 197, 199, 202, 203, 203, 204, 206, 209, 210, 210, 211, 213, 216, 217, 217, 218, 220, 223, 224, 224, 225, 227, 230, 231, 231, 232, 234, 237, 238, 238, 239, 241, 244, 245, 245, 246, 248, 251, 252, 252, 253, 255, 258, 259, 259, 260, 262, 265, 266, 266, 267, 269, 272, 273, 273, 274, 276, 279, 280, 280, 281, 283, 286, 287, 287, 288, 290, 293, 294, 294, 295, 297, 300, 301, 301, 302, 304, 307, 308, 308, 309, 311, 314, 315, 315, 316, 318, 321, 322, 322, 323, 325, 328, 329, 329, 330, 332, 335, 336, 336, 337, 339, 342, 343, 343, 344, 346, 349, 350, 350, 351, 353, 356, 357, 357, 358, 360, 363, 364, 364, 365, 367, 370, 371, 371, 372, 374, 377, 378, 378, 379, 381, 384, 385, 385, 386, 388, 391, 392, 392, 393, 395, 398, 399, 399, 400, 402, 405, 406, 406, 407, 409, 412, 413, 413, 414, 416, 419, 420, 420, 421, 423, 426, 427, 427, 428, 430, 433, 434, 434, 435, 437, 440, 441, 441, 442, 444, 447, 448, 448, 449, 451, 454, 455, 455, 456, 458, 461, 462, 462, 463, 465, 468, 469, 469, 470, 472, 475, 476, 476, 477, 479, 482, 483, 483, 484, 486, 489, 490, 490, 491, 493, 496, 497, 497, 498, 500, 503, 504, 504, 505, 507, 510, 511, 511, 512, 514, 517, 518, 518, 519, 521, 524, 525, 525, 526, 528, 531, 532, 532, 533, 535, 538, 539, 539, 540, 542, 545, 546, 546, 547, 549, 552, 553, 553, 554, 556, 559, 560, 560, 561, 563, 566, 567, 567, 568, 570, 573, 574, 574, 575, 577, 580, 581, 581, 582, 584, 587, 588, 588, 589, 591, 594, 595, 595, 596, 598, 601, 602, 602, 603, 605, 608, 609, 609, 610, 612, 615, 616, 616, 617, 619, 622, 623, 623, 624, 626, 629, 630, 630, 631, 633, 636, 637, 637, 638, 640, 643, 644, 644, 645, 647, 650, 651, 651, 652, 654, 657, 658, 658, 659, 661, 664, 665, 665, 666, 668, 671, 672, 672, 673, 675, 678, 679, 679, 680, 682, 685, 686, 686, 687, 689, 692, 693, 693, 694, 696, 699, 700, 700, 701, 703, 706, 707, 707, 708, 710, 713, 714, 714, 715, 717, 720, 721, 721, 722, 724, 727, 728, 728, 729, 731, 734, 735, 735, 736, 738, 741, 742, 742, 743, 745, 748, 749, 749, 750, 752, 755, 756, 756, 757, 759, 762, 763, 763, 764, 766, 769, 770, 770, 771, 773, 776, 777, 777, 778, 780, 783, 784, 784, 785, 787, 790, 791, 791, 792, 794, 797, 798, 798, 799, 801, 804, 805, 805, 806, 808, 811, 812, 812, 813, 815, 818, 819, 819, 820, 822, 825, 826, 826, 827, 829, 832, 833, 833, 834, 836, 839, 840, 840, 841, 843, 846, 847, 847, 848, 850, 853, 854, 854, 855, 857, 860, 861, 861, 862, 864, 867, 868, 868, 869, 871, 874, 875, 875, 876, 878, 881, 882, 882, 883, 885, 888, 889, 889, 890, 892, 895, 896, 896, 897, 899, 902, 903, 903, 904, 906, 909, 910, 910, 911, 913, 916, 917, 917, 918, 920, 923, 924, 924, 925, 927, 930, 931, 931, 932, 934, 937, 938, 938, 939, 941, 944, 945, 945, 946, 948, 951, 952, 952, 953, 955, 958, 959, 959, 960, 962, 965, 966, 966, 967, 969, 972, 973, 973, 974, 976, 979, 980, 980, 981, 983, 986, 987, 987, 988, 990, 993, 994, 994, 995, 997, 1000, 1001, 1001, 1002, 1004, 1007, 1008, 1008, 1009, 1011, 1014, 1015, 1015, 1016, 1018, 1021, 1022, 1022, 1023, 1025, 1028, 1029, 1029, 1030, 1032, 1035, 1036, 1036, 1037, 1039, 1042, 1043, 1043, 1044, 1046, 1049, 1050, 1050, 1051, 1053, 1056, 1057, 1057, 1058, 1060, 1063, 1064, 1064, 1065, 1067, 1070, 1071, 1071, 1072, 1074, 1077, 1078, 1078, 1079, 1081, 1084, 1085, 1085, 1086, 1088, 1091, 1092, 1092, 1093, 1095, 1098, 1099, 1099, 1100, 1102, 1105, 1106, 1106, 1107, 1109, 1112, 1113, 1113, 1114, 1116, 1119, 1120, 1120, 1121, 1123, 1126, 1127, 1127, 1128, 1130, 1133, 1134, 1134, 1135, 1137, 1140, 1141, 1141, 1142, 1144, 1147, 1148, 1148, 1149, 1151, 1154, 1155, 1155, 1156, 1158, 1161, 1162, 1162, 1163, 1165, 1168, 1169, 1169, 1170, 1172, 1175, 1176, 1176, 1177, 1179, 1182, 1183, 1183, 1184, 1186, 1189, 1190, 1190, 1191, 1193, 1196, 1197, 1197, 1198, 1200, 1203, 1204, 1204, 1205, 1207, 1210, 1211, 1211, 1212, 1214, 1217, 1218, 1218, 1219, 1221, 1224, 1225, 1225, 1226, 1228, 1231, 1232, 1232, 1233, 1235, 1238, 1239, 1239, 1240, 1242, 1245, 1246, 1246, 1247, 1249, 1252, 1253, 1253, 1254, 1256, 1259, 1260, 1260, 1261, 1263, 1266, 1267, 1267, 1268, 1270, 1273, 1274, 1274, 1275, 1277, 1280, 1281, 1281, 1282, 1284, 1287, 1288, 1288, 1289, 1291, 1294, 1295, 1295, 1296, 1298, 1301, 1302, 1302, 1303, 1305, 1308, 1309, 1309, 1310, 1312, 1315, 1316, 1316, 1317, 1319, 1322, 1323, 1323, 1324, 1326, 1329, 1330, 1330, 1331, 1333, 1336, 1337, 1337, 1338, 1340, 1343, 1344, 1344, 1345, 1347, 1350, 1351, 1351, 1352, 1354, 1357, 1358, 1358, 1359, 1361, 1364, 1365, 1365, 1366, 1368, 1371, 1372, 1372, 1373, 1375, 1378, 1379, 1379, 1380, 1382, 1385, 1386, 1386, 1387, 1389, 1392, 1393, 1393, 1394, 1396, 1399, 1400, 1400, 1401, 1403, 1406, 1407, 1407, 1408, 1410, 1413, 1414, 1414, 1415, 1417, 1420, 1421, 1421, 1422, 1424, 1427, 1428, 1428, 1429, 1431, 1434, 1435, 1435, 1436, 1438, 1441, 1442, 1442, 1443, 1445, 1448, 1449, 1449, 1450, 1452, 1455, 1456, 1456, 1457, 1459, 1462, 1463, 1463, 1464, 1466, 1469, 1470, 1470, 1471, 1473, 1476, 1477, 1477, 1478, 1480, 1483, 1484, 1484, 1485, 1487, 1490, 1491, 1491, 1492, 1494, 1497, 1498, 1498, 1499, 1501, 1504, 1505, 1505, 1506, 1508, 1511, 1512, 1512, 1513, 1515, 1518, 1519, 1519, 1520, 1522, 1525, 1526, 1526, 1527, 1529, 1532, 1533, 1533, 1534, 1536, 1539, 1540, 1540, 1541, 1543, 1546, 1547, 1547, 1548, 1550, 1553, 1554, 1554, 1555, 1557, 1560, 1561, 1561, 1562, 1564, 1567, 1568, 1568, 1569, 1571, 1574, 1575, 1575, 1576, 1578, 1581, 1582, 1582, 1583, 1585, 1588, 1589, 1589, 1590, 1592, 1595, 1596, 1596, 1597, 1599, 1602, 1603, 1603, 1604, 1606, 1609, 1610, 1610, 1611, 1613, 1616, 1617, 1617, 1618, 1620, 1623, 1624, 1624, 1625, 1627, 1630, 1631, 1631, 1632, 1634, 1637, 1638, 1638, 1639, 1641, 1644, 1645, 1645, 1646, 1648, 1651, 1652, 1652, 1653, 1655, 1658, 1659, 1659, 1660, 1662, 1665, 1666, 1666, 1667, 1669, 1672, 1673, 1673, 1674, 1676, 1679, 1680, 1680, 1681, 1683, 1686, 1687, 1687, 1688, 1690, 1693, 1694, 1694, 1695, 1697, 1700, 1701, 1701, 1702, 1704, 1707, 1708, 1708, 1709, 1711, 1714, 1715, 1715, 1716, 1718, 1721, 1722, 1722, 1723, 1725, 1728, 1729, 1729, 1730, 1732, 1735, 1736, 1736, 1737, 1739, 1742, 1743, 1743, 1744, 1746, 1749, 1750, 1750, 1751, 1753, 1756, 1757, 1757, 1758, 1760, 1763, 1764, 1764, 1765, 1767, 1770, 1771, 1771, 1772, 1774, 1777, 1778, 1778, 1779, 1781, 1784, 1785, 1785, 1786, 1788, 1791, 1792, 1792, 1793, 1795, 1798, 1799, 1799, 1800, 1802, 1805, 1806, 1806, 1807, 1809, 1812, 1813, 1813, 1814, 1816, 1819, 1820, 1820, 1821, 1823, 1826, 1827, 1827, 1828, 1830, 1833, 1834, 1834, 1835, 1837, 1840, 1841, 1841, 1842, 1844, 1847, 1848, 1848, 1849, 1851, 1854, 1855, 1855, 1856, 1858, 1861, 1862, 1862, 1863, 1865, 1868, 1869, 1869, 1870, 1872, 1875, 1876, 1876, 1877, 1879, 1882, 1883, 1883, 1884, 1886, 1889, 1890, 1890, 1891, 1893, 1896, 1897, 1897, 1898, 1900, 1903, 1904, 1904, 1905, 1907, 1910, 1911, 1911, 1912, 1914, 1917, 1918, 1918, 1919, 1921, 1924, 1925, 1925, 1926, 1928, 1931, 1932, 1932, 1933, 1935, 1938, 1939, 1939, 1940, 1942, 1945, 1946, 1946, 1947, 1949, 1952, 1953, 1953, 1954, 1956, 1959, 1960, 1960, 1961, 1963, 1966, 1967, 1967, 1968, 1970, 1973, 1974, 1974, 1975, 1977, 1980, 1981, 1981, 1982, 1984, 1987, 1988, 1988, 1989, 1991, 1994, 1995, 1995, 1996, 1998, 2001, 2002, 2002, 2003, 2005, 2008, 2009, 2009, 2010, 2012, 2015, 2016, 2016, 2017, 2019, 2022, 2023, 2023, 2024, 2026, 2029, 2030, 2030, 2031, 2033, 2036, 2037, 2037, 2038, 2040, 2043, 2044, 2044, 2045, 2047, 2050, 2051, 2051, 2052, 2054, 2057, 2058, 2058, 2059, 2061, 2064, 2065, 2065, 2066, 2068, 2071, 2072, 2072, 2073, 2075, 2078, 2079, 2079, 2080, 2082, 2085, 2086, 2086, 2087, 2089, 2092, 2093, 2093, 2094, 2096, 2099, 2100, 2100, 2101, 2103, 2106, 2107, 2107, 2108, 2110, 2113, 2114, 2114, 2115, 2117, 2120, 2121, 2121, 2122, 2124, 2127, 2128, 2128, 2129, 2131, 2134, 2135, 2135, 2136, 2138, 2141, 2142, 2142, 2143, 2145, 2148, 2149, 2149, 2150, 2152, 2155, 2156, 2156, 2157, 2159, 2162, 2163, 2163, 2164, 2166, 2169, 2170, 2170, 2171, 2173, 2176, 2177, 2177, 2178, 2180, 2183, 2184, 2184, 2185, 2187, 2190, 2191, 2191, 2192, 2194, 2197, 2198, 2198, 2199, 2201, 2204, 2205, 2205, 2206, 2208, 2211, 2212, 2212, 2213, 2215, 2218, 2219, 2219, 2220, 2222, 2225, 2226, 2226, 2227, 2229, 2232, 2233, 2233, 2234, 2236, 2239, 2240, 2240, 2241, 2243, 2246, 2247, 2247, 2248, 2250, 2253, 2254, 2254, 2255, 2257, 2260, 2261, 2261, 2262, 2264, 2267, 2268, 2268, 2269, 2271, 2274, 2275, 2275, 2276, 2278, 2281, 2282, 2282, 2283, 2285, 2288, 2289, 2289, 2290, 2292, 2295, 2296, 2296, 2297, 2299, 2302, 2303, 2303, 2304, 2306, 2309, 2310, 2310, 2311, 2313, 2316, 2317, 2317, 2318, 2320, 2323, 2324, 2324, 2325, 2327, 2330, 2331, 2331, 2332, 2334, 2337, 2338, 2338, 2339, 2341, 2344, 2345, 2345, 2346, 2348, 2351, 2352, 2352, 2353, 2355, 2358, 2359, 2359, 2360, 2362, 2365, 2366, 2366, 2367, 2369, 2372, 2373, 2373, 2374, 2376, 2379, 2380, 2380, 2381, 2383, 2386, 2387, 2387, 2388, 2390, 2393, 2394, 2394, 2395, 2397, 2400, 2401, 2401, 2402, 2404, 2407, 2408, 2408, 2409, 2411, 2414, 2415, 2415, 2416, 2418, 2421, 2422, 2422, 2423, 2425, 2428, 2429, 2429, 2430, 2432, 2435, 2436, 2436, 2437, 2439, 2442, 2443, 2443, 2444, 2446, 2449, 2450, 2450, 2451, 2453, 2456, 2457, 2457, 2458, 2460, 2463, 2464, 2464, 2465, 2467, 2470, 2471, 2471, 2472, 2474, 2477, 2478, 2478, 2479, 2481, 2484, 2485, 2485, 2486, 2488, 2491, 2492, 2492, 2493, 2495, 2498, 2499, 2499, 2500, 2502, 2505, 2506, 2506, 2507, 2509, 2512, 2513, 2513, 2514, 2516, 2519, 2520, 2520, 2521, 2523, 2526, 2527, 2527, 2528, 2530, 2533, 2534, 2534, 2535, 2537, 2540, 2541, 2541, 2542, 2544, 2547, 2548, 2548, 2549, 2551, 2554, 2555, 2555, 2556, 2558, 2561, 2562, 2562, 2563, 2565, 2568, 2569, 2569, 2570, 2572, 2575, 2576, 2576, 2577, 2579, 2582, 2583, 2583, 2584, 2586, 2589, 2590, 2590, 2591, 2593, 2596, 2597, 2597, 2598, 2600, 2603, 2604, 2604, 2605, 2607, 2610, 2611, 2611, 2612, 2614, 2617, 2618, 2618, 2619, 2621, 2624, 2625, 2625, 2626, 2628, 2631, 2632, 2632, 2633, 2635, 2638, 2639, 2639, 2640, 2642, 2645, 2646, 2646, 2647, 2649, 2652, 2653, 2653, 2654, 2656, 2659, 2660, 2660, 2661, 2663, 2666, 2667, 2667, 2668, 2670, 2673, 2674, 2674, 2675, 2677, 2680, 2681, 2681, 2682, 2684, 2687, 2688, 2688, 2689, 2691, 2694, 2695, 2695, 2696, 2698, 2701, 2702, 2702, 2703, 2705, 2708, 2709, 2709, 2710, 2712, 2715, 2716, 2716, 2717, 2719, 2722, 2723, 2723, 2724, 2726, 2729, 2730, 2730, 2731, 2733, 2736, 2737, 2737, 2738, 2740, 2743, 2744, 2744, 2745, 2747, 2750, 2751, 2751, 2752, 2754, 2757, 2758, 2758, 2759, 2761, 2764, 2765, 2765, 2766, 2768, 2771, 2772, 2772, 2773, 2775, 2778, 2779, 2779, 2780, 2782, 2785, 2786, 2786, 2787, 2789, 2792, 2793, 2793, 2794, 2796, 2799, 2800, 2800, 2801, 2803, 2806, 2807, 2807, 2808, 2810, 2813, 2814, 2814, 2815, 2817, 2820, 2821, 2821, 2822, 2824, 2827, 2828, 2828, 2829, 2831, 2834, 2835, 2835, 2836, 2838, 2841, 2842, 2842, 2843, 2845, 2848, 2849, 2849, 2850, 2852, 2855, 2856, 2856, 2857, 2859, 2862, 2863, 2863, 2864, 2866, 2869, 2870, 2870, 2871, 2873, 2876, 2877, 2877, 2878, 2880, 2883, 2884, 2884, 2885, 2887, 2890, 2891, 2891, 2892, 2894, 2897, 2898, 2898, 2899, 2901, 2904, 2905, 2905, 2906, 2908, 2911, 2912, 2912, 2913, 2915, 2918, 2919, 2919, 2920, 2922, 2925, 2926, 2926, 2927, 2929, 2932, 2933, 2933, 2934, 2936, 2939, 2940, 2940, 2941, 2943, 2946, 2947, 2947, 2948, 2950, 2953, 2954, 2954, 2955, 2957, 2960, 2961, 2961, 2962, 2964, 2967, 2968, 2968, 2969, 2971, 2974, 2975, 2975, 2976, 2978, 2981, 2982, 2982, 2983, 2985, 2988, 2989, 2989, 2990, 2992, 2995, 2996, 2996, 2997, 2999, 3002, 3003, 3003, 3004, 3006, 3009, 3010, 3010, 3011, 3013, 3016, 3017, 3017, 3018, 3020, 3023, 3024, 3024, 3025, 3027, 3030, 3031, 3031, 3032, 3034, 3037, 3038, 3038, 3039, 3041, 3044, 3045, 3045, 3046, 3048, 3051, 3052, 3052, 3053, 3055, 3058, 3059, 3059, 3060, 3062, 3065, 3066, 3066, 3067, 3069, 3072, 3073, 3073, 3074, 3076, 3079, 3080, 3080, 3081, 3083, 3086, 3087, 3087, 3088, 3090, 3093, 3094, 3094, 3095, 3097, 3100, 3101, 3101, 3102, 3104, 3107, 3108, 3108, 3109, 3111, 3114, 3115, 3115, 3116, 3118, 3121, 3122, 3122, 3123, 3125, 3128, 3129, 3129, 3130, 3132, 3135, 3136, 3136, 3137, 3139, 3142, 3143, 3143, 3144, 3146, 3149, 3150, 3150, 3151, 3153, 3156, 3157, 3157, 3158, 3160, 3163, 3164, 3164, 3165, 3167, 3170, 3171, 3171, 3172, 3174, 3177, 3178, 3178, 3179, 3181, 3184, 3185, 3185, 3186, 3188, 3191, 3192, 3192, 3193, 3195, 3198, 3199, 3199, 3200, 3202, 3205, 3206, 3206, 3207, 3209, 3212, 3213, 3213, 3214, 3216, 3219, 3220, 3220, 3221, 3223, 3226, 3227, 3227, 3228, 3230, 3233, 3234, 3234, 3235, 3237, 3240, 3241, 3241, 3242, 3244, 3247, 3248, 3248, 3249, 3251, 3254, 3255, 3255, 3256, 3258, 3261, 3262, 3262, 3263, 3265, 3268, 3269, 3269, 3270, 3272, 3275, 3276, 3276, 3277, 3279, 3282, 3283, 3283, 3284, 3286, 3289, 3290, 3290, 3291, 3293, 3296, 3297, 3297, 3298, 3300, 3303, 3304, 3304, 3305, 3307, 3310, 3311, 3311, 3312, 3314, 3317, 3318, 3318, 3319, 3321, 3324, 3325, 3325, 3326, 3328, 3331, 3332, 3332, 3333, 3335, 3338, 3339, 3339, 3340, 3342, 3345, 3346, 3346, 3347, 3349, 3352, 3353, 3353, 3354, 3356, 3359, 3360, 3360, 3361, 3363, 3366, 3367, 3367, 3368, 3370, 3373, 3374, 3374, 3375, 3377, 3380, 3381, 3381, 3382, 3384, 3387, 3388, 3388, 3389, 3391, 3394, 3395, 3395, 3396, 3398, 3401, 3402, 3402, 3403, 3405, 3408, 3409, 3409, 3410, 3412, 3415, 3416, 3416, 3417, 3419, 3422, 3423, 3423, 3424, 3426, 3429, 3430, 3430, 3431, 3433, 3436, 3437, 3437, 3438, 3440, 3443, 3444, 3444, 3445, 3447, 3450, 3451, 3451, 3452, 3454, 3457, 3458, 3458, 3459, 3461, 3464, 3465, 3465, 3466, 3468, 3471, 3472, 3472, 3473, 3475, 3478, 3479, 3479, 3480, 3482, 3485, 3486, 3486, 3487, 3489, 3492, 3493, 3493, 3494, 3496, 3499, 3500, 3500, 3501, 3503, 3506, 3507, 3507, 3508, 3510, 3513, 3514, 3514, 3515, 3517, 3520, 3521, 3521, 3522, 3524, 3527, 3528, 3528, 3529, 3531, 3534, 3535, 3535, 3536, 3538, 3541, 3542, 3542, 3543, 3545, 3548, 3549, 3549, 3550, 3552, 3555, 3556, 3556, 3557, 3559, 3562, 3563, 3563, 3564, 3566, 3569, 3570, 3570, 3571, 3573, 3576, 3577, 3577, 3578, 3580, 3583, 3584, 3584, 3585, 3587, 3590, 3591, 3591, 3592, 3594, 3597, 3598, 3598, 3599, 3601, 3604, 3605, 3605, 3606, 3608, 3611, 3612, 3612, 3613, 3615, 3618, 3619, 3619, 3620, 3622, 3625, 3626, 3626, 3627, 3629, 3632, 3633, 3633, 3634, 3636, 3639, 3640, 3640, 3641, 3643, 3646, 3647, 3647, 3648, 3650, 3653, 3654, 3654, 3655, 3657, 3660, 3661, 3661, 3662, 3664, 3667, 3668, 3668, 3669, 3671, 3674, 3675, 3675, 3676, 3678, 3681, 3682, 3682, 3683, 3685, 3688, 3689, 3689, 3690, 3692, 3695, 3696, 3696, 3697, 3699, 3702, 3703, 3703, 3704, 3706, 3709, 3710, 3710, 3711, 3713, 3716, 3717, 3717, 3718, 3720, 3723, 3724, 3724, 3725, 3727, 3730, 3731, 3731, 3732, 3734, 3737, 3738, 3738, 3739, 3741, 3744, 3745, 3745, 3746, 3748, 3751, 3752, 3752, 3753, 3755, 3758, 3759, 3759, 3760, 3762, 3765, 3766, 3766, 3767, 3769, 3772, 3773, 3773, 3774, 3776, 3779, 3780, 3780, 3781, 3783, 3786, 3787, 3787, 3788, 3790, 3793, 3794, 3794, 3795, 3797, 3800, 3801, 3801, 3802, 3804, 3807, 3808, 3808, 3809, 3811, 3814, 3815, 3815, 3816, 3818, 3821, 3822, 3822, 3823, 3825, 3828, 3829, 3829, 3830, 3832, 3835, 3836, 3836, 3837, 3839, 3842, 3843, 3843, 3844, 3846, 3849, 3850, 3850, 3851, 3853, 3856, 3857, 3857, 3858, 3860, 3863, 3864, 3864, 3865, 3867, 3870, 3871, 3871, 3872, 3874, 3877, 3878, 3878, 3879, 3881, 3884, 3885, 3885, 3886, 3888, 3891, 3892, 3892, 3893, 3895, 3898, 3899, 3899, 3900, 3902, 3905, 3906, 3906, 3907, 3909, 3912, 3913, 3913, 3914, 3916, 3919, 3920, 3920, 3921, 3923, 3926, 3927, 3927, 3928, 3930, 3933, 3934, 3934, 3935, 3937, 3940, 3941, 3941, 3942, 3944, 3947, 3948, 3948, 3949, 3951, 3954, 3955, 3955, 3956, 3958, 3961, 3962, 3962, 3963, 3965, 3968, 3969, 3969, 3970, 3972, 3975, 3976, 3976, 3977, 3979, 3982, 3983, 3983, 3984, 3986, 3989, 3990, 3990, 3991, 3993, 3996, 3997, 3997, 3998, 4000, 4003, 4004, 4004, 4005, 4007, 4010, 4011, 4011, 4012, 4014, 4017, 4018, 4018, 4019, 4021, 4024, 4025, 4025, 4026, 4028, 4031, 4032, 4032, 4033, 4035, 4038, 4039, 4039, 4040, 4042, 4045, 4046, 4046, 4047, 4049, 4052, 4053, 4053, 4054, 4056, 4059, 4060, 4060, 4061, 4063, 4066, 4067, 4067, 4068, 4070, 4073, 4074, 4074, 4075, 4077, 4080, 4081, 4081, 4082, 4084, 4087, 4088, 4088, 4089, 4091, 4094, 4095, 4095, 4096, 4098, 4101, 4102, 4102, 4103, 4105, 4108, 4109, 4109, 4110, 4112, 4115, 4116, 4116, 4117, 4119, 4122, 4123, 4123, 4124, 4126, 4129, 4130, 4130, 4131, 4133, 4136, 4137, 4137, 4138, 4140, 4143, 4144, 4144, 4145, 4147, 4150, 4151, 4151, 4152, 4154, 4157, 4158, 4158, 4159, 4161, 4164, 4165, 4165, 4166, 4168, 4171, 4172, 4172, 4173, 4175, 4178, 4179, 4179, 4180, 4182, 4185, 4186, 4186, 4187, 4189, 4192, 4193, 4193, 4194, 4196, 4199, 4200, 4200, 4201, 4203, 4206, 4207, 4207, 4208, 4210, 4213, 4214, 4214, 4215, 4217, 4220, 4221, 4221, 4222, 4224, 4227, 4228, 4228, 4229, 4231, 4234, 4235, 4235, 4236, 4238, 4241, 4242, 4242, 4243, 4245, 4248, 4249, 4249, 4250, 4252, 4255, 4256, 4256, 4257, 4259, 4262, 4263, 4263, 4264, 4266, 4269, 4270, 4270, 4271, 4273, 4276, 4277, 4277, 4278, 4280, 4283, 4284, 4284, 4285, 4287, 4290, 4291, 4291, 4292, 4294, 4297, 4298, 4298, 4299, 4301, 4304, 4305, 4305, 4306, 4308, 4311, 4312, 4312, 4313, 4315, 4318, 4319, 4319, 4320, 4322, 4325, 4326, 4326, 4327, 4329, 4332, 4333, 4333, 4334, 4336, 4339, 4340, 4340, 4341, 4343, 4346, 4347, 4347, 4348, 4350, 4353, 4354, 4354, 4355, 4357, 4360, 4361, 4361, 4362, 4364, 4367, 4368, 4368, 4369, 4371, 4374, 4375, 4375, 4376, 4378, 4381, 4382, 4382, 4383, 4385, 4388, 4389, 4389, 4390, 4392, 4395, 4396, 4396, 4397, 4399, 4402, 4403, 4403, 4404, 4406, 4409, 4410, 4410, 4411, 4413, 4416, 4417, 4417, 4418, 4420, 4423, 4424, 4424, 4425, 4427, 4430, 4431, 4431, 4432, 4434, 4437, 4438, 4438, 4439, 4441, 4444, 4445, 4445, 4446, 4448, 4451, 4452, 4452, 4453, 4455, 4458, 4459, 4459, 4460, 4462, 4465, 4466, 4466, 4467, 4469, 4472, 4473, 4473, 4474, 4476, 4479, 4480, 4480, 4481, 4483, 4486, 4487, 4487, 4488, 4490, 4493, 4494, 4494, 4495, 4497, 4500, 4501, 4501, 4502, 4504, 4507, 4508, 4508, 4509, 4511, 4514, 4515, 4515, 4516, 4518, 4521, 4522, 4522, 4523, 4525, 4528, 4529, 4529, 4530, 4532, 4535, 4536, 4536, 4537, 4539, 4542, 4543, 4543, 4544, 4546, 4549, 4550, 4550, 4551, 4553, 4556, 4557, 4557, 4558, 4560, 4563, 4564, 4564, 4565, 4567, 4570, 4571, 4571, 4572, 4574, 4577, 4578, 4578, 4579, 4581, 4584, 4585, 4585, 4586, 4588, 4591, 4592, 4592, 4593, 4595, 4598, 4599, 4599, 4600, 4602, 4605, 4606, 4606, 4607, 4609, 4612, 4613, 4613, 4614, 4616, 4619, 4620, 4620, 4621, 4623, 4626, 4627, 4627, 4628, 4630, 4633, 4634, 4634, 4635, 4637, 4640, 4641, 4641, 4642, 4644, 4647, 4648, 4648, 4649, 4651, 4654, 4655, 4655, 4656, 4658, 4661, 4662, 4662, 4663, 4665, 4668, 4669, 4669, 4670, 4672, 4675, 4676, 4676, 4677, 4679, 4682, 4683, 4683, 4684, 4686, 4689, 4690, 4690, 4691, 4693, 4696, 4697, 4697, 4698, 4700, 4703, 4704, 4704, 4705, 4707, 4710, 4711, 4711, 4712, 4714, 4717, 4718, 4718, 4719, 4721, 4724, 4725, 4725, 4726, 4728, 4731, 4732, 4732, 4733, 4735, 4738, 4739, 4739, 4740, 4742, 4745, 4746, 4746, 4747, 4749, 4752, 4753, 4753, 4754, 4756, 4759, 4760, 4760, 4761, 4763, 4766, 4767, 4767, 4768, 4770, 4773, 4774, 4774, 4775, 4777, 4780, 4781, 4781, 4782, 4784, 4787, 4788, 4788, 4789, 4791, 4794, 4795, 4795, 4796, 4798, 4801, 4802, 4802, 4803, 4805, 4808, 4809, 4809, 4810, 4812, 4815, 4816, 4816, 4817, 4819, 4822, 4823, 4823, 4824, 4826, 4829, 4830, 4830, 4831, 4833, 4836, 4837, 4837, 4838, 4840, 4843, 4844, 4844, 4845, 4847, 4850, 4851, 4851, 4852, 4854, 4857, 4858, 4858, 4859, 4861, 4864, 4865, 4865, 4866, 4868, 4871, 4872, 4872, 4873, 4875, 4878, 4879, 4879, 4880, 4882, 4885, 4886, 4886, 4887, 4889, 4892, 4893, 4893, 4894, 4896, 4899, 4900, 4900};const int t2[3510] = {0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 10, 10, 10, 10, 10, 10, 11, 12, 13, 14, 15, 15, 15, 15, 15, 15, 16, 17, 18, 19, 20, 20, 20, 20, 20, 20, 21, 22, 23, 24, 25, 25, 25, 25, 25, 25, 26, 27, 28, 29, 30, 30, 30, 30, 30, 30, 31, 32, 33, 34, 35, 35, 35, 35, 35, 35, 36, 37, 38, 39, 40, 40, 40, 40, 40, 40, 41, 42, 43, 44, 45, 45, 45, 45, 45, 45, 46, 47, 48, 49, 50, 50, 50, 50, 50, 50, 51, 52, 53, 54, 55, 55, 55, 55, 55, 55, 56, 57, 58, 59, 60, 60, 60, 60, 60, 60, 61, 62, 63, 64, 65, 65, 65, 65, 65, 65, 66, 67, 68, 69, 70, 70, 70, 70, 70, 70, 71, 72, 73, 74, 75, 75, 75, 75, 75, 75, 76, 77, 78, 79, 80, 80, 80, 80, 80, 80, 81, 82, 83, 84, 85, 85, 85, 85, 85, 85, 86, 87, 88, 89, 90, 90, 90, 90, 90, 90, 91, 92, 93, 94, 95, 95, 95, 95, 95, 95, 96, 97, 98, 99, 100, 100, 100, 100, 100, 100, 101, 102, 103, 104, 105, 105, 105, 105, 105, 105, 106, 107, 108, 109, 110, 110, 110, 110, 110, 110, 111, 112, 113, 114, 115, 115, 115, 115, 115, 115, 116, 117, 118, 119, 120, 120, 120, 120, 120, 120, 121, 122, 123, 124, 125, 125, 125, 125, 125, 125, 126, 127, 128, 129, 130, 130, 130, 130, 130, 130, 131, 132, 133, 134, 135, 135, 135, 135, 135, 135, 136, 137, 138, 139, 140, 140, 140, 140, 140, 140, 141, 142, 143, 144, 145, 145, 145, 145, 145, 145, 146, 147, 148, 149, 150, 150, 150, 150, 150, 150, 151, 152, 153, 154, 155, 155, 155, 155, 155, 155, 156, 157, 158, 159, 160, 160, 160, 160, 160, 160, 161, 162, 163, 164, 165, 165, 165, 165, 165, 165, 166, 167, 168, 169, 170, 170, 170, 170, 170, 170, 171, 172, 173, 174, 175, 175, 175, 175, 175, 175, 176, 177, 178, 179, 180, 180, 180, 180, 180, 180, 181, 182, 183, 184, 185, 185, 185, 185, 185, 185, 186, 187, 188, 189, 190, 190, 190, 190, 190, 190, 191, 192, 193, 194, 195, 195, 195, 195, 195, 195, 196, 197, 198, 199, 200, 200, 200, 200, 200, 200, 201, 202, 203, 204, 205, 205, 205, 205, 205, 205, 206, 207, 208, 209, 210, 210, 210, 210, 210, 210, 211, 212, 213, 214, 215, 215, 215, 215, 215, 215, 216, 217, 218, 219, 220, 220, 220, 220, 220, 220, 221, 222, 223, 224, 225, 225, 225, 225, 225, 225, 226, 227, 228, 229, 230, 230, 230, 230, 230, 230, 231, 232, 233, 234, 235, 235, 235, 235, 235, 235, 236, 237, 238, 239, 240, 240, 240, 240, 240, 240, 241, 242, 243, 244, 245, 245, 245, 245, 245, 245, 246, 247, 248, 249, 250, 250, 250, 250, 250, 250, 251, 252, 253, 254, 255, 255, 255, 255, 255, 255, 256, 257, 258, 259, 260, 260, 260, 260, 260, 260, 261, 262, 263, 264, 265, 265, 265, 265, 265, 265, 266, 267, 268, 269, 270, 270, 270, 270, 270, 270, 271, 272, 273, 274, 275, 275, 275, 275, 275, 275, 276, 277, 278, 279, 280, 280, 280, 280, 280, 280, 281, 282, 283, 284, 285, 285, 285, 285, 285, 285, 286, 287, 288, 289, 290, 290, 290, 290, 290, 290, 291, 292, 293, 294, 295, 295, 295, 295, 295, 295, 296, 297, 298, 299, 300, 300, 300, 300, 300, 300, 301, 302, 303, 304, 305, 305, 305, 305, 305, 305, 306, 307, 308, 309, 310, 310, 310, 310, 310, 310, 311, 312, 313, 314, 315, 315, 315, 315, 315, 315, 316, 317, 318, 319, 320, 320, 320, 320, 320, 320, 321, 322, 323, 324, 325, 325, 325, 325, 325, 325, 326, 327, 328, 329, 330, 330, 330, 330, 330, 330, 331, 332, 333, 334, 335, 335, 335, 335, 335, 335, 336, 337, 338, 339, 340, 340, 340, 340, 340, 340, 341, 342, 343, 344, 345, 345, 345, 345, 345, 345, 346, 347, 348, 349, 350, 350, 350, 350, 350, 350, 351, 352, 353, 354, 355, 355, 355, 355, 355, 355, 356, 357, 358, 359, 360, 360, 360, 360, 360, 360, 361, 362, 363, 364, 365, 365, 365, 365, 365, 365, 366, 367, 368, 369, 370, 370, 370, 370, 370, 370, 371, 372, 373, 374, 375, 375, 375, 375, 375, 375, 376, 377, 378, 379, 380, 380, 380, 380, 380, 380, 381, 382, 383, 384, 385, 385, 385, 385, 385, 385, 386, 387, 388, 389, 390, 390, 390, 390, 390, 390, 391, 392, 393, 394, 395, 395, 395, 395, 395, 395, 396, 397, 398, 399, 400, 400, 400, 400, 400, 400, 401, 402, 403, 404, 405, 405, 405, 405, 405, 405, 406, 407, 408, 409, 410, 410, 410, 410, 410, 410, 411, 412, 413, 414, 415, 415, 415, 415, 415, 415, 416, 417, 418, 419, 420, 420, 420, 420, 420, 420, 421, 422, 423, 424, 425, 425, 425, 425, 425, 425, 426, 427, 428, 429, 430, 430, 430, 430, 430, 430, 431, 432, 433, 434, 435, 435, 435, 435, 435, 435, 436, 437, 438, 439, 440, 440, 440, 440, 440, 440, 441, 442, 443, 444, 445, 445, 445, 445, 445, 445, 446, 447, 448, 449, 450, 450, 450, 450, 450, 450, 451, 452, 453, 454, 455, 455, 455, 455, 455, 455, 456, 457, 458, 459, 460, 460, 460, 460, 460, 460, 461, 462, 463, 464, 465, 465, 465, 465, 465, 465, 466, 467, 468, 469, 470, 470, 470, 470, 470, 470, 471, 472, 473, 474, 475, 475, 475, 475, 475, 475, 476, 477, 478, 479, 480, 480, 480, 480, 480, 480, 481, 482, 483, 484, 485, 485, 485, 485, 485, 485, 486, 487, 488, 489, 490, 490, 490, 490, 490, 490, 491, 492, 493, 494, 495, 495, 495, 495, 495, 495, 496, 497, 498, 499, 500, 500, 500, 500, 500, 500, 501, 502, 503, 504, 505, 505, 505, 505, 505, 505, 506, 507, 508, 509, 510, 510, 510, 510, 510, 510, 511, 512, 513, 514, 515, 515, 515, 515, 515, 515, 516, 517, 518, 519, 520, 520, 520, 520, 520, 520, 521, 522, 523, 524, 525, 525, 525, 525, 525, 525, 526, 527, 528, 529, 530, 530, 530, 530, 530, 530, 531, 532, 533, 534, 535, 535, 535, 535, 535, 535, 536, 537, 538, 539, 540, 540, 540, 540, 540, 540, 541, 542, 543, 544, 545, 545, 545, 545, 545, 545, 546, 547, 548, 549, 550, 550, 550, 550, 550, 550, 551, 552, 553, 554, 555, 555, 555, 555, 555, 555, 556, 557, 558, 559, 560, 560, 560, 560, 560, 560, 561, 562, 563, 564, 565, 565, 565, 565, 565, 565, 566, 567, 568, 569, 570, 570, 570, 570, 570, 570, 571, 572, 573, 574, 575, 575, 575, 575, 575, 575, 576, 577, 578, 579, 580, 580, 580, 580, 580, 580, 581, 582, 583, 584, 585, 585, 585, 585, 585, 585, 586, 587, 588, 589, 590, 590, 590, 590, 590, 590, 591, 592, 593, 594, 595, 595, 595, 595, 595, 595, 596, 597, 598, 599, 600, 600, 600, 600, 600, 600, 601, 602, 603, 604, 605, 605, 605, 605, 605, 605, 606, 607, 608, 609, 610, 610, 610, 610, 610, 610, 611, 612, 613, 614, 615, 615, 615, 615, 615, 615, 616, 617, 618, 619, 620, 620, 620, 620, 620, 620, 621, 622, 623, 624, 625, 625, 625, 625, 625, 625, 626, 627, 628, 629, 630, 630, 630, 630, 630, 630, 631, 632, 633, 634, 635, 635, 635, 635, 635, 635, 636, 637, 638, 639, 640, 640, 640, 640, 640, 640, 641, 642, 643, 644, 645, 645, 645, 645, 645, 645, 646, 647, 648, 649, 650, 650, 650, 650, 650, 650, 651, 652, 653, 654, 655, 655, 655, 655, 655, 655, 656, 657, 658, 659, 660, 660, 660, 660, 660, 660, 661, 662, 663, 664, 665, 665, 665, 665, 665, 665, 666, 667, 668, 669, 670, 670, 670, 670, 670, 670, 671, 672, 673, 674, 675, 675, 675, 675, 675, 675, 676, 677, 678, 679, 680, 680, 680, 680, 680, 680, 681, 682, 683, 684, 685, 685, 685, 685, 685, 685, 686, 687, 688, 689, 690, 690, 690, 690, 690, 690, 691, 692, 693, 694, 695, 695, 695, 695, 695, 695, 696, 697, 698, 699, 700, 700, 700, 700, 700, 700, 701, 702, 703, 704, 705, 705, 705, 705, 705, 705, 706, 707, 708, 709, 710, 710, 710, 710, 710, 710, 711, 712, 713, 714, 715, 715, 715, 715, 715, 715, 716, 717, 718, 719, 720, 720, 720, 720, 720, 720, 721, 722, 723, 724, 725, 725, 725, 725, 725, 725, 726, 727, 728, 729, 730, 730, 730, 730, 730, 730, 731, 732, 733, 734, 735, 735, 735, 735, 735, 735, 736, 737, 738, 739, 740, 740, 740, 740, 740, 740, 741, 742, 743, 744, 745, 745, 745, 745, 745, 745, 746, 747, 748, 749, 750, 750, 750, 750, 750, 750, 751, 752, 753, 754, 755, 755, 755, 755, 755, 755, 756, 757, 758, 759, 760, 760, 760, 760, 760, 760, 761, 762, 763, 764, 765, 765, 765, 765, 765, 765, 766, 767, 768, 769, 770, 770, 770, 770, 770, 770, 771, 772, 773, 774, 775, 775, 775, 775, 775, 775, 776, 777, 778, 779, 780, 780, 780, 780, 780, 780, 781, 782, 783, 784, 785, 785, 785, 785, 785, 785, 786, 787, 788, 789, 790, 790, 790, 790, 790, 790, 791, 792, 793, 794, 795, 795, 795, 795, 795, 795, 796, 797, 798, 799, 800, 800, 800, 800, 800, 800, 801, 802, 803, 804, 805, 805, 805, 805, 805, 805, 806, 807, 808, 809, 810, 810, 810, 810, 810, 810, 811, 812, 813, 814, 815, 815, 815, 815, 815, 815, 816, 817, 818, 819, 820, 820, 820, 820, 820, 820, 821, 822, 823, 824, 825, 825, 825, 825, 825, 825, 826, 827, 828, 829, 830, 830, 830, 830, 830, 830, 831, 832, 833, 834, 835, 835, 835, 835, 835, 835, 836, 837, 838, 839, 840, 840, 840, 840, 840, 840, 841, 842, 843, 844, 845, 845, 845, 845, 845, 845, 846, 847, 848, 849, 850, 850, 850, 850, 850, 850, 851, 852, 853, 854, 855, 855, 855, 855, 855, 855, 856, 857, 858, 859, 860, 860, 860, 860, 860, 860, 861, 862, 863, 864, 865, 865, 865, 865, 865, 865, 866, 867, 868, 869, 870, 870, 870, 870, 870, 870, 871, 872, 873, 874, 875, 875, 875, 875, 875, 875, 876, 877, 878, 879, 880, 880, 880, 880, 880, 880, 881, 882, 883, 884, 885, 885, 885, 885, 885, 885, 886, 887, 888, 889, 890, 890, 890, 890, 890, 890, 891, 892, 893, 894, 895, 895, 895, 895, 895, 895, 896, 897, 898, 899, 900, 900, 900, 900, 900, 900, 901, 902, 903, 904, 905, 905, 905, 905, 905, 905, 906, 907, 908, 909, 910, 910, 910, 910, 910, 910, 911, 912, 913, 914, 915, 915, 915, 915, 915, 915, 916, 917, 918, 919, 920, 920, 920, 920, 920, 920, 921, 922, 923, 924, 925, 925, 925, 925, 925, 925, 926, 927, 928, 929, 930, 930, 930, 930, 930, 930, 931, 932, 933, 934, 935, 935, 935, 935, 935, 935, 936, 937, 938, 939, 940, 940, 940, 940, 940, 940, 941, 942, 943, 944, 945, 945, 945, 945, 945, 945, 946, 947, 948, 949, 950, 950, 950, 950, 950, 950, 951, 952, 953, 954, 955, 955, 955, 955, 955, 955, 956, 957, 958, 959, 960, 960, 960, 960, 960, 960, 961, 962, 963, 964, 965, 965, 965, 965, 965, 965, 966, 967, 968, 969, 970, 970, 970, 970, 970, 970, 971, 972, 973, 974, 975, 975, 975, 975, 975, 975, 976, 977, 978, 979, 980, 980, 980, 980, 980, 980, 981, 982, 983, 984, 985, 985, 985, 985, 985, 985, 986, 987, 988, 989, 990, 990, 990, 990, 990, 990, 991, 992, 993, 994, 995, 995, 995, 995, 995, 995, 996, 997, 998, 999, 1000, 1000, 1000, 1000, 1000, 1000, 1001, 1002, 1003, 1004, 1005, 1005, 1005, 1005, 1005, 1005, 1006, 1007, 1008, 1009, 1010, 1010, 1010, 1010, 1010, 1010, 1011, 1012, 1013, 1014, 1015, 1015, 1015, 1015, 1015, 1015, 1016, 1017, 1018, 1019, 1020, 1020, 1020, 1020, 1020, 1020, 1021, 1022, 1023, 1024, 1025, 1025, 1025, 1025, 1025, 1025, 1026, 1027, 1028, 1029, 1030, 1030, 1030, 1030, 1030, 1030, 1031, 1032, 1033, 1034, 1035, 1035, 1035, 1035, 1035, 1035, 1036, 1037, 1038, 1039, 1040, 1040, 1040, 1040, 1040, 1040, 1041, 1042, 1043, 1044, 1045, 1045, 1045, 1045, 1045, 1045, 1046, 1047, 1048, 1049, 1050, 1050, 1050, 1050, 1050, 1050, 1051, 1052, 1053, 1054, 1055, 1055, 1055, 1055, 1055, 1055, 1056, 1057, 1058, 1059, 1060, 1060, 1060, 1060, 1060, 1060, 1061, 1062, 1063, 1064, 1065, 1065, 1065, 1065, 1065, 1065, 1066, 1067, 1068, 1069, 1070, 1070, 1070, 1070, 1070, 1070, 1071, 1072, 1073, 1074, 1075, 1075, 1075, 1075, 1075, 1075, 1076, 1077, 1078, 1079, 1080, 1080, 1080, 1080, 1080, 1080, 1081, 1082, 1083, 1084, 1085, 1085, 1085, 1085, 1085, 1085, 1086, 1087, 1088, 1089, 1090, 1090, 1090, 1090, 1090, 1090, 1091, 1092, 1093, 1094, 1095, 1095, 1095, 1095, 1095, 1095, 1096, 1097, 1098, 1099, 1100, 1100, 1100, 1100, 1100, 1100, 1101, 1102, 1103, 1104, 1105, 1105, 1105, 1105, 1105, 1105, 1106, 1107, 1108, 1109, 1110, 1110, 1110, 1110, 1110, 1110, 1111, 1112, 1113, 1114, 1115, 1115, 1115, 1115, 1115, 1115, 1116, 1117, 1118, 1119, 1120, 1120, 1120, 1120, 1120, 1120, 1121, 1122, 1123, 1124, 1125, 1125, 1125, 1125, 1125, 1125, 1126, 1127, 1128, 1129, 1130, 1130, 1130, 1130, 1130, 1130, 1131, 1132, 1133, 1134, 1135, 1135, 1135, 1135, 1135, 1135, 1136, 1137, 1138, 1139, 1140, 1140, 1140, 1140, 1140, 1140, 1141, 1142, 1143, 1144, 1145, 1145, 1145, 1145, 1145, 1145, 1146, 1147, 1148, 1149, 1150, 1150, 1150, 1150, 1150, 1150, 1151, 1152, 1153, 1154, 1155, 1155, 1155, 1155, 1155, 1155, 1156, 1157, 1158, 1159, 1160, 1160, 1160, 1160, 1160, 1160, 1161, 1162, 1163, 1164, 1165, 1165, 1165, 1165, 1165, 1165, 1166, 1167, 1168, 1169, 1170, 1170, 1170, 1170, 1170, 1170, 1171, 1172, 1173, 1174, 1175, 1175, 1175, 1175, 1175, 1175, 1176, 1177, 1178, 1179, 1180, 1180, 1180, 1180, 1180, 1180, 1181, 1182, 1183, 1184, 1185, 1185, 1185, 1185, 1185, 1185, 1186, 1187, 1188, 1189, 1190, 1190, 1190, 1190, 1190, 1190, 1191, 1192, 1193, 1194, 1195, 1195, 1195, 1195, 1195, 1195, 1196, 1197, 1198, 1199, 1200, 1200, 1200, 1200, 1200, 1200, 1201, 1202, 1203, 1204, 1205, 1205, 1205, 1205, 1205, 1205, 1206, 1207, 1208, 1209, 1210, 1210, 1210, 1210, 1210, 1210, 1211, 1212, 1213, 1214, 1215, 1215, 1215, 1215, 1215, 1215, 1216, 1217, 1218, 1219, 1220, 1220, 1220, 1220, 1220, 1220, 1221, 1222, 1223, 1224, 1225, 1225, 1225, 1225, 1225, 1225, 1226, 1227, 1228, 1229, 1230, 1230, 1230, 1230, 1230, 1230, 1231, 1232, 1233, 1234, 1235, 1235, 1235, 1235, 1235, 1235, 1236, 1237, 1238, 1239, 1240, 1240, 1240, 1240, 1240, 1240, 1241, 1242, 1243, 1244, 1245, 1245, 1245, 1245, 1245, 1245, 1246, 1247, 1248, 1249, 1250, 1250, 1250, 1250, 1250, 1250, 1251, 1252, 1253, 1254, 1255, 1255, 1255, 1255, 1255, 1255, 1256, 1257, 1258, 1259, 1260, 1260, 1260, 1260, 1260, 1260, 1261, 1262, 1263, 1264, 1265, 1265, 1265, 1265, 1265, 1265, 1266, 1267, 1268, 1269, 1270, 1270, 1270, 1270, 1270, 1270, 1271, 1272, 1273, 1274, 1275, 1275, 1275, 1275, 1275, 1275, 1276, 1277, 1278, 1279, 1280, 1280, 1280, 1280, 1280, 1280, 1281, 1282, 1283, 1284, 1285, 1285, 1285, 1285, 1285, 1285, 1286, 1287, 1288, 1289, 1290, 1290, 1290, 1290, 1290, 1290, 1291, 1292, 1293, 1294, 1295, 1295, 1295, 1295, 1295, 1295, 1296, 1297, 1298, 1299, 1300, 1300, 1300, 1300, 1300, 1300, 1301, 1302, 1303, 1304, 1305, 1305, 1305, 1305, 1305, 1305, 1306, 1307, 1308, 1309, 1310, 1310, 1310, 1310, 1310, 1310, 1311, 1312, 1313, 1314, 1315, 1315, 1315, 1315, 1315, 1315, 1316, 1317, 1318, 1319, 1320, 1320, 1320, 1320, 1320, 1320, 1321, 1322, 1323, 1324, 1325, 1325, 1325, 1325, 1325, 1325, 1326, 1327, 1328, 1329, 1330, 1330, 1330, 1330, 1330, 1330, 1331, 1332, 1333, 1334, 1335, 1335, 1335, 1335, 1335, 1335, 1336, 1337, 1338, 1339, 1340, 1340, 1340, 1340, 1340, 1340, 1341, 1342, 1343, 1344, 1345, 1345, 1345, 1345, 1345, 1345, 1346, 1347, 1348, 1349, 1350, 1350, 1350, 1350, 1350, 1350, 1351, 1352, 1353, 1354, 1355, 1355, 1355, 1355, 1355, 1355, 1356, 1357, 1358, 1359, 1360, 1360, 1360, 1360, 1360, 1360, 1361, 1362, 1363, 1364, 1365, 1365, 1365, 1365, 1365, 1365, 1366, 1367, 1368, 1369, 1370, 1370, 1370, 1370, 1370, 1370, 1371, 1372, 1373, 1374, 1375, 1375, 1375, 1375, 1375, 1375, 1376, 1377, 1378, 1379, 1380, 1380, 1380, 1380, 1380, 1380, 1381, 1382, 1383, 1384, 1385, 1385, 1385, 1385, 1385, 1385, 1386, 1387, 1388, 1389, 1390, 1390, 1390, 1390, 1390, 1390, 1391, 1392, 1393, 1394, 1395, 1395, 1395, 1395, 1395, 1395, 1396, 1397, 1398, 1399, 1400, 1400, 1400, 1400, 1400, 1400, 1401, 1402, 1403, 1404, 1405, 1405, 1405, 1405, 1405, 1405, 1406, 1407, 1408, 1409, 1410, 1410, 1410, 1410, 1410, 1410, 1411, 1412, 1413, 1414, 1415, 1415, 1415, 1415, 1415, 1415, 1416, 1417, 1418, 1419, 1420, 1420, 1420, 1420, 1420, 1420, 1421, 1422, 1423, 1424, 1425, 1425, 1425, 1425, 1425, 1425, 1426, 1427, 1428, 1429, 1430, 1430, 1430, 1430, 1430, 1430, 1431, 1432, 1433, 1434, 1435, 1435, 1435, 1435, 1435, 1435, 1436, 1437, 1438, 1439, 1440, 1440, 1440, 1440, 1440, 1440, 1441, 1442, 1443, 1444, 1445, 1445, 1445, 1445, 1445, 1445, 1446, 1447, 1448, 1449, 1450, 1450, 1450, 1450, 1450, 1450, 1451, 1452, 1453, 1454, 1455, 1455, 1455, 1455, 1455, 1455, 1456, 1457, 1458, 1459, 1460, 1460, 1460, 1460, 1460, 1460, 1461, 1462, 1463, 1464, 1465, 1465, 1465, 1465, 1465, 1465, 1466, 1467, 1468, 1469, 1470, 1470, 1470, 1470, 1470, 1470, 1471, 1472, 1473, 1474, 1475, 1475, 1475, 1475, 1475, 1475, 1476, 1477, 1478, 1479, 1480, 1480, 1480, 1480, 1480, 1480, 1481, 1482, 1483, 1484, 1485, 1485, 1485, 1485, 1485, 1485, 1486, 1487, 1488, 1489, 1490, 1490, 1490, 1490, 1490, 1490, 1491, 1492, 1493, 1494, 1495, 1495, 1495, 1495, 1495, 1495, 1496, 1497, 1498, 1499, 1500, 1500, 1500, 1500, 1500, 1500, 1501, 1502, 1503, 1504, 1505, 1505, 1505, 1505, 1505, 1505, 1506, 1507, 1508, 1509, 1510, 1510, 1510, 1510, 1510, 1510, 1511, 1512, 1513, 1514, 1515, 1515, 1515, 1515, 1515, 1515, 1516, 1517, 1518, 1519, 1520, 1520, 1520, 1520, 1520, 1520, 1521, 1522, 1523, 1524, 1525, 1525, 1525, 1525, 1525, 1525, 1526, 1527, 1528, 1529, 1530, 1530, 1530, 1530, 1530, 1530, 1531, 1532, 1533, 1534, 1535, 1535, 1535, 1535, 1535, 1535, 1536, 1537, 1538, 1539, 1540, 1540, 1540, 1540, 1540, 1540, 1541, 1542, 1543, 1544, 1545, 1545, 1545, 1545, 1545, 1545, 1546, 1547, 1548, 1549, 1550, 1550, 1550, 1550, 1550, 1550, 1551, 1552, 1553, 1554, 1555, 1555, 1555, 1555, 1555, 1555, 1556, 1557, 1558, 1559, 1560, 1560, 1560, 1560, 1560, 1560, 1561, 1562, 1563, 1564, 1565, 1565, 1565, 1565, 1565, 1565, 1566, 1567, 1568, 1569, 1570, 1570, 1570, 1570, 1570, 1570, 1571, 1572, 1573, 1574, 1575, 1575, 1575, 1575, 1575, 1575, 1576, 1577, 1578, 1579, 1580, 1580, 1580, 1580, 1580, 1580, 1581, 1582, 1583, 1584, 1585, 1585, 1585, 1585, 1585, 1585, 1586, 1587, 1588, 1589, 1590, 1590, 1590, 1590, 1590, 1590, 1591, 1592, 1593, 1594, 1595, 1595, 1595, 1595, 1595, 1595, 1596, 1597, 1598, 1599, 1600, 1600, 1600, 1600, 1600, 1600, 1601, 1602, 1603, 1604, 1605, 1605, 1605, 1605, 1605, 1605, 1606, 1607, 1608, 1609, 1610, 1610, 1610, 1610, 1610, 1610, 1611, 1612, 1613, 1614, 1615, 1615, 1615, 1615, 1615, 1615, 1616, 1617, 1618, 1619, 1620, 1620, 1620, 1620, 1620, 1620, 1621, 1622, 1623, 1624, 1625, 1625, 1625, 1625, 1625, 1625, 1626, 1627, 1628, 1629, 1630, 1630, 1630, 1630, 1630, 1630, 1631, 1632, 1633, 1634, 1635, 1635, 1635, 1635, 1635, 1635, 1636, 1637, 1638, 1639, 1640, 1640, 1640, 1640, 1640, 1640, 1641, 1642, 1643, 1644, 1645, 1645, 1645, 1645, 1645, 1645, 1646, 1647, 1648, 1649, 1650, 1650, 1650, 1650, 1650, 1650, 1651, 1652, 1653, 1654, 1655, 1655, 1655, 1655, 1655, 1655, 1656, 1657, 1658, 1659, 1660, 1660, 1660, 1660, 1660, 1660, 1661, 1662, 1663, 1664, 1665, 1665, 1665, 1665, 1665, 1665, 1666, 1667, 1668, 1669, 1670, 1670, 1670, 1670, 1670, 1670, 1671, 1672, 1673, 1674, 1675, 1675, 1675, 1675, 1675, 1675, 1676, 1677, 1678, 1679, 1680, 1680, 1680, 1680, 1680, 1680, 1681, 1682, 1683, 1684, 1685, 1685, 1685, 1685, 1685, 1685, 1686, 1687, 1688, 1689, 1690, 1690, 1690, 1690, 1690, 1690, 1691, 1692, 1693, 1694, 1695, 1695, 1695, 1695, 1695, 1695, 1696, 1697, 1698, 1699, 1700, 1700, 1700, 1700, 1700, 1700, 1701, 1702, 1703, 1704, 1705, 1705, 1705, 1705, 1705, 1705, 1706, 1707, 1708, 1709, 1710, 1710, 1710, 1710, 1710, 1710, 1711, 1712, 1713, 1714, 1715, 1715, 1715, 1715, 1715, 1715, 1716, 1717, 1718, 1719, 1720, 1720, 1720, 1720, 1720, 1720, 1721, 1722, 1723, 1724, 1725, 1725, 1725, 1725, 1725, 1725, 1726, 1727, 1728, 1729, 1730, 1730, 1730, 1730, 1730, 1730, 1731, 1732, 1733, 1734, 1735, 1735, 1735, 1735, 1735, 1735, 1736, 1737, 1738, 1739, 1740, 1740, 1740, 1740, 1740, 1740, 1741, 1742, 1743, 1744, 1745, 1745, 1745, 1745, 1745, 1745, 1746, 1747, 1748, 1749, 1750, 1750, 1750};const int t3[3510] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 183, 186, 189, 192, 195, 198, 201, 204, 207, 210, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255, 258, 261, 264, 267, 270, 273, 276, 279, 282, 285, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 333, 336, 339, 342, 345, 348, 351, 354, 357, 360, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 375, 375, 375, 375, 375, 375, 375, 375, 375, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 387, 389, 391, 393, 395, 397, 399, 401, 403, 405, 408, 411, 414, 417, 420, 423, 426, 429, 432, 435, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 483, 486, 489, 492, 495, 498, 501, 504, 507, 510, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 525, 525, 525, 525, 525, 525, 525, 525, 525, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 558, 561, 564, 567, 570, 573, 576, 579, 582, 585, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 633, 636, 639, 642, 645, 648, 651, 654, 657, 660, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 675, 675, 675, 675, 675, 675, 675, 675, 675, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 687, 689, 691, 693, 695, 697, 699, 701, 703, 705, 708, 711, 714, 717, 720, 723, 726, 729, 732, 735, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 783, 786, 789, 792, 795, 798, 801, 804, 807, 810, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 825, 825, 825, 825, 825, 825, 825, 825, 825, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 837, 839, 841, 843, 845, 847, 849, 851, 853, 855, 858, 861, 864, 867, 870, 873, 876, 879, 882, 885, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 912, 914, 916, 918, 920, 922, 924, 926, 928, 930, 933, 936, 939, 942, 945, 948, 951, 954, 957, 960, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, 1008, 1011, 1014, 1017, 1020, 1023, 1026, 1029, 1032, 1035, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1062, 1064, 1066, 1068, 1070, 1072, 1074, 1076, 1078, 1080, 1083, 1086, 1089, 1092, 1095, 1098, 1101, 1104, 1107, 1110, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1155, 1158, 1161, 1164, 1167, 1170, 1173, 1176, 1179, 1182, 1185, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1212, 1214, 1216, 1218, 1220, 1222, 1224, 1226, 1228, 1230, 1233, 1236, 1239, 1242, 1245, 1248, 1251, 1254, 1257, 1260, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1308, 1311, 1314, 1317, 1320, 1323, 1326, 1329, 1332, 1335, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1362, 1364, 1366, 1368, 1370, 1372, 1374, 1376, 1378, 1380, 1383, 1386, 1389, 1392, 1395, 1398, 1401, 1404, 1407, 1410, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1425, 1425, 1425, 1425, 1425, 1425, 1425, 1425, 1425, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1437, 1439, 1441, 1443, 1445, 1447, 1449, 1451, 1453, 1455, 1458, 1461, 1464, 1467, 1470, 1473, 1476, 1479, 1482, 1485, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1512, 1514, 1516, 1518, 1520, 1522, 1524, 1526, 1528, 1530, 1533, 1536, 1539, 1542, 1545, 1548, 1551, 1554, 1557, 1560, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1575, 1575, 1575, 1575, 1575, 1575, 1575, 1575, 1575, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1587, 1589, 1591, 1593, 1595, 1597, 1599, 1601, 1603, 1605, 1608, 1611, 1614, 1617, 1620, 1623, 1626, 1629, 1632, 1635, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1662, 1664, 1666, 1668, 1670, 1672, 1674, 1676, 1678, 1680, 1683, 1686, 1689, 1692, 1695, 1698, 1701, 1704, 1707, 1710, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1725, 1725, 1725, 1725, 1725, 1725, 1725, 1725, 1725, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1737, 1739, 1741, 1743, 1745, 1747, 1749, 1751, 1753, 1755, 1758, 1761, 1764, 1767, 1770, 1773, 1776, 1779, 1782, 1785, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1812, 1814, 1816, 1818, 1820, 1822, 1824, 1826, 1828, 1830, 1833, 1836, 1839, 1842, 1845, 1848, 1851, 1854, 1857, 1860, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1887, 1889, 1891, 1893, 1895, 1897, 1899, 1901, 1903, 1905, 1908, 1911, 1914, 1917, 1920, 1923, 1926, 1929, 1932, 1935, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1962, 1964, 1966, 1968, 1970, 1972, 1974, 1976, 1978, 1980, 1983, 1986, 1989, 1992, 1995, 1998, 2001, 2004, 2007, 2010, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2025, 2025, 2025, 2025, 2025, 2025, 2025, 2025, 2025, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2037, 2039, 2041, 2043, 2045, 2047, 2049, 2051, 2053, 2055, 2058, 2061, 2064, 2067, 2070, 2073, 2076, 2079, 2082, 2085, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2112, 2114, 2116, 2118, 2120, 2122, 2124, 2126, 2128, 2130, 2133, 2136, 2139, 2142, 2145, 2148, 2151, 2154, 2157, 2160, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2187, 2189, 2191, 2193, 2195, 2197, 2199, 2201, 2203, 2205, 2208, 2211, 2214, 2217, 2220, 2223, 2226, 2229, 2232, 2235, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2262, 2264, 2266, 2268, 2270, 2272, 2274, 2276, 2278, 2280, 2283, 2286, 2289, 2292, 2295, 2298, 2301, 2304, 2307, 2310, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2325, 2325, 2325, 2325, 2325, 2325, 2325, 2325, 2325, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2337, 2339, 2341, 2343, 2345, 2347, 2349, 2351, 2353, 2355, 2358, 2361, 2364, 2367, 2370, 2373, 2376, 2379, 2382, 2385, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2400, 2400, 2400, 2400, 2400, 2400, 2400, 2400, 2400, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2412, 2414, 2416, 2418, 2420, 2422, 2424, 2426, 2428, 2430, 2433, 2436, 2439, 2442, 2445, 2448, 2451, 2454, 2457, 2460, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2475, 2475, 2475, 2475, 2475, 2475, 2475, 2475, 2475, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2487, 2489, 2491, 2493, 2495, 2497, 2499, 2501, 2503, 2505, 2508, 2511, 2514, 2517, 2520, 2523, 2526, 2529, 2532, 2535, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2562, 2564, 2566, 2568, 2570, 2572, 2574, 2576, 2578, 2580, 2583, 2586, 2589, 2592, 2595, 2598, 2601, 2604, 2607, 2610, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2625, 2625, 2625, 2625, 2625, 2625, 2625, 2625, 2625, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2637, 2639, 2641, 2643, 2645, 2647, 2649, 2651, 2653, 2655, 2658, 2661, 2664, 2667, 2670, 2673, 2676, 2679, 2682, 2685, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2700, 2700, 2700, 2700, 2700, 2700, 2700, 2700, 2700, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2712, 2714, 2716, 2718, 2720, 2722, 2724, 2726, 2728, 2730, 2733, 2736, 2739, 2742, 2745, 2748, 2751, 2754, 2757, 2760, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2775, 2775, 2775, 2775, 2775, 2775, 2775, 2775, 2775, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2787, 2789, 2791, 2793, 2795, 2797, 2799, 2801, 2803, 2805, 2808, 2811, 2814, 2817, 2820, 2823, 2826, 2829, 2832, 2835, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2862, 2864, 2866, 2868, 2870, 2872, 2874, 2876, 2878, 2880, 2883, 2886, 2889, 2892, 2895, 2898, 2901, 2904, 2907, 2910, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2925, 2925, 2925, 2925, 2925, 2925, 2925, 2925, 2925, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2937, 2939, 2941, 2943, 2945, 2947, 2949, 2951, 2953, 2955, 2958, 2961, 2964, 2967, 2970, 2973, 2976, 2979, 2982, 2985, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3012, 3014, 3016, 3018, 3020, 3022, 3024, 3026, 3028, 3030, 3033, 3036, 3039, 3042, 3045, 3048, 3051, 3054, 3057, 3060, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3075, 3075, 3075, 3075, 3075, 3075, 3075, 3075, 3075, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3087, 3089, 3091, 3093, 3095, 3097, 3099, 3101, 3103, 3105, 3108, 3111, 3114, 3117, 3120, 3123, 3126, 3129, 3132, 3135, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3162, 3164, 3166, 3168, 3170, 3172, 3174, 3176, 3178, 3180, 3183, 3186, 3189, 3192, 3195, 3198, 3201, 3204, 3207, 3210, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3237, 3239, 3241, 3243, 3245, 3247, 3249, 3251, 3253, 3255, 3258, 3261, 3264, 3267, 3270, 3273, 3276, 3279, 3282, 3285, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3300, 3300, 3300, 3300, 3300, 3300, 3300, 3300, 3300, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3312, 3314, 3316, 3318, 3320, 3322, 3324, 3326, 3328, 3330, 3333, 3336, 3339, 3342, 3345, 3348, 3351, 3354, 3357, 3360, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3375, 3375, 3375, 3375, 3375, 3375, 3375, 3375, 3375, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3387, 3389, 3391, 3393, 3395, 3397, 3399, 3401, 3403, 3405, 3408, 3411, 3414, 3417, 3420, 3423, 3426, 3429, 3432, 3435, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3462, 3464, 3466, 3468, 3470, 3472, 3474, 3476, 3478, 3480, 3483, 3486, 3489, 3492, 3495, 3498, 3501, 3504, 3507, 3510, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3525, 3525, 3525, 3525, 3525, 3525, 3525, 3525, 3525, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3537, 3539, 3541, 3543, 3545, 3547, 3549, 3551, 3553, 3555, 3558, 3561, 3564, 3567, 3570, 3573, 3576, 3579, 3582, 3585, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3600, 3600, 3600, 3600, 3600, 3600, 3600, 3600, 3600, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3612, 3614, 3616, 3618, 3620, 3622, 3624, 3626, 3628, 3630, 3633, 3636, 3639, 3642, 3645, 3648, 3651, 3654, 3657, 3660, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3675, 3675, 3675, 3675, 3675, 3675, 3675, 3675, 3675, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3687, 3689, 3691, 3693, 3695, 3697, 3699, 3701, 3703, 3705, 3708, 3711, 3714, 3717, 3720, 3723, 3726, 3729, 3732, 3735, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3762, 3764, 3766, 3768, 3770, 3772, 3774, 3776, 3778, 3780, 3783, 3786, 3789, 3792, 3795, 3798, 3801, 3804, 3807, 3810, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3825, 3825, 3825, 3825, 3825, 3825, 3825, 3825, 3825, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3837, 3839, 3841, 3843, 3845, 3847, 3849, 3851, 3853, 3855, 3858, 3861, 3864, 3867, 3870, 3873, 3876, 3879, 3882, 3885, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3900, 3900, 3900, 3900, 3900, 3900, 3900, 3900, 3900, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3912, 3914, 3916, 3918, 3920, 3922, 3924, 3926, 3928, 3930, 3933, 3936, 3939, 3942, 3945, 3948, 3951, 3954, 3957, 3960, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3975, 3975, 3975, 3975, 3975, 3975, 3975, 3975, 3975, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3987, 3989, 3991, 3993, 3995, 3997, 3999, 4001, 4003, 4005, 4008, 4011, 4014, 4017, 4020, 4023, 4026, 4029, 4032, 4035, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4062, 4064, 4066, 4068, 4070, 4072, 4074, 4076, 4078, 4080, 4083, 4086, 4089, 4092, 4095, 4098, 4101, 4104, 4107, 4110, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4125, 4125, 4125, 4125, 4125, 4125, 4125, 4125, 4125, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4137, 4139, 4141, 4143, 4145, 4147, 4149, 4151, 4153, 4155, 4158, 4161, 4164, 4167, 4170, 4173, 4176, 4179, 4182, 4185, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4200, 4200, 4200, 4200, 4200, 4200, 4200, 4200, 4200, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4212, 4214, 4216, 4218, 4220, 4222, 4224, 4226, 4228, 4230, 4233, 4236, 4239, 4242, 4245, 4248, 4251, 4254, 4257, 4260, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4275, 4275, 4275, 4275, 4275, 4275, 4275, 4275, 4275, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4287, 4289, 4291, 4293, 4295, 4297, 4299, 4301, 4303, 4305, 4308, 4311, 4314, 4317, 4320, 4323, 4326, 4329, 4332, 4335, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4350, 4350, 4350, 4350, 4350, 4350, 4350, 4350, 4350, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4362, 4364, 4366, 4368, 4370, 4372, 4374, 4376, 4378, 4380, 4383, 4386, 4389, 4392, 4395, 4398, 4401, 4404, 4407, 4410, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4425, 4425, 4425, 4425, 4425, 4425, 4425, 4425, 4425, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4437, 4439, 4441, 4443, 4445, 4447, 4449, 4451, 4453, 4455, 4458, 4461, 4464, 4467, 4470, 4473, 4476, 4479, 4482, 4485, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4501, 4502, 4503, 4504, 4505, 4506, 4507, 4508, 4509, 4510, 4512, 4514, 4516, 4518, 4520, 4522, 4524, 4526, 4528, 4530, 4533, 4536, 4539, 4542, 4545, 4548, 4551, 4554, 4557, 4560, 4564, 4565, 4566, 4567, 4568, 4569, 4570, 4571, 4572, 4573, 4575, 4575, 4575, 4575, 4575, 4575, 4575, 4575, 4575, 4575, 4576, 4577, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4587, 4589, 4591, 4593, 4595, 4597, 4599, 4601, 4603, 4605, 4608, 4611, 4614, 4617, 4620, 4623, 4626, 4629, 4632, 4635, 4639, 4640, 4641, 4642, 4643, 4644, 4645, 4646, 4647, 4648, 4650, 4650, 4650, 4650, 4650, 4650, 4650, 4650, 4650, 4650, 4651, 4652, 4653, 4654, 4655, 4656, 4657, 4658, 4659, 4660, 4662, 4664, 4666, 4668, 4670, 4672, 4674, 4676, 4678, 4680, 4683, 4686, 4689, 4692, 4695, 4698, 4701, 4704, 4707, 4710, 4714, 4715, 4716, 4717, 4718, 4719, 4720, 4721, 4722, 4723, 4725, 4725, 4725, 4725, 4725, 4725, 4725, 4725, 4725, 4725, 4726, 4727, 4728, 4729, 4730, 4731, 4732, 4733, 4734, 4735, 4737, 4739, 4741, 4743, 4745, 4747, 4749, 4751, 4753, 4755, 4758, 4761, 4764, 4767, 4770, 4773, 4776, 4779, 4782, 4785, 4789, 4790, 4791, 4792, 4793, 4794, 4795, 4796, 4797, 4798, 4800, 4800, 4800, 4800, 4800, 4800, 4800, 4800, 4800, 4800, 4801, 4802, 4803, 4804, 4805, 4806, 4807, 4808, 4809, 4810, 4812, 4814, 4816, 4818, 4820, 4822, 4824, 4826, 4828, 4830, 4833, 4836, 4839, 4842, 4845, 4848, 4851, 4854, 4857, 4860, 4864, 4865, 4866, 4867, 4868, 4869, 4870, 4871, 4872, 4873, 4875, 4875, 4875, 4875, 4875, 4875, 4875, 4875, 4875, 4875, 4876, 4877, 4878, 4879, 4880, 4881, 4882, 4883, 4884, 4885, 4887, 4889, 4891, 4893, 4895, 4897, 4899, 4901, 4903, 4905, 4908, 4911, 4914, 4917, 4920, 4923, 4926, 4929, 4932, 4935, 4939, 4940, 4941, 4942, 4943, 4944, 4945, 4946, 4947, 4948, 4950, 4950, 4950, 4950, 4950, 4950, 4950, 4950, 4950, 4950, 4951, 4952, 4953, 4954, 4955, 4956, 4957, 4958, 4959, 4960, 4962, 4964, 4966, 4968, 4970, 4972, 4974, 4976, 4978, 4980, 4983, 4986, 4989, 4992, 4995, 4998, 5001, 5004, 5007, 5010, 5014, 5015, 5016, 5017, 5018, 5019, 5020, 5021, 5022, 5023, 5025, 5025, 5025, 5025, 5025, 5025, 5025, 5025, 5025, 5025, 5026, 5027, 5028, 5029, 5030, 5031, 5032, 5033, 5034, 5035, 5037, 5039, 5041, 5043, 5045, 5047, 5049, 5051, 5053, 5055, 5058, 5061, 5064, 5067, 5070, 5073, 5076, 5079, 5082, 5085, 5089, 5090, 5091, 5092, 5093, 5094, 5095, 5096, 5097, 5098, 5100, 5100, 5100, 5100, 5100, 5100, 5100, 5100, 5100, 5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108, 5109, 5110, 5112, 5114, 5116, 5118, 5120, 5122, 5124, 5126, 5128, 5130, 5133, 5136, 5139, 5142, 5145, 5148, 5151, 5154, 5157, 5160, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 5171, 5172, 5173, 5175, 5175, 5175, 5175, 5175, 5175, 5175, 5175, 5175, 5175, 5176, 5177, 5178, 5179, 5180, 5181, 5182, 5183, 5184, 5185, 5187, 5189, 5191, 5193, 5195, 5197, 5199, 5201, 5203, 5205, 5208, 5211, 5214, 5217, 5220, 5223, 5226, 5229, 5232, 5235, 5239, 5240, 5241, 5242, 5243, 5244, 5245, 5246, 5247, 5248, 5250, 5250};const int t4[3510] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750};const int t5[3510] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 303, 306, 309, 312, 315, 318, 321, 324, 327, 330, 333, 336, 339, 342, 345, 348, 351, 354, 357, 360, 363, 366, 369, 372, 375, 378, 381, 384, 387, 390, 393, 396, 399, 402, 405, 408, 411, 414, 417, 420, 423, 426, 429, 432, 435, 438, 441, 444, 447, 450, 453, 456, 459, 462, 465, 468, 471, 474, 477, 480, 483, 486, 489, 492, 495, 498, 501, 504, 507, 510, 513, 516, 519, 522, 525, 528, 531, 534, 537, 540, 543, 546, 549, 552, 555, 558, 561, 564, 567, 570, 573, 576, 579, 582, 585, 588, 591, 594, 597, 600, 604, 608, 612, 616, 620, 624, 628, 632, 636, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 852, 854, 856, 858, 860, 862, 864, 866, 868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888, 890, 892, 894, 896, 898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918, 920, 922, 924, 926, 928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948, 950, 952, 954, 956, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 980, 982, 984, 986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034, 1036, 1038, 1040, 1042, 1044, 1046, 1048, 1050, 1053, 1056, 1059, 1062, 1065, 1068, 1071, 1074, 1077, 1080, 1083, 1086, 1089, 1092, 1095, 1098, 1101, 1104, 1107, 1110, 1113, 1116, 1119, 1122, 1125, 1128, 1131, 1134, 1137, 1140, 1143, 1146, 1149, 1152, 1155, 1158, 1161, 1164, 1167, 1170, 1173, 1176, 1179, 1182, 1185, 1188, 1191, 1194, 1197, 1200, 1203, 1206, 1209, 1212, 1215, 1218, 1221, 1224, 1227, 1230, 1233, 1236, 1239, 1242, 1245, 1248, 1251, 1254, 1257, 1260, 1263, 1266, 1269, 1272, 1275, 1278, 1281, 1284, 1287, 1290, 1293, 1296, 1299, 1302, 1305, 1308, 1311, 1314, 1317, 1320, 1323, 1326, 1329, 1332, 1335, 1338, 1341, 1344, 1347, 1350, 1354, 1358, 1362, 1366, 1370, 1374, 1378, 1382, 1386, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1482, 1484, 1486, 1488, 1490, 1492, 1494, 1496, 1498, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1602, 1604, 1606, 1608, 1610, 1612, 1614, 1616, 1618, 1620, 1622, 1624, 1626, 1628, 1630, 1632, 1634, 1636, 1638, 1640, 1642, 1644, 1646, 1648, 1650, 1652, 1654, 1656, 1658, 1660, 1662, 1664, 1666, 1668, 1670, 1672, 1674, 1676, 1678, 1680, 1682, 1684, 1686, 1688, 1690, 1692, 1694, 1696, 1698, 1700, 1702, 1704, 1706, 1708, 1710, 1712, 1714, 1716, 1718, 1720, 1722, 1724, 1726, 1728, 1730, 1732, 1734, 1736, 1738, 1740, 1742, 1744, 1746, 1748, 1750, 1752, 1754, 1756, 1758, 1760, 1762, 1764, 1766, 1768, 1770, 1772, 1774, 1776, 1778, 1780, 1782, 1784, 1786, 1788, 1790, 1792, 1794, 1796, 1798, 1800, 1803, 1806, 1809, 1812, 1815, 1818, 1821, 1824, 1827, 1830, 1833, 1836, 1839, 1842, 1845, 1848, 1851, 1854, 1857, 1860, 1863, 1866, 1869, 1872, 1875, 1878, 1881, 1884, 1887, 1890, 1893, 1896, 1899, 1902, 1905, 1908, 1911, 1914, 1917, 1920, 1923, 1926, 1929, 1932, 1935, 1938, 1941, 1944, 1947, 1950, 1953, 1956, 1959, 1962, 1965, 1968, 1971, 1974, 1977, 1980, 1983, 1986, 1989, 1992, 1995, 1998, 2001, 2004, 2007, 2010, 2013, 2016, 2019, 2022, 2025, 2028, 2031, 2034, 2037, 2040, 2043, 2046, 2049, 2052, 2055, 2058, 2061, 2064, 2067, 2070, 2073, 2076, 2079, 2082, 2085, 2088, 2091, 2094, 2097, 2100, 2104, 2108, 2112, 2116, 2120, 2124, 2128, 2132, 2136, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2232, 2234, 2236, 2238, 2240, 2242, 2244, 2246, 2248, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2352, 2354, 2356, 2358, 2360, 2362, 2364, 2366, 2368, 2370, 2372, 2374, 2376, 2378, 2380, 2382, 2384, 2386, 2388, 2390, 2392, 2394, 2396, 2398, 2400, 2402, 2404, 2406, 2408, 2410, 2412, 2414, 2416, 2418, 2420, 2422, 2424, 2426, 2428, 2430, 2432, 2434, 2436, 2438, 2440, 2442, 2444, 2446, 2448, 2450, 2452, 2454, 2456, 2458, 2460, 2462, 2464, 2466, 2468, 2470, 2472, 2474, 2476, 2478, 2480, 2482, 2484, 2486, 2488, 2490, 2492, 2494, 2496, 2498, 2500, 2502, 2504, 2506, 2508, 2510, 2512, 2514, 2516, 2518, 2520, 2522, 2524, 2526, 2528, 2530, 2532, 2534, 2536, 2538, 2540, 2542, 2544, 2546, 2548, 2550, 2553, 2556, 2559, 2562, 2565, 2568, 2571, 2574, 2577, 2580, 2583, 2586, 2589, 2592, 2595, 2598, 2601, 2604, 2607, 2610, 2613, 2616, 2619, 2622, 2625, 2628, 2631, 2634, 2637, 2640, 2643, 2646, 2649, 2652, 2655, 2658, 2661, 2664, 2667, 2670, 2673, 2676, 2679, 2682, 2685, 2688, 2691, 2694, 2697, 2700, 2703, 2706, 2709, 2712, 2715, 2718, 2721, 2724, 2727, 2730, 2733, 2736, 2739, 2742, 2745, 2748, 2751, 2754, 2757, 2760, 2763, 2766, 2769, 2772, 2775, 2778, 2781, 2784, 2787, 2790, 2793, 2796, 2799, 2802, 2805, 2808, 2811, 2814, 2817, 2820, 2823, 2826, 2829, 2832, 2835, 2838, 2841, 2844, 2847, 2850, 2854, 2858, 2862, 2866, 2870, 2874, 2878, 2882, 2886, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2982, 2984, 2986, 2988, 2990, 2992, 2994, 2996, 2998, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3102, 3104, 3106, 3108, 3110, 3112, 3114, 3116, 3118, 3120, 3122, 3124, 3126, 3128, 3130, 3132, 3134, 3136, 3138, 3140, 3142, 3144, 3146, 3148, 3150, 3152, 3154, 3156, 3158, 3160, 3162, 3164, 3166, 3168, 3170, 3172, 3174, 3176, 3178, 3180, 3182, 3184, 3186, 3188, 3190, 3192, 3194, 3196, 3198, 3200, 3202, 3204, 3206, 3208, 3210, 3212, 3214, 3216, 3218, 3220, 3222, 3224, 3226, 3228, 3230, 3232, 3234, 3236, 3238, 3240, 3242, 3244, 3246, 3248, 3250, 3252, 3254, 3256, 3258, 3260, 3262, 3264, 3266, 3268, 3270, 3272, 3274, 3276, 3278, 3280, 3282, 3284, 3286, 3288, 3290, 3292, 3294, 3296, 3298, 3300, 3303, 3306, 3309, 3312, 3315, 3318, 3321, 3324, 3327, 3330, 3333, 3336, 3339, 3342, 3345, 3348, 3351, 3354, 3357, 3360, 3363, 3366, 3369, 3372, 3375, 3378, 3381, 3384, 3387, 3390, 3393, 3396, 3399, 3402, 3405, 3408, 3411, 3414, 3417, 3420, 3423, 3426, 3429, 3432, 3435, 3438, 3441, 3444, 3447, 3450, 3453, 3456, 3459, 3462, 3465, 3468, 3471, 3474, 3477, 3480, 3483, 3486, 3489, 3492, 3495, 3498, 3501, 3504, 3507, 3510, 3513, 3516, 3519, 3522, 3525, 3528, 3531, 3534, 3537, 3540, 3543, 3546, 3549, 3552, 3555, 3558, 3561, 3564, 3567, 3570, 3573, 3576, 3579, 3582, 3585, 3588, 3591, 3594, 3597, 3600, 3604, 3608, 3612, 3616, 3620, 3624, 3628, 3632, 3636, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3732, 3734, 3736, 3738, 3740, 3742, 3744, 3746, 3748, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3852, 3854, 3856, 3858, 3860, 3862, 3864, 3866, 3868, 3870, 3872, 3874, 3876, 3878, 3880, 3882, 3884, 3886, 3888, 3890, 3892, 3894, 3896, 3898, 3900, 3902, 3904, 3906, 3908, 3910, 3912, 3914, 3916, 3918, 3920, 3922, 3924, 3926, 3928, 3930, 3932, 3934, 3936, 3938, 3940, 3942, 3944, 3946, 3948, 3950, 3952, 3954, 3956, 3958, 3960, 3962, 3964, 3966, 3968, 3970, 3972, 3974, 3976, 3978, 3980, 3982, 3984, 3986, 3988, 3990, 3992, 3994, 3996, 3998, 4000, 4002, 4004, 4006, 4008, 4010, 4012, 4014, 4016, 4018, 4020, 4022, 4024, 4026, 4028, 4030, 4032, 4034, 4036, 4038, 4040, 4042, 4044, 4046, 4048, 4050, 4053, 4056, 4059, 4062, 4065, 4068, 4071, 4074, 4077, 4080, 4083, 4086, 4089, 4092, 4095, 4098, 4101, 4104, 4107, 4110, 4113, 4116, 4119, 4122, 4125, 4128, 4131, 4134, 4137, 4140, 4143, 4146, 4149, 4152, 4155, 4158, 4161, 4164, 4167, 4170, 4173, 4176, 4179, 4182, 4185, 4188, 4191, 4194, 4197, 4200, 4203, 4206, 4209, 4212, 4215, 4218, 4221, 4224, 4227, 4230, 4233, 4236, 4239, 4242, 4245, 4248, 4251, 4254, 4257, 4260, 4263, 4266, 4269, 4272, 4275, 4278, 4281, 4284, 4287, 4290, 4293, 4296, 4299, 4302, 4305, 4308, 4311, 4314, 4317, 4320, 4323, 4326, 4329, 4332, 4335, 4338, 4341, 4344, 4347, 4350, 4354, 4358, 4362, 4366, 4370, 4374, 4378, 4382, 4386, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4482, 4484, 4486, 4488, 4490, 4492, 4494, 4496, 4498, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4501, 4502, 4503, 4504, 4505, 4506, 4507, 4508, 4509, 4510, 4511, 4512, 4513, 4514, 4515, 4516, 4517, 4518, 4519, 4520, 4521, 4522, 4523, 4524, 4525, 4526, 4527, 4528, 4529, 4530, 4531, 4532, 4533, 4534, 4535, 4536, 4537, 4538, 4539, 4540, 4541, 4542, 4543, 4544, 4545, 4546, 4547, 4548, 4549, 4550, 4551, 4552, 4553, 4554, 4555, 4556, 4557, 4558, 4559, 4560, 4561, 4562, 4563, 4564, 4565, 4566, 4567, 4568, 4569, 4570, 4571, 4572, 4573, 4574, 4575, 4576, 4577, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4586, 4587, 4588, 4589, 4590, 4591, 4592, 4593, 4594, 4595, 4596, 4597, 4598, 4599, 4600, 4602, 4604, 4606, 4608, 4610, 4612, 4614, 4616, 4618, 4620, 4622, 4624, 4626, 4628, 4630, 4632, 4634, 4636, 4638, 4640, 4642, 4644, 4646, 4648, 4650, 4652, 4654, 4656, 4658, 4660, 4662, 4664, 4666, 4668, 4670, 4672, 4674, 4676, 4678, 4680, 4682, 4684, 4686, 4688, 4690, 4692, 4694, 4696, 4698, 4700, 4702, 4704, 4706, 4708, 4710, 4712, 4714, 4716, 4718, 4720, 4722, 4724, 4726, 4728, 4730, 4732, 4734, 4736, 4738, 4740, 4742, 4744, 4746, 4748, 4750, 4752, 4754, 4756, 4758, 4760, 4762, 4764, 4766, 4768, 4770, 4772, 4774, 4776, 4778, 4780, 4782, 4784, 4786, 4788, 4790, 4792, 4794, 4796, 4798, 4800, 4803, 4806, 4809, 4812, 4815, 4818, 4821, 4824, 4827, 4830, 4833, 4836, 4839, 4842, 4845, 4848, 4851, 4854, 4857, 4860, 4863, 4866, 4869, 4872, 4875, 4878, 4881, 4884, 4887, 4890, 4893, 4896, 4899, 4902, 4905, 4908, 4911, 4914, 4917, 4920, 4923, 4926, 4929, 4932, 4935, 4938, 4941, 4944, 4947, 4950, 4953, 4956, 4959, 4962, 4965, 4968, 4971, 4974, 4977, 4980, 4983, 4986, 4989, 4992, 4995, 4998, 5001, 5004, 5007, 5010, 5013, 5016, 5019, 5022, 5025, 5028, 5031, 5034, 5037, 5040, 5043, 5046, 5049, 5052, 5055, 5058, 5061, 5064, 5067, 5070, 5073, 5076, 5079, 5082, 5085, 5088, 5091, 5094, 5097, 5100, 5104, 5108, 5112, 5116, 5120, 5124, 5128, 5132, 5136, 5140, 5141, 5142, 5143, 5144, 5145, 5146, 5147, 5148, 5149, 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161, 5162, 5163, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 5171, 5172, 5173, 5174, 5175, 5176, 5177, 5178, 5179, 5180, 5181, 5182, 5183, 5184, 5185, 5186, 5187, 5188, 5189, 5190, 5191, 5192, 5193, 5194, 5195, 5196, 5197, 5198, 5199, 5200, 5201, 5202, 5203, 5204, 5205, 5206, 5207, 5208, 5209, 5210, 5211, 5212, 5213, 5214, 5215, 5216, 5217, 5218, 5219, 5220, 5221, 5222, 5223, 5224, 5225, 5226, 5227, 5228, 5229, 5230, 5232, 5234, 5236, 5238, 5240, 5242, 5244, 5246, 5248, 5250, 5250};const int t6[3510] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601};const int t7[3510] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034, 1036, 1038, 1040, 1042, 1044, 1046, 1048, 1050, 1052, 1054, 1056, 1058, 1060, 1062, 1064, 1066, 1068, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1088, 1090, 1092, 1094, 1096, 1098, 1100, 1102, 1104, 1106, 1108, 1110, 1112, 1114, 1116, 1118, 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1154, 1156, 1158, 1160, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, 1216, 1218, 1220, 1222, 1224, 1226, 1228, 1230, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, 1328, 1330, 1332, 1334, 1336, 1338, 1340, 1342, 1344, 1346, 1348, 1350, 1352, 1354, 1356, 1358, 1360, 1362, 1364, 1366, 1368, 1370, 1372, 1374, 1376, 1378, 1380, 1382, 1384, 1386, 1388, 1390, 1392, 1394, 1396, 1398, 1400, 1402, 1404, 1406, 1408, 1410, 1412, 1414, 1416, 1418, 1420, 1422, 1424, 1426, 1428, 1430, 1432, 1434, 1436, 1438, 1440, 1442, 1444, 1446, 1448, 1450, 1452, 1454, 1456, 1458, 1460, 1462, 1464, 1466, 1468, 1470, 1472, 1474, 1476, 1478, 1480, 1482, 1484, 1486, 1488, 1490, 1492, 1494, 1496, 1498, 1500, 1502, 1504, 1506, 1508, 1510, 1512, 1514, 1516, 1518, 1520, 1522, 1524, 1526, 1528, 1530, 1532, 1534, 1536, 1538, 1540, 1542, 1544, 1546, 1548, 1550, 1552, 1554, 1556, 1558, 1560, 1562, 1564, 1566, 1568, 1570, 1572, 1574, 1576, 1578, 1580, 1582, 1584, 1586, 1588, 1590, 1592, 1594, 1596, 1598, 1600, 1602, 1604, 1606, 1608, 1610, 1612, 1614, 1616, 1618, 1620, 1622, 1624, 1626, 1628, 1630, 1632, 1634, 1636, 1638, 1640, 1642, 1644, 1646, 1648, 1650, 1652, 1654, 1656, 1658, 1660, 1662, 1664, 1666, 1668, 1670, 1672, 1674, 1676, 1678, 1680, 1682, 1684, 1686, 1688, 1690, 1692, 1694, 1696, 1698, 1700, 1702, 1704, 1706, 1708, 1710, 1712, 1714, 1716, 1718, 1720, 1722, 1724, 1726, 1728, 1730, 1732, 1734, 1736, 1738, 1740, 1742, 1744, 1746, 1748, 1750, 1752, 1754, 1756, 1758, 1760, 1762, 1764, 1766, 1768, 1770, 1772, 1774, 1776, 1778, 1780, 1782, 1784, 1786, 1788, 1790, 1792, 1794, 1796, 1798, 1800, 1802, 1804, 1806, 1808, 1810, 1812, 1814, 1816, 1818, 1820, 1822, 1824, 1826, 1828, 1830, 1832, 1834, 1836, 1838, 1840, 1842, 1844, 1846, 1848, 1850, 1852, 1854, 1856, 1858, 1860, 1862, 1864, 1866, 1868, 1870, 1872, 1874, 1876, 1878, 1880, 1882, 1884, 1886, 1888, 1890, 1892, 1894, 1896, 1898, 1900, 1902, 1904, 1906, 1908, 1910, 1912, 1914, 1916, 1918, 1920, 1922, 1924, 1926, 1928, 1930, 1932, 1934, 1936, 1938, 1940, 1942, 1944, 1946, 1948, 1950, 1952, 1954, 1956, 1958, 1960, 1962, 1964, 1966, 1968, 1970, 1972, 1974, 1976, 1978, 1980, 1982, 1984, 1986, 1988, 1990, 1992, 1994, 1996, 1998, 2000, 2002, 2004, 2006, 2008, 2010, 2012, 2014, 2016, 2018, 2020, 2022, 2024, 2026, 2028, 2030, 2032, 2034, 2036, 2038, 2040, 2042, 2044, 2046, 2048, 2050, 2052, 2054, 2056, 2058, 2060, 2062, 2064, 2066, 2068, 2070, 2072, 2074, 2076, 2078, 2080, 2082, 2084, 2086, 2088, 2090, 2092, 2094, 2096, 2098, 2100, 2102, 2104, 2106, 2108, 2110, 2112, 2114, 2116, 2118, 2120, 2122, 2124, 2126, 2128, 2130, 2132, 2134, 2136, 2138, 2140, 2142, 2144, 2146, 2148, 2150, 2152, 2154, 2156, 2158, 2160, 2162, 2164, 2166, 2168, 2170, 2172, 2174, 2176, 2178, 2180, 2182, 2184, 2186, 2188, 2190, 2192, 2194, 2196, 2198, 2200, 2202, 2204, 2206, 2208, 2210, 2212, 2214, 2216, 2218, 2220, 2222, 2224, 2226, 2228, 2230, 2232, 2234, 2236, 2238, 2240, 2242, 2244, 2246, 2248, 2250, 2252, 2254, 2256, 2258, 2260, 2262, 2264, 2266, 2268, 2270, 2272, 2274, 2276, 2278, 2280, 2282, 2284, 2286, 2288, 2290, 2292, 2294, 2296, 2298, 2300, 2302, 2304, 2306, 2308, 2310, 2312, 2314, 2316, 2318, 2320, 2322, 2324, 2326, 2328, 2330, 2332, 2334, 2336, 2338, 2340, 2342, 2344, 2346, 2348, 2350, 2352, 2354, 2356, 2358, 2360, 2362, 2364, 2366, 2368, 2370, 2372, 2374, 2376, 2378, 2380, 2382, 2384, 2386, 2388, 2390, 2392, 2394, 2396, 2398, 2400, 2402, 2404, 2406, 2408, 2410, 2412, 2414, 2416, 2418, 2420, 2422, 2424, 2426, 2428, 2430, 2432, 2434, 2436, 2438, 2440, 2442, 2444, 2446, 2448, 2450, 2452, 2454, 2456, 2458, 2460, 2462, 2464, 2466, 2468, 2470, 2472, 2474, 2476, 2478, 2480, 2482, 2484, 2486, 2488, 2490, 2492, 2494, 2496, 2498, 2500, 2502, 2504, 2506, 2508, 2510, 2512, 2514, 2516, 2518, 2520, 2522, 2524, 2526, 2528, 2530, 2532, 2534, 2536, 2538, 2540, 2542, 2544, 2546, 2548, 2550, 2552, 2554, 2556, 2558, 2560, 2562, 2564, 2566, 2568, 2570, 2572, 2574, 2576, 2578, 2580, 2582, 2584, 2586, 2588, 2590, 2592, 2594, 2596, 2598, 2600, 2602, 2604, 2606, 2608, 2610, 2612, 2614, 2616, 2618, 2620, 2622, 2624, 2626, 2628, 2630, 2632, 2634, 2636, 2638, 2640, 2642, 2644, 2646, 2648, 2650, 2652, 2654, 2656, 2658, 2660, 2662, 2664, 2666, 2668, 2670, 2672, 2674, 2676, 2678, 2680, 2682, 2684, 2686, 2688, 2690, 2692, 2694, 2696, 2698, 2700, 2702, 2704, 2706, 2708, 2710, 2712, 2714, 2716, 2718, 2720, 2722, 2724, 2726, 2728, 2730, 2732, 2734, 2736, 2738, 2740, 2742, 2744, 2746, 2748, 2750, 2752, 2754, 2756, 2758, 2760, 2762, 2764, 2766, 2768, 2770, 2772, 2774, 2776, 2778, 2780, 2782, 2784, 2786, 2788, 2790, 2792, 2794, 2796, 2798, 2800, 2802, 2804, 2806, 2808, 2810, 2812, 2814, 2816, 2818, 2820, 2822, 2824, 2826, 2828, 2830, 2832, 2834, 2836, 2838, 2840, 2842, 2844, 2846, 2848, 2850, 2852, 2854, 2856, 2858, 2860, 2862, 2864, 2866, 2868, 2870, 2872, 2874, 2876, 2878, 2880, 2882, 2884, 2886, 2888, 2890, 2892, 2894, 2896, 2898, 2900, 2902, 2904, 2906, 2908, 2910, 2912, 2914, 2916, 2918, 2920, 2922, 2924, 2926, 2928, 2930, 2932, 2934, 2936, 2938, 2940, 2942, 2944, 2946, 2948, 2950, 2952, 2954, 2956, 2958, 2960, 2962, 2964, 2966, 2968, 2970, 2972, 2974, 2976, 2978, 2980, 2982, 2984, 2986, 2988, 2990, 2992, 2994, 2996, 2998, 3000, 3003, 3006, 3009, 3012, 3015, 3018, 3021, 3024, 3027, 3030, 3033, 3036, 3039, 3042, 3045, 3048, 3051, 3054, 3057, 3060, 3063, 3066, 3069, 3072, 3075, 3078, 3081, 3084, 3087, 3090, 3093, 3096, 3099, 3102, 3105, 3108, 3111, 3114, 3117, 3120, 3123, 3126, 3129, 3132, 3135, 3138, 3141, 3144, 3147, 3150, 3153, 3156, 3159, 3162, 3165, 3168, 3171, 3174, 3177, 3180, 3183, 3186, 3189, 3192, 3195, 3198, 3201, 3204, 3207, 3210, 3213, 3216, 3219, 3222, 3225, 3228, 3231, 3234, 3237, 3240, 3243, 3246, 3249, 3252, 3255, 3258, 3261, 3264, 3267, 3270, 3273, 3276, 3279, 3282, 3285, 3288, 3291, 3294, 3297, 3300, 3303, 3306, 3309, 3312, 3315, 3318, 3321, 3324, 3327, 3330, 3333, 3336, 3339, 3342, 3345, 3348, 3351, 3354, 3357, 3360, 3363, 3366, 3369, 3372, 3375, 3378, 3381, 3384, 3387, 3390, 3393, 3396, 3399, 3402, 3405, 3408, 3411, 3414, 3417, 3420, 3423, 3426, 3429, 3432, 3435, 3438, 3441, 3444, 3447, 3450, 3453, 3456, 3459, 3462, 3465, 3468, 3471, 3474, 3477, 3480, 3483, 3486, 3489, 3492, 3495, 3498, 3501, 3504, 3507, 3510, 3513, 3516, 3519, 3522, 3525, 3528, 3531, 3534, 3537, 3540, 3543, 3546, 3549, 3552, 3555, 3558, 3561, 3564, 3567, 3570, 3573, 3576, 3579, 3582, 3585, 3588, 3591, 3594, 3597, 3600, 3603, 3606, 3609, 3612, 3615, 3618, 3621, 3624, 3627, 3630, 3633, 3636, 3639, 3642, 3645, 3648, 3651, 3654, 3657, 3660, 3663, 3666, 3669, 3672, 3675, 3678, 3681, 3684, 3687, 3690, 3693, 3696, 3699, 3702, 3705, 3708, 3711, 3714, 3717, 3720, 3723, 3726, 3729, 3732, 3735, 3738, 3741, 3744, 3747, 3750, 3753, 3756, 3759, 3762, 3765, 3768, 3771, 3774, 3777, 3780, 3783, 3786, 3789, 3792, 3795, 3798, 3801, 3804, 3807, 3810, 3813, 3816, 3819, 3822, 3825, 3828, 3831, 3834, 3837, 3840, 3843, 3846, 3849, 3852, 3855, 3858, 3861, 3864, 3867, 3870, 3873, 3876, 3879, 3882, 3885, 3888, 3891, 3894, 3897, 3900, 3903, 3906, 3909, 3912, 3915, 3918, 3921, 3924, 3927, 3930, 3933, 3936, 3939, 3942, 3945, 3948, 3951, 3954, 3957, 3960, 3963, 3966, 3969, 3972, 3975, 3978, 3981, 3984, 3987, 3990, 3993, 3996, 3999, 4002, 4005, 4008, 4011, 4014, 4017, 4020, 4023, 4026, 4029, 4032, 4035, 4038, 4041, 4044, 4047, 4050, 4053, 4056, 4059, 4062, 4065, 4068, 4071, 4074, 4077, 4080, 4083, 4086, 4089, 4092, 4095, 4098, 4101, 4104, 4107, 4110, 4113, 4116, 4119, 4122, 4125, 4128, 4131, 4134, 4137, 4140, 4143, 4146, 4149, 4152, 4155, 4158, 4161, 4164, 4167, 4170, 4173, 4176, 4179, 4182, 4185, 4188, 4191, 4194, 4197, 4200, 4203, 4206, 4209, 4212, 4215, 4218, 4221, 4224, 4227, 4230, 4233, 4236, 4239, 4242, 4245, 4248, 4251, 4254, 4257, 4260, 4263, 4266, 4269, 4272, 4275, 4278, 4281, 4284, 4287, 4290, 4293, 4296, 4299, 4302, 4305, 4308, 4311, 4314, 4317, 4320, 4323, 4326, 4329, 4332, 4335, 4338, 4341, 4344, 4347, 4350, 4353, 4356, 4359, 4362, 4365, 4368, 4371, 4374, 4377, 4380, 4383, 4386, 4389, 4392, 4395, 4398, 4401, 4404, 4407, 4410, 4413, 4416, 4419, 4422, 4425, 4428, 4431, 4434, 4437, 4440, 4443, 4446, 4449, 4452, 4455, 4458, 4461, 4464, 4467, 4470, 4473, 4476, 4479, 4482, 4485, 4488, 4491, 4494, 4497, 4500, 4503, 4506, 4509, 4512, 4515, 4518, 4521, 4524, 4527, 4530, 4533, 4536, 4539, 4542, 4545, 4548, 4551, 4554, 4557, 4560, 4563, 4566, 4569, 4572, 4575, 4578, 4581, 4584, 4587, 4590, 4593, 4596, 4599, 4602, 4605, 4608, 4611, 4614, 4617, 4620, 4623, 4626, 4629, 4632, 4635, 4638, 4641, 4644, 4647, 4650, 4653, 4656, 4659, 4662, 4665, 4668, 4671, 4674, 4677, 4680, 4683, 4686, 4689, 4692, 4695, 4698, 4701, 4704, 4707, 4710, 4713, 4716, 4719, 4722, 4725, 4728, 4731, 4734, 4737, 4740, 4743, 4746, 4749, 4752, 4755, 4758, 4761, 4764, 4767, 4770, 4773, 4776, 4779, 4782, 4785, 4788, 4791, 4794, 4797, 4800, 4803};const char table[10] = {0, 'I', 'V', 'X', 'L', 'C', 'D', 'M'};int n;int main () { scanf (&quot;%d&quot;, &amp;n); if (t1[n] != 0) { printf (&quot;%c %d\\n&quot;, table[1], t1[n]); } if (t2[n] != 0) { printf (&quot;%c %d\\n&quot;, table[2], t2[n]); } if (t3[n] != 0) { printf (&quot;%c %d\\n&quot;, table[3], t3[n]); } if (t4[n] != 0) { printf (&quot;%c %d\\n&quot;, table[4], t4[n]); } if (t5[n] != 0) { printf (&quot;%c %d\\n&quot;, table[5], t5[n]); } if (t6[n] != 0) { printf (&quot;%c %d\\n&quot;, table[6], t6[n]); } if (t7[n] != 0) { printf (&quot;%c %d\\n&quot;, table[7], t7[n]); } return 0;} T2 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXLEN = 2e5 + 5;int n, len;char a[MAXLEN], b[MAXLEN];bool check (int l1, int r1, int l2, int r2) { bool flag = 1; for (int i = l1, j = l2; i &lt;= r1 &amp;&amp; j &lt;= r2; i++, j++) { if (a[i] != b[j]) { flag = 0; break; } } if (flag == 1) { return 1; } if ((r1 - l1 + 1) % 2 == 1) { return 0; } int mid = ((r1 - l1) + 1) &gt;&gt; 1; return ((check (l1, l1 + mid - 1, l2, l2 + mid - 1) &amp;&amp; check (r1 - mid + 1, r1, r2 - mid + 1, r2)) || (check (l1, l1 + mid - 1, r2 - mid + 1, r2) &amp;&amp; check (r1 - mid + 1, r1, l2, l2 + mid - 1)));}int main () { freopen (&quot;string.in&quot;, &quot;r&quot;, stdin); freopen (&quot;string.out&quot;, &quot;w&quot;, stdout); scanf (&quot;%d&quot;, &amp;n); while (n--) { scanf (&quot;%s&quot;, a + 1); scanf (&quot;%s&quot;, b + 1); len = strlen (a + 1); if (check (1, len, 1, len)) { printf (&quot;YES\\n&quot;); } else printf (&quot;NO\\n&quot;); } return 0;} T3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 1e5 + 5;int n, ans, tmp;struct node { int l, r;} a[MAXN];bool cmp(node x, node y) { return (x.l == y.l) ? x.r &lt; y.r : x.l &lt; y.l; }int Max(int x, int y) { return (x &gt; y) ? x : y; }int Min(int x, int y) { return (x &lt; y) ? x : y; }int Tot(int x) { return (x &lt; 0) ? 0 : x; }int sl[MAXN], sr[MAXN], tl[MAXN], tr[MAXN];signed main() { // freopen (&quot;homework.in&quot;, &quot;r&quot;, stdin); // freopen (&quot;homework.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%lld&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld %lld&quot;, &amp;a[i].l, &amp;a[i].r); } sort(a + 1, a + 1 + n, cmp); memset(sl, 0, sizeof(sl)); memset(sr, 0x3f, sizeof(sr)); memset(tl, 0, sizeof(tl)); memset(tr, 0x3f, sizeof(tr)); for (int i = 1; i &lt;= n; i++) { sl[i] = Max(sl[i - 1], a[i].l); sr[i] = Min(sr[i - 1], a[i].r); } for (int i = n; i &gt;= 1; i--) { tl[i] = Max(tl[i + 1], a[i].l); tr[i] = Min(tr[i + 1], a[i].r); } sl[0] = tl[n + 1] = 0; sr[0] = tr[n + 1] = -1; for (int i = 0; i &lt;= n; i++) { tmp = Tot(sr[i] - sl[i] + 1) + Tot(tr[i + 1] - tl[i + 1] + 1); ans = Max(ans, tmp); } for (int i = 1; i &lt;= n; i++) { ans = Max(ans, a[i].r - a[i].l + 1 + Tot (Min (sr[i - 1], tr[i + 1]) - Max (sl[i - 1], tl[i + 1]) + 1)); } printf(&quot;%lld\\n&quot;, ans); return 0;} T4 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 5;int n, dp[30][3], ans;char s[MAXN];int Max (int x, int y) { return (x &gt; y) ? x : y;}int main () { scanf (&quot;%d&quot;, &amp;n); scanf (&quot;%s&quot;, s + 1); for (int i = 0; i &lt; 26; i++) { for (int j = 0; j &lt; 26; j++) { dp[j][0] = 0xcfcfcfcf; dp[j][1] = 0; } for (int pos = 1; pos &lt;= n; pos++) { if (s[pos] == i + 'a') { for (int j = 0; j &lt; 26; j++) { dp[j][0]++, dp[j][1]++; ans = Max (ans, dp[j][0]); } } else { int j = s[pos] - 'a'; dp[j][0] = dp[j][1] - 1; dp[j][1] = Max (0, dp[j][1] - 1); ans = Max (ans, dp[j][0]); } } } printf (&quot;%d\\n&quot;, ans); return 0;}","link":"/2021/06/19/2021-06-19-%E5%88%9D%E4%BA%8C20210619%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95%20%E6%80%BB%E7%BB%93/"},{"title":"「Solution」中国好代码","text":"考试时真就是写了个《中国好代码》呗。。。 link 分析其实就是道一眼题。可以发现，如果要写同余方程的话，每个学生的第一次转身时间是余数，转身周期是模数。那么问题可以转化为:给定$n$个模方程(下标从$1$到$n$)，支持两种操作： 交换$i,j$两个方程。 查询$[l,r]$的方程组成方程组后是否有解。根据刚学的扩展中国剩余定理的思路可以知道：我们能在$nlog$的时间复杂度里合并$n$个方程为一个。并满足区间可合并性。那么既然求区间内有无解，并且可以等价的合并，那么我们用线段树维护即可，每个节点维护一段区间内合并后的方程的模数与余数。然后就做完了。 代码考试时真就是写了个《中国好代码》。。。开始在push_up里面写了个ExCRT，后来发现查询时不那么方便，又写了个merge用来合并方程，发现丢线段树节点到merge里面不那么舒服，又开了个结构体装方程，然后merge里的ExCRT写错了，把r1(特解)写成了r2(当前方程的余数)。。。有趣的是我写了两个ExCRT，第一个没错，第二个马上就挂了(早知道我就直接复制第一遍)。然后代码很冗长。写完就不想看了，跑去看了会第一题，结果考完发现写炸了。。。混乱代码给我留下了深深的伤痛。。。我应该好好学习如何把代码写好看精简代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 1e5 + 5;int t, n, q, tg[5];struct node { int m, r; int flag;} a[MAXN];struct SegmentTree { int m, ri, flag; int l, r;} s[MAXN * 4];int gcd(int x, int y) { if (y == 0) return x; else return gcd(y, x % y);}void exgcd(int&amp; x, int&amp; y, int a, int b) { if (b == 0) { x = 1, y = 0; return; } exgcd(x, y, b, a % b); int t = x; x = y, y = t - a / b * y; return;}void push_up(int p) { if (s[p &lt;&lt; 1].flag == -1 || s[p &lt;&lt; 1 | 1].flag == -1) { s[p].flag = s[p].m = s[p].ri = -1; return; } int m1 = s[p &lt;&lt; 1].m, r1 = s[p &lt;&lt; 1].ri; int m2 = s[p &lt;&lt; 1 | 1].m, r2 = s[p &lt;&lt; 1 | 1].ri; int g = gcd(m1, m2); int tmp = r2 - r1; if (tmp % g != 0) { s[p].flag = s[p].m = s[p].ri = -1; return; } int k1, k2; exgcd(k1, k2, m1 / g, m2 / g); k1 = (tmp / g * k1) % (m2 / g); r1 += k1 * m1; m1 = m1 / g * m2; r1 = (r1 + m1) % m1; s[p].flag = 1, s[p].m = m1, s[p].ri = r1;}node merge(node x, node y) { node res; res.flag = 1; if (x.flag == -1 || y.flag == -1) { res.flag = res.m = res.r = -1; return res; } int m1 = x.m, r1 = x.r; int m2 = y.m, r2 = y.r; int g = gcd(m1, m2); int tmp = r2 - r1; if (tmp % g != 0) { res.flag = res.m = res.r = -1; return res; } int k1, k2; exgcd(k1, k2, m1 / g, m2 / g); k1 = (tmp / g * k1) % (m2 / g); r1 += k1 * m1; m1 = m1 / g * m2; r1 = (r1 + m1) % m1; res.m = m1, res.r = r1, res.flag = 1; //此处的r1写成了r2... return res;}void build(int p, int l, int r) { s[p].l = l, s[p].r = r; if (l == r) { s[p].flag = 1; s[p].m = a[l].m, s[p].ri = a[l].r; return; } int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid); build(p &lt;&lt; 1 | 1, mid + 1, r); push_up(p);}void update(int p, int x, int l, int r, node val) { if (s[p].l == s[p].r) { s[p].m = val.m, s[p].ri = val.r; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (x &lt;= mid) { update(p &lt;&lt; 1, x, l, r, val); } else update(p &lt;&lt; 1 | 1, x, l, r, val); push_up(p);}node query(int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) { node res; res.flag = 1; if (s[p].flag == -1) { res.flag = res.m = res.r = -1; return res; } else { res.m = s[p].m, res.r = s[p].ri; return res; } } int mid = (s[p].l + s[p].r) &gt;&gt; 1; node res; res.flag = 1; if (l &lt;= mid) { res = query(p &lt;&lt; 1, l, r); if (r &gt; mid) { res = merge(res, query(p &lt;&lt; 1 | 1, l, r)); } return res; } else if (r &gt; mid) { res = query(p &lt;&lt; 1 | 1, l, r); return res; }}signed main() { // freopen (&quot;goodcode.in&quot;, &quot;r&quot;, stdin); // freopen (&quot;goodcode.out&quot;, &quot;w&quot;, stdout); scanf (&quot;%lld&quot;, &amp;t); while (t--) { scanf (&quot;%lld %lld&quot;, &amp;n, &amp;q); for (int i = 1; i &lt;= 3; i++) { scanf (&quot;%lld&quot;, &amp;tg[i]); } for (int i = 1, g; i &lt;= n; i++) { scanf (&quot;%lld %lld&quot;, &amp;a[i].r, &amp;g); a[i].m = tg[g]; } build(1, 1, n); while (q--) { int op, l, r; scanf (&quot;%lld %lld %lld&quot;, &amp;op, &amp;l, &amp;r); if (op == 0) { update(1, l, 1, n, a[r]); update(1, r, 1, n, a[l]); swap(a[r], a[l]); } else { node res = query(1, l, r); if (res.flag == -1) { printf(&quot;No\\n&quot;); } else { printf(&quot;Yes\\n&quot;); } } } } return 0;}","link":"/2021/08/25/2021-08-25-%E4%B8%AD%E5%9B%BD%E5%A5%BD%E4%BB%A3%E7%A0%81%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」AtCoder[abc177]Code","text":"AtCoder[abc177]练习后留档 2021/1/6 A1234567891011121314151617#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int doubleusing namespace std;int d, t, s, tt;signed main() { scanf(&quot;%lf %lf %lf&quot;, &amp;d, &amp;t, &amp;s); tt = d / s; if (tt &lt;= t) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); return 0;} B注意有坑，下标不要整出边界了。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1005 + 50;char a[MAXN], b[MAXN];int lena, lenb, ans;int Summary(int id) { int sum = 0; for (int i = 1; i &lt;= lenb; i++) { if (b[i] != a[i + id - 1]) sum++; } return sum;}int main() { scanf(&quot;%s&quot;, a + 1); scanf(&quot;%s&quot;, b + 1); lena = strlen(a + 1); lenb = strlen(b + 1); ans = 0x3f3f3f3f; for (int i = 1; i &lt;= lena - lenb + 1; i++) { ans = min(ans, Summary(i)); } printf(&quot;%d\\n&quot;, ans); return 0;} C给出一个数组，数组元素两两求积，再对积求和，输出该和值。利用前缀和。 有点像小学奥数里的分组比赛问题。 1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int mod = 1e9 + 7;const int MAXN = 4 * 1e5 + 5;int a[MAXN], n;int sum[MAXN], ans;signed main() { scanf(&quot;%lld&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a[i]); sum[i] = (sum[i - 1] % mod + a[i] % mod) % mod; } for (int i = 1; i &lt;= n; i++) { ans = (ans % mod + (a[i] % mod * sum[i - 1] % mod) % mod) % mod; } printf(&quot;%lld\\n&quot;, ans % mod); return 0;} D并查集板题，加一个$rank$值即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 4 * 1e5 + 5;int n, m, ans;struct node { int rank, f;} fa[MAXN];void MakeSet(int n) { for (int i = 1; i &lt;= n; i++) { fa[i].f = i; fa[i].rank = 1; }}int FindSet(int v) { if (fa[v].f == v) return v; else return fa[v].f = FindSet(fa[v].f);}void UnionSet(int u, int v) { int x = FindSet(u); int y = FindSet(v); if (x == y) return; fa[x].f = fa[y].f; fa[y].rank += fa[x].rank; return;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); MakeSet(n); for (int i = 1, u, v; i &lt;= m; i++) { scanf(&quot;%d %d&quot;, &amp;u, &amp;v); UnionSet(u, v); } for (int i = 1; i &lt;= n; i++) { ans = max(ans, fa[FindSet(i)].rank); } printf(&quot;%d\\n&quot;, ans); return 0;} E此题一开始我的做法是错的。但是数据良心地给了我$80pts$。判断最大公约数是否是1，可以用$gcd$直接跑。但判断两两互质有点麻烦。如果暴力的话一定会超时，可以考虑含根号的算法，即$\\sqrt{n}n$。那么将每个数都进行质因数分解，如果一个因子被记录超过1次，则可以判断了。细节有点多，还有特判。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int SIZE = 2 * 1e6 + 5;const int MAXN = 1e6;int n, a[SIZE], pre[SIZE], cnt, Gcd, tot[MAXN];int vis[SIZE];bool flag1;bool cmp(int x, int y) { return x &lt; y; }int gcd(int x, int y) { if (y == 0) return x; else return gcd(y, x % y);}void change(int x) { for (int i = 2; i &lt;= sqrt(x); i++) { if (x % i == 0) { tot[i]++; if (tot[i] != 1) { printf(&quot;setwise coprime\\n&quot;); exit(0); } while (x % i == 0) x /= i; } } if (x != 1) { tot[x]++; if (tot[x] != 1) { printf(&quot;setwise coprime\\n&quot;); exit(0); } }}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); if (a[i] != 1) { flag1 = 1; } if (i == 1) Gcd = a[i]; else Gcd = gcd(a[i], Gcd); } if (flag1 == 0) { printf(&quot;pairwise coprime\\n&quot;); return 0; } if (Gcd != 1) { printf(&quot;not coprime\\n&quot;); } else { sort(a + 1, a + 1 + n, cmp); for (int i = 1; i &lt;= n; i++) { if (a[i] == 1) continue; change(a[i]); } printf(&quot;pairwise coprime\\n&quot;); } return 0;}","link":"/2021/01/16/2021-1-16-AtCoder%5Babc177%5DCode/"},{"title":"「Note」欧拉反演","text":"求$\\sum_{i=1}^n\\gcd(i,n)$$$\\sum_{d|n}\\varphi(d) = n\\\\rightarrow \\sum_{i=1}^n\\gcd(i,n) = \\sum_{i=1}^n\\sum_{d|\\gcd(i,n)}\\varphi(d)\\$$ $$=\\sum_{i=1}^n\\sum_{d|i}\\sum_{d|n} \\varphi(d) \\$$ $$=\\sum_{d|n}\\sum_{i=1}^n\\sum_{d|i} \\varphi(d) \\$$ $$=\\sum_{d|n}\\frac{n}{d}\\varphi(d)$$ 然后可以直接整除分块。","link":"/2021/08/24/2021-08-24-%E6%AC%A7%E6%8B%89%E5%8F%8D%E6%BC%94/"},{"title":"「Solution」「JOISC 2016 Day 3」回转寿司","text":"人生第二道黑题分块好题 [link](#2736. 「JOISC 2016 Day 3」回转寿司 - 题目 - LibreOJ (loj.ac)) Solution不难看出，在遍历完区间之后，若该区间有数大于$A$，那么$A$将进入该区间，并弹出区间内最大的数。 这里用到一个结论，序列操作的顺序不会改变数列中数字的最终集合。 先咕了。 给一个证明： 设有两个操作：$(l_1,r_1,A_1)$和$(l_2,r_2,A_2)$并假定$A_1&gt;A_2$。 当$[l_1,r_1] \\bigcup [l_2,r_2] = \\varnothing$时，两个操作一定不会影响 当$[l_1,r_1] \\bigcup [l_2,r_2] \\neq \\varnothing$时，若先操作$(l_1,r_1,A_1)$，设弹出了$A^{‘}$，若$A^{‘}&gt;A_2$，那么 咕咕咕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 4e5 + 5;const int MAXLOG = 650;int n, m, siz, cnt, block[MAXN], a[MAXN];priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; now[MAXLOG];priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; his[MAXLOG];void reset(int id) { for (int i = (id - 1) * siz + 1; i &lt;= id * siz; i++) { his[id].push(a[i]); a[i] = his[id].top(); his[id].pop(); } while (his[id].size()) his[id].pop();}void update(int id) { while (now[id].size()) { now[id].pop(); } for (int i = (id - 1) * siz + 1; i &lt;= id * siz; i++) { now[id].push(a[i]); }}int feces(int l, int r, int val) { reset(block[l]); for (int i = l; i &lt;= min(block[l] * siz, r); i++) { if (a[i] &gt; val) swap(a[i], val); } for (int i = block[l] + 1; i &lt; block[r]; i++) { his[i].push(val); now[i].push(val); val = now[i].top(); now[i].pop(); } update(block[l]); if (block[l] != block[r]) { reset(block[r]); for (int i = (block[r] - 1) * siz + 1; i &lt;= r; i++) { if (a[i] &gt; val) swap(a[i], val); } update(block[r]); } return val;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); siz = sqrt(n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;a[i]); block[i] = (i - 1) / siz + 1; now[block[i]].push(a[i]); } for (int t = 1, l, r, val; t &lt;= m; t++) { scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;val); if (l &gt; r) { printf(&quot;%d\\n&quot;, feces(1, r, feces(l, n, val))); } else printf(&quot;%d\\n&quot;, feces(l, r, val)); } return 0;}","link":"/2021/10/05/2021-10-05-%E3%80%8CJOISC%202016%20Day%203%E3%80%8D%E5%9B%9E%E8%BD%AC%E5%AF%BF%E5%8F%B8%20%E9%A2%98%E8%A7%A3/"},{"title":"「Summary」半期复习","text":"我本来想躺平的 老老实实复习吧 平衡树Fhq_Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;int n, root, tot, tmp1, tmp2, tmp3;struct Treap { int l, r, key, val, siz;} s[MAXN];int newnode(int val) { s[++tot].val = val, s[tot].key = rand(), s[tot].siz = 1; return tot;}void push_up(int p) { s[p].siz = s[s[p].l].siz + s[s[p].r].siz + 1;}void split(int p, int val, int&amp; x, int&amp; y) { if (p == 0) { x = y = 0; return; } if (s[p].val &lt;= val) { x = p, split(s[p].r, val, s[p].r, y); } else { y = p, split(s[p].l, val, x, s[p].l); } push_up(p);}int merge(int x, int y) { if (!x || !y) return x + y; if (s[x].key &gt; s[y].key) { s[x].r = merge(s[x].r, y); push_up(x); return x; } else { s[y].l = merge(x, s[y].l); push_up(y); return y; }}void insert(int val) { split(root, val, tmp1, tmp2); root = merge(merge(tmp1, newnode(val)), tmp2);}void remove(int val) { split(root, val, tmp1, tmp2); split(tmp1, val - 1, tmp1, tmp3); tmp3 = merge(s[tmp3].l, s[tmp3].r); root = merge(merge(tmp1, tmp3), tmp2);}int queryrnk(int val) { split(root, val - 1, tmp1, tmp2); int res = s[tmp1].siz + 1; root = merge(tmp1, tmp2); return res;}int querykth(int p, int k) { while (p) { if (s[s[p].l].siz + 1 == k) { return s[p].val; } if (s[s[p].l].siz &gt;= k) { p = s[p].l; continue; } k -= s[s[p].l].siz + 1, p = s[p].r; }}int querypre(int val) { split(root, val - 1, tmp1, tmp2); int res = querykth(tmp1, s[tmp1].siz); root = merge(tmp1, tmp2); return res;}int querynxt(int val) { split(root, val, tmp1, tmp2); int res = querykth(tmp2, 1); root = merge(tmp1, tmp2); return res;}int main() { // freopen(&quot;D:\\\\Math\\\\tmp.in&quot;, &quot;r&quot;, stdin); srand(time(0)); scanf(&quot;%d&quot;, &amp;n); while (n--) { int opt, val; scanf(&quot;%d %d&quot;, &amp;opt, &amp;val); if (opt == 1) { insert(val); } else if (opt == 2) { remove(val); } else if (opt == 3) { printf(&quot;%d\\n&quot;, queryrnk(val)); } else if (opt == 4) { printf(&quot;%d\\n&quot;, querykth(root, val)); } else if (opt == 5) { printf(&quot;%d\\n&quot;, querypre(val)); } else { printf(&quot;%d\\n&quot;, querynxt(val)); } } return 0;} 高斯消元核心思想忘了 step1依次扫描当前列的每一行，找到主元(当前列系数最大的) step2将找到的主元所在的行和当前行交换。开始消元，即，从后往前扫后面的每一行，用对应变元的系数去除主元，最后把主元的系数化为一，再去对后面的每一位依次做减法消元。 估计时没说清楚的，但是我自己懂了。。。 最后有个回带的过程，其实整体方法和手算没什么区别。 如果有多解，一定有某个元的系数是$0$.在代码里体现就是消元的操作没有做够$n$次。 时间复杂度$n^3$. 运用范围当遇到了概率期望题目的方程式会产生含有 当前$dp$值的转移方程时，形如$\\mathrm{dp_i} = a\\times \\mathrm{dp_i} + \\dots$并且每个状态前的系数可以确定这时可以预处理出每个状态前的系数。然后代入用高斯消元求解就行了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e2 + 5;const double EPS = 1e-18;int n;double a[MAXN][MAXN];void Gauss() { int r, c; for (c = 1, r = 1; c &lt;= n; c++) { int maxl = r; for (int i = r; i &lt;= n; i++) if (fabs(a[i][c]) &gt; fabs(a[maxl][c])) { maxl = i; } if (fabs(a[maxl][c]) &lt; EPS) continue; for (int i = c; i &lt;= n + 1; i++) swap(a[r][i], a[maxl][i]); for (int i = n + 1; i &gt;= c; i--) a[r][i] /= a[r][c]; for (int i = r; i &lt;= n; i++) { for (int j = c; j &lt;= n + 1; j++) { a[i][j] -= a[r][j] * a[i][c]; } } r++; } if (r &lt;= n) { // 因为 r 是从 1 开始，所以如果全部消完了， r 的终值应该是 n + 1 printf(&quot;No Solution\\n&quot;); exit(0); } for (int i = n; i &gt;= 1; i--) { for (int j = i + 1; j &lt;= n; j++) { a[i][n + 1] -= a[j][n + 1] * a[i][j]; } }}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n + 1; j++) { scanf(&quot;%lf&quot;, &amp;a[i][j]); } } Gauss(); for (int i = 1; i &lt;= n; i++) { printf(&quot;%.2lf\\n&quot;, a[i][n + 1]); } return 0;}","link":"/2021/11/05/2021-11-05-%E5%8D%8A%E6%9C%9F%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"},{"title":"「Solution」Gauss消元题目合集","text":"All in one. First Knight设$dp[i][j]$为从$(i, j)$为起点走到终点$(n, m)$的代价。 $dp[i][j] = dp[i + 1][j] \\times p[i + 1][j][1] + dp[i][j + 1] \\times p[i][j + 1][2] \\ + dp[i - 1][j] \\times p[i - 1][j][3] \\ + dp[i][j - 1] \\times p[i][j - 1][4] + 1$ 移项后为$-dp[i][j] \\ + dp[i + 1][j] \\times p[i + 1][j][1]\\ + dp[i][j + 1] \\times p[i][j + 1][2] \\+ dp[i - 1][j] \\times p[i - 1][j][3] \\+ dp[i][j - 1] \\times p[i][j - 1][4] = -1$ 可以高斯消元。 然后用带状优化到$N \\times N \\times 2 \\times m$ Time travel设$dp[i]$表示从$i$为起点到终点走过路程的期望长度。 $dp[i]=1+\\sum_{j=1}^{m} dp[vis[i][j]]\\times P[|i-j|]$ $\\rightarrow -dp[i] +\\sum_{j=1}^{m} dp[vis[i][j]]\\times P[|i-j|] = -1$ $dp[t] = 0$ 对于$dp[s]$只能从规定方向转移。 然后可以带状优化。 比较难写，弃了 Museum$dp[i][j]$表示当前Petya在$i$,Vasya 在$j$的概率。 $$dp[i][j] = dp[i][j] \\times P[i] \\times P[j] \\ + \\sum_{(x,i) \\in G}\\sum_{(y,j) \\in G} \\frac{dp[x][y] \\times (1 - P[x]) \\times (1 - P[y])}{deg[x] \\times deg[y]} + \\ \\sum_{(x, i)\\in G}\\frac{dp[x][j]\\times(1-p[x])\\times p[j]}{deg[x]} + \\sum_{(y, i)\\in G}\\frac{dp[i][y]\\times(1-p[y])\\times p[i]}{deg[y]}$$常数项为$0$$$dp[i][j] \\times (P[i] \\times P[j] - 1) \\+\\sum_{(x,i) \\in G}\\sum_{(y,j) \\in G} \\frac{dp[x][y] \\times (1 - P[x]) \\times (1 - P[y])}{deg[x] \\times deg[y]} + \\ \\sum_{(x, i)\\in G}\\frac{dp[x][j]\\times(1-p[x])\\times p[j]}{deg[x]} + \\sum_{(y, i)\\in G}\\frac{dp[i][y]\\times(1-p[y])\\times p[i]}{deg[y]} = 0$$ 初始值$dp[s_1][s_2] = 1$ 不论经过这两个点多少次，它的概率都是1，因为这个是必然事件。 暴力解方程是$\\Theta(N^3) = \\Theta(113379904)$ 时限$2s$可过。 Rating显然可以把数据范围缩小到$[1,20]$。 $(0, 0) \\rightarrow (0,1) \\rightarrow (1,1) \\rightarrow (1,2) \\rightarrow (2,2)$ 考虑当前的一个状态$(x,y) | y\\leq x$$dp[x][y] = dp[x][y + 2] \\times (1-p) + dp[x][y - 1] \\times p + 1$$\\rightarrow dp[x][y]-dp[x][y+2]\\times (1 - p) - dp[x][y - 1] \\times p = 1$ 游走如果把边权看做已知条件。 设$dp[u]$表示从$u$为初始节点，走到$n$结束的期望值。 $dp[u] = val(u, v) + \\frac{1}{deg[u]} \\sum_{(v,u)\\in G} dp[v]$ $-dp[u] + val(u, v) + \\frac{1}{deg[u]} \\sum_{(v,u)\\in G} dp[v] = 0$ 瓶颈在于给每条边赋权。 如果把边权挪到点上？ 如果考虑点的话断然是行不通的。 那么设$dp[(u,v)]$表示从$(u,v)$这条边出发，走到$n$结束的期望值。 $dp[(u,v)] = val(u,v) + \\frac{1}{deg[u]}\\sum_{(x, u)\\in G}dp[x] + \\frac{1}{deg[v]}\\sum_{(y, v) \\in G}dp[y]$ 不行。 根据上面式子，最后的贡献与每边的边权和经过的概率有关。 贪心一下，经过次数越多的边的边权应该赋得越大。 那么要找出每条边贡献的次数。 即是经过的次数。 在这道题中，概率就等同于期望。 求出每条边的概率即可。 复杂度不对？ 然后找到经过每个点的概率就好了。 边$(u, v)$的概率就是$P[u]\\times \\frac{1}{deg[u]} + P[v] \\times \\frac{1}{deg[v]}$ 然后排序，从大到小依次赋值。 $-dp[u] + \\frac{1}{deg[u]} \\sum_{(v,u)\\in G} dp[v] = 0$ 边界注意$dp[1] = dp[n] = 1$ 高斯消元可以解决。","link":"/2021/10/16/2021-10-16-Gauss%E6%B6%88%E5%85%83%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"},{"title":"「Note」二项式定理与组合恒等式","text":"二项式定理定理$1$: $(x+y)^n=\\sum_{k=0}^n(^n_k)x^ky^{n - k}$ 证明$1$:$$当n=1时,公式显然成立.假设公式对于n成立\\(x+y)^{n+1} = (x + y)^n \\times (x+y)\\=(x+y) \\times \\sum_{k=0}^n \\dbinom {n}{k} x^ky^{n - k}\\=x\\sum_{k=0}^n \\dbinom {n}{k} x^ky^{n - k} + y\\sum_{k=0}^n \\dbinom {n}{k} x^ky^{n - k}\\=\\sum_{k=0}^n \\dbinom {n}{k} x^{k + 1}y^{n - k} + \\sum_{k=0}^n \\dbinom {n}{k} x^ky^{n - k + 1}\\=\\sum_{k=1}^{n+1} \\dbinom {n}{k} x^ky^{n - k + 1} + \\sum_{k=0}^n \\dbinom {n}{k} x^ky^{n - k + 1}\\=\\sum_{k=1}^n \\dbinom {n}{k} x^ky^{n - k+1} + x^{n+1}+y^{n+1} \\=\\sum_{k=0}^{n + 1} \\dbinom {n}{k} x^ky^{n+ 1 - k} \\即公式对n+1成立$$ 组合恒等式定理$1$: $\\dbinom{n}{k}=\\dbinom{n}{n-k}$ **证明$1$:**从组合意义证明，$\\dbinom{n}{k}$表示从$n$个物品中留下$k$个的方案数，$\\dbinom{n}{n - k}$表示从$n$个物品中拿走$n-k$个的方案数，两者是等价的。 定理$2$:$\\dbinom{n}{k}=\\frac{n}{k}\\dbinom{n-1}{k-1}$ **证明$2$:**可以用公式法。$\\dbinom{n}{k}=\\frac{n!}{k!(n-k)!}=\\frac{n}{k}\\times \\frac{(n - 1)!}{(k-1)![(n - 1) - (k - 1)]!} = \\frac{n}{k}\\dbinom{n-1}{k-1}$ 定理$3$:$\\dbinom{n}{k}=\\dbinom{n - 1}{k} + \\dbinom{n - 1}{k - 1}$ **证明$3$:**从组合意义证明，$\\dbinom{n}{k}$表示从$n$个物品中选$k$个的方案数，考虑当前的物品，有选它与不选两种情况，如果选它，就等价于从$n - 1$个物品中选$k - 1$的方案数$\\dbinom{n - 1}{k}$；如果不选，就等价于从$n - 1$个物品中选$k$个的方案数$\\dbinom{n - 1}{k - 1}$，相加即是总方案数。 定理$4$: $\\sum_{k = 0} ^ {n} \\dbinom{n}{k} = 2^n$ **证明$4$:**从组合意义证明，$\\sum_{k = 0} ^ {n} \\dbinom{n}{k}$表示从$n$个物品中任意选任意个的方案数，考虑每个物品，有选与不选两种情况，一共就有$2^n$种方案数。 定理$5$: $\\sum_{k = 0} ^ {n} (-1) ^k \\dbinom{n}{k} = 0$ **证明$5$:**因为$\\dbinom{n}{k}=\\dbinom{n}{n-k}$,且$$\\dbinom{n}{k}$$ 和$\\dbinom{n}{n-k}$必定反号，所以等于$0$. 定理$6$:$\\sum_{k = 0} ^ {n} k \\dbinom{n}{k} = n 2 ^ {n - 1}$ **证明$6$:**因为$\\dbinom{n}{k}=\\frac{n}{k}\\dbinom{n-1}{k-1}$，$\\sum_{k = 0} ^ {n} k \\dbinom{n}{k} = \\sum_0^n n \\dbinom{n - 1}{k - 1}=n\\sum_0^n\\dbinom{n - 1}{k - 1} = n2^{n - 1}$ 定理$7$:$\\sum_{l=0}^n\\dbinom{l}{k} = \\dbinom{n + 1}{k + 1} n, k \\in \\mathrm{N}$ **证明$7$:**从组合意义证明，依次考虑每个元素$A_i$是否包含在集合$\\mathrm{S}|\\mathrm{S} \\in \\mathrm{A},|\\mathrm{S}|=k+1$中,含$A_1$，方案数为$\\dbinom{n}{k}$,不含$A_1$,含$A_2$,方案数为$\\dbinom{n - 1}{k}$,$\\dots$,不含$A_1, A_2, \\dots, A_{n}$,含$A_{n+1}$，方案数为$\\dbinom{0}{k}$。转换为变下项求和。","link":"/2021/11/13/2021-11-13-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86%E4%B8%8E%E7%BB%84%E5%90%88%E6%81%92%E7%AD%89%E5%BC%8F/"},{"title":"「Solution」二项式相关数学题","text":"1. $(3x-2y)^{18}$的展开式中，$x^5y^{13}$系数是什么？$x^8y^9$ 的系数是什么？ $x^5y^{13}$是第$6$项，系数是$\\dbinom{18}{6} \\times 3^{5} \\times 2^{5}$ $x^8y^9$是第$9$项，系数是$\\dbinom{18}{9} \\times 3^{8} \\times 2 ^ {9}$ **2.**用二项式定理证明：$3^n=\\sum\\limits_{k=0}^n2^k$,扩展此结果，对任意实数$r$ 求和 $\\sum\\limits_{k=0}^nr^k$ $3^{n} = (2 + 1) ^ n = \\sum_{k = 0} ^ n \\dbinom{n}{k} 2 ^ {k} \\times 1 ^ {n - k} = \\sum\\limits_{k=0}^n2^k$ 扩展：$\\sum_{k = 0} ^ n r ^k = (r + 1) ^ n$ **3.**用二项式定理证明：$2^n=\\sum\\limits_{k=0}^n(-1)^k\\dbinom{n}{k}3^{n-k}$ $2 ^ n = (3 - 1) ^ n = (3 + (-1)) ^ n = \\sum_{k = 0} ^ n \\dbinom{n}{k} \\times 3 ^ {n - k} \\times (-1) ^ k = \\sum_{k = 0} ^ n(-1) ^ k \\dbinom{n}{k} 3 ^ {n - k}$ **4.**求和：$\\sum\\limits_{k=0}^n(-1)^k\\dbinom{n}{k}10^k$ $\\sum_{k = 0} ^ n (-1) ^ k \\dbinom{n}{k} 10 ^ k = (-10 + 1) ^ n = (-9) ^ n$ **5.**使用组合分析的方法证明：$\\dbinom{n}{k} - \\dbinom{n-3}{k} = \\dbinom{n-1}{k-1}+\\dbinom{n-2}{k-1}+ \\dbinom{n-3}{k-1}$ $\\dbinom{n}{k}$ 表示前$n$个选择$k$个的方案数，$\\dbinom{n - 3}{k}$表示前$n - 3$个选择$k$个的方案数，相减就表示至少在$[n - 2, n]$中选择了一个的方案数，相当于依次枚举在前$[n - 3, n - 1]$个中只选择$k - 1$个方案数的和。 **6.**设 $n$ 是正整数，证明：$\\sum\\limits_{k=0}^n(-1)^k\\dbinom{n}{k}^2 = \\begin{cases} 0，若n是奇数\\ (-1)^m\\dbinom{2m}{m}， 若n=2m\\end{cases}$ 当$n$为奇数时，前后可以抵消。 当$n$为偶数时，$???$ **7.**求出等于下列表达式的二项式系数：$\\dbinom{n}{k} = 3\\dbinom{n}{k-1}+3\\dbinom{n}{k-2}+\\dbinom{n}{k-3}$ **8.**证明：$\\dbinom{r}{k}=\\frac{r}{r-k}\\dbinom{r-1}{k}$,其中$r$为实数，$k$是实数且 $r \\neq k$ $\\dbinom{r}{k} = \\frac{r}{k} \\dbinom{r - 1}{k - 1} = \\frac{r}{k} \\times \\frac{(r - 1)!}{(k - 1)!(r- k)!} = \\frac{r}{r-k} \\times \\dfrac{(r - 1)!}{k!(r-1-k)!} = \\dfrac{r(r-1)!}{k!(r - k)!} = \\frac{r}{r - k} \\dbinom{r - 1}{k}$ **9.**求和：$1-\\frac{1}{2}\\dbinom{n}{1}+\\frac{1}{3}\\dbinom{n}{2}-\\frac{1}{4}\\dbinom{n}{3}+…+(-1)^n\\frac{1}{n+1}\\dbinom{n}{n}$ $$1-\\frac{1}{2}\\dbinom{n}{1}+\\frac{1}{3}\\dbinom{n}{2}-\\frac{1}{4}\\dbinom{n}{3}+…+(-1)^n\\frac{1}{n+1}\\dbinom{n}{n} \\=1 - \\dfrac{1 \\times n!}{2 \\times 1! \\times (n - 1)!} + \\dfrac{1 \\times n!}{3 \\times 2! \\times (n - 2)!} - \\dfrac{1\\times n!}{4\\times 3! \\times(n - 3)}! + \\dots + (-1) ^ n \\dfrac{1 \\times n!}{(n + 1) \\times n! \\times (n - n)!}\\= \\dfrac{\\sum_{k=0}^{n} (-1) ^ k \\dbinom{n+1}{k+1}}{n + 1}\\= \\dfrac{1}{n+1}$$ **10.**证明：$\\dbinom{n+1}{k+1}=\\dbinom{0}{k}+\\dbinom{1}{k}+…+\\dbinom{n-1}{k}+\\dbinom{n}{k} 以及m^2=2\\dbinom{m}{2}+\\dbinom{m}{1}$ 从组合意义证明，左式表示从$a_1,a_2,a_3,\\dots a_{n + 1}$中选出$k + 1$个元素的方案数。 那么对于$\\dbinom{i}{k}$表示不选前$n - i - 1$个元素，但一定选择第$i$元素，那么就只能从剩下的$i$个元素中再选出$k$个。 从组合意义证明，左式表示从$m$个元素中选出两个元素(可相同)组成有序坐标数，右式表示从$m$个元素中选出两个元素(可相同)组成有序坐标数与横纵坐标相同的坐标数。两式显然相等。 **11.**求整数 $a$、$b$和$c$，使得对所有的$m$有：$m^3 = a\\dbinom{m}{3}+b\\dbinom{m}{2}+c\\dbinom{m}{1}$ 即是 $a = 6, b = 6, c = 1$","link":"/2021/11/15/2021-11-15-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E7%9B%B8%E5%85%B3%E6%95%B0%E5%AD%A6%E9%A2%98/"},{"title":"「Solution」Devu and Flowers","text":"居然调了半天的组合数？ Devu and Flowerslink 分析看到$n$很小，第一反应是要状压。 如果直接求解不太舒服，考虑求补集。 在不考虑个数的限制下的总方案数是$\\dbinom{n+m-1}{n-1}$。 考虑选择一个种类的花不合法，设为$S_i$。 $Ans = \\dbinom{n + m - 1}{n - 1} - \\sum_\\limits{i = 1}^n S_i + \\sum_\\limits{i,j \\in n} (S_i \\cup S_j) - \\dits$ $S_i = \\dbinom{n+m-1-a_i-1}{n-1}$ $S_i \\cup S_j = \\dbinom{n + m - 1 - a_i - 1 - a_j - 1}{n - 1}$ 结果问题是看到数据范围后求不来组合数了，想了要到一个小时怎么对$1e12$范围里的数求组合数。。。 其实用$\\dbinom{n}{k} = \\dbinom{n}{n - k}$就行了。 可以看到式子中即使暴力算只会循环不到$20$次。。。 然后到处都要取模。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 25;const int Mod = 1000000007;LL n, m, a[MAXN], inv[MAXN], ans;LL qpow(LL x, LL y) { LL res = 1; while (y) { if (y &amp; 1) res = res * x % Mod; x = x * x % Mod; y &gt;&gt;= 1; } return res;}LL C(LL x, LL y) { if (y &gt; x) return 0; y = x - y; LL res = 1ll; for (LL i = y + 1ll; i &lt;= x; i++) { res = (res * (i % Mod)) % Mod; } for (int i = 1ll; i &lt;= x - y; i++) { res = res * inv[i] % Mod; } return res;}int main() { inv[0] = 1; for (int i = 1; i &lt;= 20; i++) { inv[i] = qpow(i, Mod - 2); } scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;a[i]); } for (int i = 0, sta = 1, cnt = 0; i &lt; (1 &lt;&lt; n); i++, sta = 1, cnt = 0) { LL tot = 0; for (int j = 1; j &lt;= n; j++) if ((1 &lt;&lt; j - 1) &amp; i) { cnt++; tot += a[j] + 1; } if (cnt &amp; 1) sta = -1; ans = (ans + sta * C(n + m - 1 - tot, n - 1) % Mod + Mod) % Mod; // printf(&quot;%d %lld %lld\\n&quot;, cnt, ans, sta * C(n + m - 1 - tot, n - 1)); } printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/2021/11/18/2021-11-18-Devu%20and%20Flowers%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」A Simple Chess","text":"可能就只有我会把$i,j$写反吧。。。 A Simple Chesslink 分析首先对于每个读进来的坐标从左上到右下排序。 总方案数是明确的，考虑不合法的方案数。 因为给定的棋子走的方式比较奇怪，先考虑如何计算出某两个点之间的到达的方案数。假设两个点之间的横距离为$a$，纵距离为$b$，并且走了$x$步**右$2$下$1$的操作，走了$y$步右$1$下$2$**的操作。可以列出方程$\\begin {cases} 2x + y = a \\ 2y + x = b \\end {cases}$$\\rightarrow \\begin {cases} x = \\frac{2a-b}{3} \\ y = \\frac{2b-a}{3} \\end {cases}$如果$x,y \\notin \\mathbb{Z}$表示方案数为$0$，直接返回即可。如果满足要求则方案数为$\\dbinom{x+y}{x}$ 对于每个点$(x_i, y_i)$，考虑从起点到它且不经过其他点的方案数是$dp_i$。如果单纯计算从$(1,1)$到$(x_i, y_i)$的路径数，其中可能会经过排序在它前面的点，这时需要容斥，容斥的系数为先前一个点$j$到$i$的路径数。 即是 $dp_i = \\sum_{j = 1}^{i - 1} Dist(j, i) \\times dp_j$ 最后答案 $Ans = \\dbinom{n + m}{n} - \\sum_{i = 1} ^ {cnt} Dist(i, (n, m)) \\times dp_i$ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 205;const int Mod = 110119;int cnt, cas;int ans, n, m, sum, fac[Mod + 5], dp[Mod + 5];struct node { int x, y;} s[MAXN];int qpow(int x, int y) { int res = 1; while (y) { if (y &amp; 1) res = res * x % Mod; x = x * x % Mod; y &gt;&gt;= 1; } return res;}int C(int x, int y) { if (y &gt; x) return 0; if (y == 0 || y == x) return 1; return fac[x] * qpow(fac[y], Mod - 2) % Mod * qpow(fac[x - y], Mod - 2) % Mod;}int Lucas(int x, int y) { if (y == 0) return 1ll; return C(x % Mod, y % Mod) * Lucas(x / Mod, y / Mod) % Mod;}int Dis(int p, int q) { int a = s[q].x - s[p].x, b = s[q].y - s[p].y; if ((2 * a - b) % 3 != 0 || (2 * b - a) % 3 != 0) return 0; int x = (2 * a - b) / 3; int y = (2 * b - a) / 3; if (x &lt; 0 || y &lt; 0) return 0; return Lucas(x + y, x);}bool cmp(node a, node b) { return (a.x == b.x) ? a.y &lt; b.y : a.x &lt; b.x;}signed main() { // freopen(&quot;test.in&quot;, &quot;r&quot;, stdin); fac[0] = 1; for (int i = 1; i &lt; Mod - 1; i++) { fac[i] = fac[i - 1] * i % Mod; } while (scanf(&quot;%lld %lld %lld&quot;, &amp;n, &amp;m, &amp;cnt) != EOF) { for (int i = 0; i &lt;= cnt + 5; i++) { s[i].x = s[i].y = dp[i] = 0; } for (int i = 1; i &lt;= cnt; i++) { scanf(&quot;%lld %lld&quot;, &amp;s[i].x, &amp;s[i].y); } s[++cnt].x = 1, s[cnt].y = 1; sort(s + 1, s + 1 + cnt, cmp); ans = 0; dp[1] = 1ll; for (int i = 2; i &lt;= cnt; i++) { for (int j = 1; j &lt; i; j++) { dp[i] = (dp[i] - Dis(j, i * dp[j] % Mod + Mod) % Mod; // 此处的 i, j写反了!!!!!! } } s[++cnt].x = n, s[cnt].y = m; for (int i = 1; i &lt; cnt; i++) { ans = ((ans + dp[i] * Dis(i, cnt)) % Mod + Mod) % Mod; } printf(&quot;Case #%lld: %lld\\n&quot;, ++cas, ans); } return 0;}","link":"/2021/11/26/2021-11-26-A%20Simple%20Chess%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」HDU-6314 Matrix","text":"确实可以推广到一般性题目 Matrixlink 分析原来一直不理解容斥，这道题可以作为一个一般性容斥题目的母题。 首先可以考虑只有行的时候。 设$g_i$为至少有$i$行是黑色的方案数。 显然$g_i = \\sum_\\limits{i=a}^{n} f_i \\dbinom{n}{i} \\times 2 ^ {n - i}$其中$f_k$为容斥系数。 那么可以知道$\\sum_\\limits{i=a}^n f_i\\dbinom{n}{i} = 1$ 就可以开始推式子了。$$\\begin{aligned}1 &amp;= \\sum_\\limits{i=a}^n f_i\\dbinom{n}{i} \\1 &amp;= \\sum_\\limits{i=a}^{n-1} f_i\\dbinom{n}{i} + f_n\\1 &amp;= \\sum_\\limits{i=a}^{n-1} f_i\\Big(\\dbinom{n - 1}{i - 1} + \\dbinom{n - 1}{i}\\Big) + f_n \\f_n &amp;= 1 - \\sum_\\limits{i=a}^{n-1} f_i\\Big(\\dbinom{n - 1}{i - 1} + \\dbinom{n - 1}{i}\\Big)\\f_n &amp;= 1 - \\sum_\\limits{i=a}^{n-1}\\dbinom{n - 1}{i - 1} f_i - \\sum_\\limits{i=a}^{n-1} \\dbinom{n - 1}{i} f_i \\f_n &amp;= -\\sum_\\limits{i=a}^{n-1} \\dbinom{n - 1}{i - 1} f_i\\end{aligned}$$ 然后加入列的贡献。 $g_i = \\sum_\\limits{i=a}^{n} \\sum_\\limits{j=b}^{m} f_{1,i} \\dbinom{n}{i} f_{2,j}\\dbinom{m}{j} \\times 2 ^ {(n - i) \\times (m - j)}$ 时间复杂度是$\\mathcal{O(n^2 + m^2 + nm)}$ 显然不会超时。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 3e3 + 5;const int Mod = 998244353;int n, m, a, b;int f[5][MAXN];LL C[MAXN][MAXN], ans;LL qpow(LL x, int y) { LL res = 1; while (y) { if (y &amp; 1) res = res * x % Mod; x = x * x % Mod; y &gt;&gt;= 1; } return res;}int main() { C[0][0] = 1ll; for (int i = 1; i &lt;= 3000; i++) { C[i][0] = 1ll; for (int j = 1; j &lt;= i; j++) { C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % Mod; } } while (scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;a, &amp;b) != EOF) { ans = 0; memset(f, 0, sizeof(f)); f[1][a] = 1; for (int i = a + 1; i &lt;= n; i++) { for (int j = a; j &lt; i; j++) { f[1][i] = (f[1][i] - C[i - 1][j - 1] * f[1][j] % Mod + Mod) % Mod; } } f[2][b] = 1; for (int i = b + 1; i &lt;= m; i++) { for (int j = b; j &lt; i; j++) { f[2][i] = (f[2][i] - C[i - 1][j - 1] * f[2][j] % Mod + Mod) % Mod; } } for (int i = a; i &lt;= n; i++) { for (int j = b; j &lt;= m; j++) { ans = (ans + f[1][i] * C[n][i] % Mod * f[2][j] % Mod * C[m][j] % Mod * qpow(2, (n - i) * (m - j)) % Mod); } } printf(&quot;%lld\\n&quot;, ans % Mod); } return 0;}","link":"/2021/11/17/2021-11-17-Matrix%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」组合数学测试","text":"组合数学测试题解 T1jumplink 分析感性观察+手玩可以在5min内得到结论。走的路径如下图所示。如果行比列多，就把行列反过来。得到式子是:$\\dbinom{n + m + 1}{m + 1} + m$，上下项的差很小，可以暴力求。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 2000005;const int Mod = 1e9 + 7;int n, m, ans;int qpow(int x, int y) { int res = 1; while (y) { if (y &amp; 1) res = res * x % Mod; x = x * x % Mod; y &gt;&gt;= 1; } return res;}int C(int x, int y) { if ((x - y) &gt; (x - (x - y))) y = x - y; int res = 1ll; for (int i = y + 1; i &lt;= x; i++) { res = (res * (i % Mod)) % Mod; } for (int i = 1; i &lt;= x - y; i++) { res = (res * qpow(i, Mod - 2) % Mod); } return res;}signed main() { freopen(&quot;jump.in&quot;, &quot;r&quot;, stdin); freopen(&quot;jump.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); ans = (C(n + m + 1, m + 1) + m) % Mod; printf(&quot;%lld\\n&quot;, ans); return 0;} T2countlink 分析其实就是个康托展开。 考试时真心没搞清楚题意，于是放弃了。。。但是有重复元素。 可以用如下流程操作。 用桶记录每个数的个数。 对于每一位，枚举小于当前位的数字 如果还有可用的，填进去，计算后面的数字产生全排列的贡献 把当前位的数字个数减一 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 55;char s[MAXN];int n, ans, tot[MAXN], C[MAXN][MAXN];signed main() { freopen(&quot;count.in&quot;, &quot;r&quot;, stdin); freopen(&quot;count.out&quot;, &quot;w&quot;, stdout); C[0][0] = 1; for (int i = 1; i &lt;= 50; i++) { C[i][0] = 1; for (int j = 1; j &lt;= i; j++) { C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; } } scanf(&quot;%s&quot;, s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; i++) { tot[s[i] - 48]++; } for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; s[i] - 48; j++) if(tot[j] &gt; 0) { tot[j]--; int res = 1, sum = n - i; for(int k = 0; k &lt;= 9; k++) { res *= C[sum][sum - tot[k]]; sum -= tot[k]; } tot[j]++; ans += res; } tot[s[i] - 48]--; } printf(&quot;%lld\\n&quot;, ans); return 0;} T3encodinglink我是真的脑子进水了。居然忘了乘每项前的系数，看了半天还没发现。 分析直接隔板法。方案中如果不考虑数字的limit，那么可以有$\\dbinom{m + k - 1}{m - 1}$。然后枚举有多少个填进去的数不合法。 方案数是 $\\dbinom{k + m - 1 - i \\times n}{m - 1}$，注意不合法的板子可以插的地方不唯一，要乘上系数 $\\dbinom{m}{i}$。结果写着写着就忘了。 本题就可以直接奇减偶加容斥求解。 $Ans = \\dbinom{k + m - 1}{m - 1} - {\\Large\\sum_{i = 1}^n} \\dbinom{k + m - 1 - i \\times n}{m - 1} \\dbinom{m}{i} \\times (-1)^i$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long long#define LL long longusing namespace std;const int MAXN = 1e5 + 5;const int Mod = 998244353;int t, n, m, k;LL fac[MAXN &lt;&lt; 1], inv[MAXN &lt;&lt; 1], ans;LL qpow(LL x, int y) { LL res = 1; while (y) { if (y &amp; 1) res = res * x % Mod; x = x * x % Mod; y &gt;&gt;= 1; } return res;}LL C(int x, int y) { if (y &gt; x) return 0; if (x &lt; 0 || y &lt; 0) return 0; return fac[x] * inv[y] % Mod * inv[x - y] % Mod;}signed main() { freopen(&quot;encoding.in&quot;, &quot;r&quot;, stdin); freopen(&quot;encoding.out&quot;, &quot;w&quot;, stdout); fac[0] = inv[0] = 1; for (int i = 1; i &lt;= 2e5; i++) fac[i] = fac[i - 1] * i % Mod; inv[200000] = qpow(fac[200000], Mod - 2); for (int i = 2e5 - 1; i &gt;= 1; i--) inv[i] = inv[i + 1] * (i + 1) % Mod; scanf(&quot;%lld&quot;, &amp;t); while (t--) { scanf(&quot;%lld %lld %lld&quot;, &amp;n, &amp;m, &amp;k); LL ans = C(k + m - 1, m - 1); for (int i = 1, sta = -1; i &lt;= m; i++, sta *= -1) { ans = (ans + C(k + m - 1 - i * n, m - 1) * C(m, i) * (sta) + Mod) % Mod; } printf(&quot;%lld\\n&quot;, ans); } return 0;} T4againstlink 数组开小了 + cmp函数自带大场数 + 忘记处理循环后的遗留数据 = 0 分析没什么好说的。。。 在代码里把错误标出来吧。。。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 2e6 + 5;int n, tot[MAXN], cnt, ans, sum;struct node { int v[6], wid; unsigned long long key;} s[MAXN], tmp[MAXN];bool check(int x, int y) { bool flag = true; for (int i = 1; i &lt;= 5; i++) if(tmp[x].v[i] != tmp[y].v[i]) { flag = false; break; } return flag;}bool cmp(node x, node y) { if (x.wid != y.wid) return x.wid &lt; y.wid; // 哈哈，sort直接TLE // for (int i = 1; i &lt;= 5; i++) { // if (x.v[i] != y.v[i]) { // return x.v[i] &lt; y.v[i]; // } // } // return true; return x.key &lt; y.key;}void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}signed main() { freopen(&quot;against.in&quot;, &quot;r&quot;, stdin); freopen(&quot;against.out&quot;, &quot;w&quot;, stdout); read(n); // double st1 = time(0); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= 5; j++) { read(s[i].v[j]); } sort(s[i].v + 1, s[i].v + 1 + 5); for (int sta = 1; sta &lt; (1 &lt;&lt; 5); sta++) { cnt++; int p = 0; for (int k = 1; k &lt;= 5; k++) if ((1 &lt;&lt; k - 1) &amp; sta) { tmp[cnt].v[++p] = s[i].v[k]; tmp[cnt].key = tmp[cnt].key * 13331 + s[i].v[k]; // 考试没有hash，直接cmp自带大常数 } tmp[cnt].wid = p; } } // double st = time(0); // printf(&quot;%ld\\n&quot;, st - st1); sort(tmp + 1, tmp + 1 + cnt, cmp); // double ed = time(0); // printf(&quot;%lf\\n&quot;, ed - st); 没有hash的排序跑了 9ms 哈哈哈哈。。。 // for (int i = 1; i &lt;= cnt; i++) { // printf(&quot;%d : &quot;, i); // for (int j = 1; j &lt;= 5; j++) { // printf(&quot;%d &quot;, tmp[i].v[j]); // } // printf(&quot;\\n&quot;); // } ans = 0, sum = 0; for (int i = 1; i &lt;= cnt; i++) { if (check(i, i - 1)) { sum++; } else { tot[tmp[i - 1].wid] += (sum * (sum - 1)) / 2; sum = 1; } } tot[tmp[cnt - 1].wid] += (sum * (sum - 1)) / 2; // 考试时没写，结果过样例了。哈哈哈哈。 for (int i = 1, sta = 1; i &lt;= 5; i++, sta *= -1) { // printf(&quot;%lld\\n&quot;, tot[i]); ans += sta * tot[i]; } // printf(&quot;%d\\n&quot;, ans); printf(&quot;%lld\\n&quot;, ((long long)n * (n - 1) / 2) - ans); return 0;}","link":"/2021/11/27/2021-11-27-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E6%B5%8B%E8%AF%95%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」二项式反演乱搞","text":"均为口胡","link":"/2021/11/29/2021-11-29-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%E4%B9%B1%E6%90%9E/"},{"title":"「Solution」文理分科 &amp; 圈地计划","text":"网络流建图 文理分科linklink 分析可以知道，每个点只能选择 文/理 中的一种，那么可以将其转化为一个二分图最小割的问题。 把每个点的贡献拆开，一部分是自己选科后的贡献 art_i或science_i ，一部分是与相邻同学在一起产生的贡献 same_art_i 或 same_science_i。 那么把点分成 i ， i' ， i''。 如下图 将i'向周围的四个点j1~j4连边，边权为same_art_i，再将j1~j4向i'' 连边，边权为same_science_i。 为什么是对的呢？ 因为根据最小割定义，它会将图分成两个集合。 由于题目中二选一的限制，划分后可以保证每个学生只选一门。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5e2 + 5;const int MAXM = 5e7 + 5;const int INF = 0x3f3f3f3f;const int dx[5] = {0, 1, -1, 0, 0};const int dy[5] = {0, 0, 0, 1, -1};int n, m, st, ed, now, ans, tmp, d[MAXM], cur[MAXM];int art[MAXN][MAXN], sci[MAXN][MAXN], sa[MAXN][MAXN], ss[MAXN][MAXN];int tot = 1, head[MAXM], ver[MAXM], edge[MAXM], nxt[MAXM];queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { // printf(&quot;%d %d %d\\n&quot;, u, v, c); ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs() { memset(d, 0, sizeof(d)); while (!q.empty()) q.pop(); q.push(st), d[st] = 1, cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != 0) continue; q.push(v); cur[v] = head[v]; d[v] = d[u] + 1; if (v == ed) return true; } } return false;}int dinic(int u, int flow) {// printf(&quot;%d %d %d\\n&quot;, now, u, d[u]); if (u == ed) return flow; int res = flow, k, i; for (i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; now++; k = dinic(v, min(res, edge[i])); now--; if (k == 0) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k; res -= k; cur[u] = i; } return flow - res;}int ind(int x, int y) { return (x - 1) * m + y; }int ind1(int x, int y) { return (x - 1) * m + y + n * m; }int ind2(int x, int y) { return (x - 1) * m + y + n * m * 2; }int main() { // freopen(&quot;B.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); st = n * m * 3 + 1, ed = n * m * 3 + 2; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;art[i][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;sci[i][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;sa[i][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;ss[i][j]); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { AddEdge(st, ind(i, j), art[i][j]); AddEdge(ind(i, j), ed, sci[i][j]); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { AddEdge(st, ind1(i, j), sa[i][j]); AddEdge(ind2(i, j), ed, ss[i][j]); for (int k = 0; k &lt;= 4; k++) { int nx = i + dx[k], ny = j + dy[k]; // printf(&quot;%d %d\\n&quot;, nx, ny); if (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; m) continue; AddEdge(ind1(i, j), ind(nx, ny), INF); AddEdge(ind(nx, ny), ind2(i, j), INF); } } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { ans += art[i][j] + sci[i][j] + sa[i][j] + ss[i][j]; } } while (bfs()) { while ((tmp = dinic(st, INF))) { ans -= tmp; } } printf(&quot;%d\\n&quot;, ans); return 0;} 圈地计划linklink 分析其实可以转换到与上一道题差不多。但是它对周围造成的贡献是反的。 考虑黑白染色。如果当前点是黑的，那么就把 a_i 和 b_i 交换，即可完成反向。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e3 + 5;const int MAXM = 5 * 1e6 + 5;const int dx[5] = {0, 0, 0, 1, -1};const int dy[5] = {0, 1, -1, 0, 0};const int INF = 0x3f3f3f3f;int n, m, a[MAXN][MAXN], b[MAXN][MAXN], c[MAXN][MAXN], cur[MAXM], d[MAXM];int st, ed, ans, tmp, tot = 1, head[MAXM], nxt[MAXM], edge[MAXM], ver[MAXM];int ind(int x, int y) { return (x - 1) * m + y;}queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs() { memset(d, 0, sizeof(d)); while (!q.empty()) q.pop(); q.push(st), d[st] = 1, cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != 0) continue; q.push(v); cur[v] = head[v]; d[v] = d[u] + 1; if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow, k, i; for (i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; k = dinic(v, min(res, edge[i])); if (k == 0) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k; res -= k; cur[u] = i; } return flow - res;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); st = n * m * 4 + 1, ed = n * m * 4 + 2; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf(&quot;%d&quot;, &amp;a[i][j]); ans += a[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf(&quot;%d&quot;, &amp;b[i][j]); ans += b[i][j]; } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf(&quot;%d&quot;, &amp;c[i][j]); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if ((i &amp; 1) == (j &amp; 1)) { swap(a[i][j], b[i][j]); } AddEdge(st, ind(i, j), a[i][j]); AddEdge(ind(i, j), ed, b[i][j]); for (int k = 1; k &lt;= 4; k++) { int nx = i + dx[k]; int ny = j + dy[k]; if (nx &lt; 1 || ny &lt; 1 || nx &gt; n || ny &gt; m) continue; AddEdge(ind(i, j), ind(nx, ny), c[i][j] + c[nx][ny]); ans += c[i][j]; } } } while (bfs()) { while ((tmp = dinic(st, INF))) ans -= tmp; } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2021/12/09/2021-12-09-%E6%96%87%E7%90%86%E5%88%86%E7%A7%91%20&%20%E5%9C%88%E5%9C%B0%E8%AE%A1%E5%88%92%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」最大权闭合子图 习题","text":"做题记录 小M的作物$\\mathcal{Link}$link $\\mathcal{Sol}$直接用文理分科思路直接碾过去 如果非要用最大权闭合子图解释也是可以的。那么可以先把每个点分别向 $A,B$ 集合连边， 可以清晰地看到其中的依赖关系， 即是每个额外价值依赖于其中的作物。 然后建虚点表示额外价值向每个作物连边即可。 $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e6 + 5;const int MAXM = 1e7 + 5;const int INF = 0x3f3f3f3f;int n, m, cnt, cur[MAXM], d[MAXM], deg[MAXN];int st, ed, ans, tmp, tot = 1, head[MAXM], nxt[MAXM], edge[MAXM], ver[MAXM];queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { // printf(&quot;--%d %d %d\\n&quot;, u, v, c); ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs() { memset(d, 0, sizeof(d)); while (!q.empty()) q.pop(); q.push(st), d[st] = 1, cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != 0) continue; q.push(v); cur[v] = head[v]; d[v] = d[u] + 1; if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow, k, i; for (i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; k = dinic(v, min(res, edge[i])); if (k == 0) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k; res -= k; cur[u] = i; } return flow - res;}signed main() { // freopen(&quot;1.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;D.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); st = n + 1, ed = cnt = n + 2; for (int i = 1, x; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;x); AddEdge(st, i, x); ans += x; } for (int i = 1, x; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;x); AddEdge(i, ed, x); ans += x; } scanf(&quot;%d&quot;, &amp;m); for (int i = 1, k, c1, c2; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;, &amp;k, &amp;c1, &amp;c2); cnt++; AddEdge(st, cnt, c1); AddEdge(cnt + 1, ed, c2); ans += c1, ans += c2; for (int j = 1, v; j &lt;= k; j++) { scanf(&quot;%d&quot;, &amp;v); AddEdge(cnt, v, INF); AddEdge(v, cnt + 1, INF); } cnt++; } // printf(&quot;%d\\n&quot;, ans); while (bfs()) { while ((tmp = dinic(st, INF))) ans -= tmp; } printf(&quot;%d\\n&quot;, ans); return 0;} Strange Set$\\mathcal{Link}$link $\\mathcal{Sol}$体验 $5 \\ minutes’ \\ time$ 快速切掉 2700 的 F 的快感。 显然的依赖关系，即是 $a_i$ 依赖于 $a_j \\mid a_i (1 \\le j &lt; i)$。没看空限，直接 $\\mathbb{MLE \\ on \\ test \\ 14}$ 寻求思辨。发现对于每个因数，只需要连最后的那个就行了。 $\\mathcal{Code}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 6e5 + 5;const int MAXM = 6e5 + 5;const int INF = 0x3f3f3f3f;int n, m, cnt, cur[MAXM], d[MAXM], a[MAXN], b[MAXN];int st, ed, ans, tmp, tot = 1, head[MAXM], nxt[MAXM], edge[MAXM], ver[MAXM];bool vis[MAXN];queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { // printf(&quot;--%d %d %d\\n&quot;, u, v, c); ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs() { memset(d, 0, sizeof(d)); while (!q.empty()) q.pop(); q.push(st), d[st] = 1, cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != 0) continue; q.push(v); cur[v] = head[v]; d[v] = d[u] + 1; if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow, k, i; for (i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; k = dinic(v, min(res, edge[i])); if (k == 0) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k; res -= k; cur[u] = i; } return flow - res;}signed main() { scanf(&quot;%d&quot;, &amp;n); st = n + 1, ed = n + 2; for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 1; i &lt;= n; i++) { if (b[i] &gt; 0) AddEdge(st, i, b[i]), ans += b[i]; else AddEdge(i, ed, -b[i]); } for (int i = 1; i &lt;= n; i++) { memset(vis, 0, sizeof(vis)); for (int j = i - 1; j &gt;= 1; j--) { if (a[i] % a[j] == 0 &amp;&amp; vis[a[j]] == 0) { AddEdge(i, j, INF); vis[a[j]] = 1; } } } while (bfs()) { while ((tmp = dinic(st, INF))) ans -= tmp; } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2021/12/11/2021-12-11-%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%20%E4%B9%A0%E9%A2%98%E9%A2%98%E8%A7%A3/"},{"title":"「Note」二项式反演","text":"对于推广的证明 $$\\Large f(n) = \\sum_{i = n}^m \\dbinom{i}{n} g(i)\\\\rightarrow g(n) = \\sum_{i=n}^m (−1)^{i - n} \\dbinom{i}{n} f(i)$$","link":"/2021/12/13/2021-12-13-%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"},{"title":"「Solution」最小割测试","text":"… $\\mathbb{Destroy}$$\\mathcal{Link}$link $\\mathcal{Sol}$没什么好说的，将点拆成两个，注意输入的顺序。 形式化地，有$$V_N = V \\cup {s,t}\\E_N = E \\cup {&lt;s, u&gt; \\mid u \\in V} \\cup {&lt;u’, t&gt; \\mid u’ \\in V’}\\\\begin{cases}c(s, u) = w’_u\\c(v’, t) = w_v\\c(u, v’) = \\infty\\\\end{cases}$$ $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e4 + 100;const int MAXMAP = 1e2 + 5;const int INF = 0x3f3f3f3f;void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}int tmp, ans, n, m, st, ed, a[MAXN], b[MAXN], d[MAXN], cur[MAXN];bool vis_st[MAXN], vis_ed[MAXN], linked[MAXMAP][MAXMAP];int tot = 1, head[MAXN], nxt[MAXN], edge[MAXN], ver[MAXN];queue&lt;int&gt; q;int ind(int x, int k) { return x + n * k;}void AddEdge(int u, int v, int c) { // printf(&quot;%d %d %d\\n&quot;, u, v, c); ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs(int st) { memset(d, 0, sizeof(d)); while (!q.empty()) q.pop(); q.push(st), d[st] = 1, cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != 0) continue; q.push(v); cur[v] = head[v]; d[v] = d[u] + 1; if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow, k, i; for (i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; k = dinic(v, min(res, edge[i])); if (k == 0) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k; res -= k; cur[u] = i; } return flow - res;}int main() { freopen(&quot;destroy.in&quot;, &quot;r&quot;, stdin); freopen(&quot;destroy.out&quot;, &quot;w&quot;, stdout); read(n), read(m); st = 2 * n + 1, ed = 2 * n + 2; for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= n; i++) read(b[i]); for (int i = 1, u, v; i &lt;= m; i++) { read(u), read(v); if (vis_st[u] == 0) AddEdge(st, ind(u, 0), b[u]), vis_st[u] = 1; if (linked[ind(u, 0)][ind(v, 1)] == 0) AddEdge(ind(u, 0), ind(v, 1), INF), linked[ind(u, 0)][ind(v, 1)] = 1; if (vis_ed[v] == 0) AddEdge(ind(v, 1), ed, a[v]), vis_ed[v] = 1; } while (bfs(st)) { while ((tmp = dinic(st, INF))) ans += tmp; } printf(&quot;%d\\n&quot;, ans); return 0;} $\\mathbb{Lotus}$$\\mathcal{Link}$link $\\mathcal{Sol}$真的吐了，怎么一堆人用$1e6$的点的暴力跑过去。。。其实和棋盘上的守卫很相似。 对于一个点$(x,y)$，从它可以到达第$x$行，第$y$列的所有其他可行的点。那么可以将横纵坐标连接，边的容量为$1$表示这两行/列上可行点组成的联通快是可达的。建一个大源/汇点，分别连向初始/终止点的横纵坐标。边的容量为$+\\infty$。 所以最后整张图只有$n + m$个点。 形式化地，设$V$为所有行列编号组成的点集，$P$为可行点的点集，有$$P = {(x,y) \\mid map(x,y) = o } \\V_N = V \\cup {S,T}\\E_N = {&lt;u,v’&gt; \\mid (u,v) \\in P } \\cup {&lt;v’,u&gt; \\mid (u,v) \\in P } \\cup &lt;S, s_x&gt; \\cup &lt;S, s_y&gt; \\cup &lt;t_x, T&gt; \\cup &lt;t_y, T&gt;\\\\begin{cases}c(S, s_x) = c(S, s_y) = c(t_x, T) = c(t_y, T) = \\infty \\c(u, v’) = c(v’, u) = 1\\end{cases}$$ $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXMAP = 2e2 + 5;const int MAXN = 4e4 + 500;const int INF = 0x3f3f3f3f;void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}int n, m, st, ed, ans, tmp, cnt = 2, d[MAXN], cur[MAXN];char s[MAXMAP][MAXMAP];bool vis[MAXN];int tot = 1, head[MAXN], nxt[MAXN], edge[MAXN], ver[MAXN];queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { // printf(&quot;%d %d %d\\n&quot;, u, v, c); ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs(int st) { memset(d, 0, sizeof(d)); while (!q.empty()) q.pop(); q.push(st), d[st] = 1, cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != 0) continue; q.push(v); cur[v] = head[v]; d[v] = d[u] + 1; if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow, k, i; for (i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; k = dinic(v, min(res, edge[i])); if (k == 0) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k; res -= k; cur[u] = i; } return flow - res;}int main() { freopen(&quot;lotus.in&quot;, &quot;r&quot;, stdin); freopen(&quot;lotus.out&quot;, &quot;w&quot;, stdout); read(n), read(m); st = n + m + 1, ed = n + m + 2; for (int i = 1; i &lt;= n; i++) scanf(&quot;%s&quot;, s[i] + 1); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) if (s[i][j] != '.') { AddEdge(i, j + n, 1); AddEdge(j + n, i, 1); if (s[i][j] == 'S') AddEdge(st, i, INF), AddEdge(st, j + n, INF); if (s[i][j] == 'T') AddEdge(i, ed, INF), AddEdge(j + n, ed, INF); } } while (bfs(st)) { while ((tmp = dinic(st, INF))) ans += tmp; } if (ans &gt;= INF) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;, ans); return 0;} $\\mathbb{Mincut}$$\\mathcal{Link}$link $\\mathcal{Sol}$读完题，感觉一脸不可做的样子。。。然后考试时写了个暴力，乱开数组，直接$\\mathtt{MLE \\ \\ 0}$。。。 首先跑一遍最小割，那么，所有的可行边一定满流了。再在残余网络上面跑$\\mathtt{SCC}$，如果对于一条必须边，它一定分属于两个集合，否则就是一条可行边。 更形式化的，有 $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5e4 + 5;const int MAXM = 1e5 + 2e4 + 5;const int INF = 0x3f3f3f3f;void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}int n, m, st, ed, now, ans, tmp, cnt[MAXN], d[MAXM], cur[MAXM];int tot = 1, head[MAXN], ver[MAXM], edge[MAXM], nxt[MAXM], fr[MAXM], scc;int dfn[MAXN], low[MAXN], stk[MAXN], vis[MAXN], tp, dn;bool ex[MAXN];queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { // printf(&quot;%d %d %d\\n&quot;, u, v, c); ver[++tot] = v, fr[tot] = u, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, fr[tot] = v, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs() { memset(d, 0, sizeof(d)); while (!q.empty()) q.pop(); q.push(st), d[st] = 1, cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); // printf(&quot;%d\\n&quot;, u); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != 0) continue; q.push(v); cur[v] = head[v]; d[v] = d[u] + 1; if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow, k, i; for (i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; now++; k = dinic(v, min(res, edge[i])); now--; if (k == 0) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k; res -= k; cur[u] = i; } return flow - res;}void Tarjan(int u, int fa) { dfn[u] = low[u] = ++dn; ex[u] = 1, stk[++tp] = u; for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i]) continue; if (!dfn[v]) { Tarjan(v, u); low[u] = min(low[u], low[v]); } else if (ex[v]) { low[u] = min(low[u], dfn[v]); } } if (low[u] == dfn[u]) { int v; scc++; do { v = stk[tp--]; vis[v] = scc; ex[v] = 0; } while (v != u); }}int main() { freopen(&quot;mincut.in&quot;, &quot;r&quot;, stdin); freopen(&quot;mincut.out&quot;, &quot;w&quot;, stdout); read(n), read(m), read(st), read(ed); for (int i = 1, u, v, w; i &lt;= m; i++) read(u), read(v), read(w), AddEdge(u, v, w); while (bfs()) { // printf(&quot;ok\\n&quot;); while ((tmp = dinic(st, INF))) ans += tmp; } for (int i = 1; i &lt;= n; i++) { if (!vis[i]) { Tarjan(i, 0); } } // for (int i = 1; i &lt;= n; i++) { // printf(&quot;%d &quot;, vis[i]); // } // printf(&quot;\\n&quot;); for (int i = 2; i &lt;= tot; i += 2) { // printf(&quot;%d %d %d\\n&quot;, fr[i], ver[i], edge[i]); if (edge[i] != 0) { printf(&quot;0 0\\n&quot;); } else { if (vis[fr[i]] != vis[ver[i]]) { if (vis[ver[i]] == vis[ed] &amp;&amp; vis[fr[i]] == vis[st]) { printf(&quot;1 1\\n&quot;); } else { printf(&quot;1 0\\n&quot;); } } else printf(&quot;0 0\\n&quot;); } } return 0;}","link":"/2021/12/18/2021-12-18-%E6%9C%80%E5%B0%8F%E5%89%B2%E6%B5%8B%E8%AF%95%20%E9%A2%98%E8%A7%A3/"},{"title":"「Note」KM","text":"便于记忆。。。 12345678910111213141516171819202122232425262728293031323334353637383940using namespace std;const int MAXN = 505;const int INF = 0x3f3f3f3f;int n, m, la[MAXN], lb[MAXN], sl[MAXN], match[MAXN], w[MAXN][MAXN], fa[MAXN], ans, re[MAXN];bool vis[MAXN];void bfs(int u) { memset(sl, 0x3f, sizeof(sl)); // 将 slack 标记清空 memset(vis, 0, sizeof(vis)); // 清 vis int pos = 0, x, p, delta; for (match[pos] = u; match[pos]; pos = p) { // 迭代模拟递归 vis[pos] = 1, x = match[pos], delta = INF; // 初始化 置标记,从右部图节点到匹配的左部图,把 delta 置为无穷 for (int y = 1; y &lt;= n; y++) { // 遍历右部的节点 if (vis[y]) continue; if (la[x] + lb[y] - w[x][y] &lt; sl[y]) { // 更新 sl 标记 sl[y] = la[x] + lb[y] - w[x][y]; fa[y] = pos; // 记录前驱 } if (sl[y] &lt; delta) { delta = sl[y]; // 更新 delta p = y; // 把 y 丢进去扩展 相当于 dfs(y) } } for (int y = 0; y &lt;= n; y++) { if (vis[y]) la[match[y]] -= delta, lb[y] += delta; // 把经过的顶点权值更新 else sl[y] -= delta; // 更新 slack 此处可以消掉一个 n } } for (; pos; pos = fa[pos]) match[pos] = match[fa[pos]]; // 增广重置匹配}void KM() { for (int i = 1; i &lt;= n; i++) bfs(i); } 整个算法的时间复杂度是 $\\mathcal{O(n ^ 3)}$","link":"/2021/12/23/2021-12-23-KM%20%E6%A8%A1%E6%9D%BF/"},{"title":"「Solution」二分图多重匹配 习题集","text":"题解集合 $\\mathbb{Jamie’s Contact Groups}$$\\mathcal{Link}$link $\\mathcal{Sol}$模板题，对于此类问题，解决方案可以是网络流。对于匈牙利算法，有部分代码需要变动。 1234567891011121314bool dfs(int u) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v]) continue; vis[v] = 1; if (cnt[v] &lt; limit[v]) { match[v][++cnt[v]] = u; return true; } //如果还可以继续匹配则继续 for (int j = 1; j &lt;= cnt[v]; j++) { // 否则就在已匹配的点中增广 if (dfs(match[v][j])) { match[v][j] = u; return true; } } } return false;} $\\mathcal{Code}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e3 + 5;int n, m, l, r, mid, cnt[MAXN], match[MAXN][MAXN];char tmp[15];vector&lt;int&gt; G[MAXN];bool vis[MAXN];bool dfs(int u) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v]) continue; vis[v] = 1; if (cnt[v] &lt; mid) { match[v][++cnt[v]] = u; return true; } for (int j = 1; j &lt;= cnt[v]; j++) { if (dfs(match[v][j])) { match[v][j] = u; return true; } } } return false;}bool check(int mid) { memset(cnt, 0, sizeof(cnt)); memset(match, 0, sizeof(match)); for (int i = 1; i &lt;= n; i++) { memset(vis, 0, sizeof(vis)); if (!dfs(i)) return false; } return true;}int main() { // freopen(&quot;E.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;E.out&quot;, &quot;w&quot;, stdout); while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n + m)) { for (int i = 1, j; i &lt;= n; i++) { G[i].clear(); scanf(&quot;%s&quot;, tmp); char emsp; while (1) { scanf(&quot;%d%c&quot;, &amp;j, &amp;emsp); G[i].push_back(j); if (emsp == '\\n') break; } } l = 1, r = n; while (l &lt; r) { mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } printf(&quot;%d\\n&quot;, l); } return 0;} $\\mathbb{Optimal Milking}$$\\mathcal{Link}$link $\\mathcal{Sol}$其实和网络流中奶牛躲雨棚一个思路。 首先$\\mathcal{Floyd}$出来两两点之间的最短路。然后二分答案。用匈牙利判匹配即可。 $\\mathcal{Code}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = (200 &lt;&lt; 1) + 5;const int INF = 0x3f3f3f3f;int n, m, l, r, mid, limit, dis[MAXN][MAXN], cnt[MAXN], match[MAXN][MAXN];vector&lt;int&gt; G[MAXN];bool vis[MAXN];bool dfs(int u) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v]) continue; vis[v] = 1; if (cnt[v] &lt; limit) { match[v][++cnt[v]] = u; return true; } for (int j = 1; j &lt;= cnt[v]; j++) { if (dfs(match[v][j])) { match[v][j] = u; return true; } } } return false;}bool check(int mid) { // printf(&quot;--%d--\\n&quot;, mid); for (int i = n + 1; i &lt;= n + m; i++) G[i].clear(); memset(cnt, 0, sizeof(cnt)); memset(match, 0, sizeof(match)); for (int i = 1; i &lt;= n; i++) { for (int j = n + 1; j &lt;= n + m; j++) if (dis[i][j] &lt;= mid) { G[j].push_back(i); // printf(&quot;%d %d\\n&quot;, j, i); } } for (int i = n + 1; i &lt;= n + m; i++) { memset(vis, 0, sizeof(vis)); if (!dfs(i)) return false; } return true;}int main() { // freopen(&quot;D:\\\\ChenJiage\\\\2021-12-23\\\\F.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;F.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;limit); for (int i = 1; i &lt;= n + m; i++) { for (int j = 1; j &lt;= n + m; j++) { scanf(&quot;%d&quot;, &amp;dis[i][j]); if (dis[i][j] == 0) dis[i][j] = INF; } } for (int k = 1; k &lt;= n + m; k++) for (int i = 1; i &lt;= n + m; i++) for (int j = 1; j &lt;= n + m; j++) if (i != j) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); for (int i = 1; i &lt;= n; i++) for (int j = n + 1; j &lt;= n + m; j++) r = max(r, dis[i][j]); while (l &lt; r) { mid = (l + r) &gt;&gt; 1; // printf(&quot;%d %d %d\\n&quot;, l, mid, r); if (check(mid)) r = mid; else l = mid + 1; } printf(&quot;%d\\n&quot;, l); return 0;} $\\mathbb{Steady Cow Assignment}$$\\mathcal{Link}$link $\\mathcal{Sol}$哈哈哈哈，这个阴间输入，哈哈哈。 输入挂了，一直$\\mathtt{WA \\ Test \\ 6}$，总共就 $\\mathtt{7}$个点。什么鬼东西。。。 然后值域很小，直接枚举区间就能过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e3 + 5;const int MAXM = 25;const int INF = 0x3f3f3f3f;int n, m, ans, limit[MAXM], p[MAXN][MAXM], match[MAXM][MAXN], cnt[MAXM];vector&lt;int&gt; G[MAXN];bool vis[MAXM];bool dfs(int u) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v]) continue; vis[v] = 1; if (cnt[v] &lt; limit[v]) { match[v][++cnt[v]] = u; return true; } for (int j = 1; j &lt;= cnt[v]; j++) { if (dfs(match[v][j])) { match[v][j] = u; return true; } } } return false;}bool check(int l, int r) { memset(cnt, 0, sizeof(cnt)); memset(match, 0, sizeof(match)); memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= n; i++) G[i].clear(); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) if (p[i][j] &gt;= l &amp;&amp; p[i][j] &lt;= r) { G[i].push_back(j); } } for (int i = 1; i &lt;= n; i++) { memset(vis, 0, sizeof(vis)); if (!dfs(i)) return false; } return true;}int main() { // freopen(&quot;G.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;G.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) for (int j = 1, x; j &lt;= m; j++) scanf(&quot;%d&quot;, &amp;x), p[i][x] = j; for (int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;limit[i]); ans = INF; for (int l = 1; l &lt;= m; l++) { for (int r = l; r &lt;= m; r++) { if (check(l, r)) ans = min(ans, r - l + 1); } } printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/2021/12/24/2021-12-24-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%A4%9A%E9%87%8D%E5%8C%B9%E9%85%8D%20%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/"},{"title":"「Solution」[BJOI2012]连连看","text":"顺带练习 $dij + EK$ 求费用流 $\\mathcal{Link}$link $\\mathcal{Sol}$这种两两配对的题盲猜是二分图。但事实证明是这道题只在 $1≤a,b≤1000$ 的情况下成立。。。 可是并不妨碍做题。 看到分数最大考虑把它转化为一个费用流解决的问题，那么先拆点，从源向每个数的入点连边，从每个数的出点向汇点连边，容量为 $1$，费用为 $0$， 如果两两点之间可以产生贡献，就交叉连边，容量为 $1$， 费用为点权。 形式化地有: $$V_N = V \\cup V’ \\cup {s,t}\\E = {&lt;u, v&gt; \\mid (u, v) \\ \\mathrm{satisfies \\ the \\ requirement \\ above} } \\E_N = E \\cup {&lt;s, u&gt; \\mid u \\in V} \\cup {&lt;u’, t&gt; \\mid u’ \\in V’}\\\\begin{cases}c(s, u) = 1, w(s, u) = 0\\c(u’, t) = 1, w(u’, t) = 0\\c(u, v’) = 1, w(u, v’) = u + v\\c(v, u’) = 1, w(v, u’) = u + v\\\\end{cases}$$ 建完图跑一个最大费用最大流就好了。 $\\mathcal{Code}$关于 $dij + EK$ 写法。 因为 $dij$ 无法处理负权， 可以给每个点加上势能函数 $h_u$ ，然后把 $w_{u, v}$ 替换成 $h_u - h_v + w_{u, v}$。 只要可以保证 $w_{u, v} \\le h_u - h_v + w_{u, v}$ 就可以把负边干掉。 那么可以先跑一次 $\\mathrm{SPFA}$，把$h_i$设成$dis_i$就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pii pair&lt;int, int&gt;#define con make_pairusing namespace std;const int MAXN = 2e3 + 5;const int MAXM = 1e4 + 5;const int INF = 0x3f3f3f3f;int n, m, st, ed, ans, tmp, mincost, mark[MAXN * MAXN], h[MAXN], pre[MAXN], flow[MAXN];int tot = 1, head[MAXN], edge[MAXM], cost[MAXM], nxt[MAXM], ver[MAXM], dis[MAXN], cur[MAXN], d[MAXN];queue&lt;int&gt; q;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; que; bool vis[MAXN];void AddEdge(int u, int v, int c, int w) { ver[++tot] = v, edge[tot] = c, cost[tot] = w, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, cost[tot] = -w, nxt[tot] = head[v], head[v] = tot;} bool spfa(int st) { while (!q.empty()) q.pop(); memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= 2 * m + 2; i++) dis[i] = INF; dis[st] = 0, q.push(st), vis[st] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || dis[v] &lt;= dis[u] + cost[i]) continue; dis[v] = dis[u] + cost[i]; if (!vis[v]) { vis[v] = 1; q.push(v); } } } for (int i = 1; i &lt;= 2 * m + 2; i++) h[i] = dis[i]; return (dis[ed] &lt; INF);}bool dijstra(int st) { while (!que.empty()) que.pop(); for (int i = 1; i &lt;= 2 * m + 2; i++) dis[i] = INF; memset(vis, 0, sizeof(vis)); memset(pre, 0, sizeof(pre)); que.push(con(0, st)), dis[st] = 0, flow[st] = INF; while (!que.empty()) { int u = que.top().second; que.pop(); if (vis[u]) continue; vis[u] = 1; for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || dis[v] &lt;= dis[u] + cost[i] + h[u] - h[v]) continue; dis[v] = dis[u] + cost[i] + h[u] - h[v]; pre[v] = i; flow[v] = min(flow[u], edge[i]); que.push(con(dis[v], v)); } } return (dis[ed] &lt; INF);}int gcd(int x, int y) { if (y == 0) return x; else return gcd(y, x % y);}bool check(int x, int y) { if (mark[y * y - x * x] != 0 &amp;&amp; gcd(x, mark[y * y - x * x]) == 1) return true; else return false; }int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= 1000; i++) mark[i * i] = i; st = 2 * m + 1, ed = 2 * m + 2; for (int i = n; i &lt;= m; i++) { AddEdge(st, i, 1, 0); AddEdge(i + m, ed, 1, 0); for (int j = i + 1; j &lt;= m; j++) if (check(i, j)) { // printf(&quot;--%d %d\\n&quot;, i, j); AddEdge(i, j + m, 1, -(i + j)); AddEdge(j, i + m, 1, -(i + j)); } } spfa(st); while (dijstra(st)) { for (int i = 1; i &lt;= 2 * m + 2; i++) h[i] = min(h[i] + dis[i], INF); ans += flow[ed]; mincost += flow[ed] * h[ed]; for (int i = ed; i != st; i = ver[pre[i] ^ 1]) { edge[pre[i]] -= flow[ed], edge[pre[i] ^ 1] += flow[ed]; } } printf(&quot;%d %d\\n&quot;, ans / 2, -mincost / 2); return 0;}","link":"/2022/01/06/2022-01-06-%5BBJOI2012%5D%E8%BF%9E%E8%BF%9E%E7%9C%8B%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」Fairy","text":"十年前的紫题? $\\mathbb{Fairy}$$\\mathcal{Link}$link $\\mathcal{Sol}$这道题充分说明我二分图没整抻抖。 考察了一个基本的性质，如果这张图是二分图，那么图中一定不含奇环。然而我再知道性质的情况下不会做。。。 再重新理一遍思路。 $\\mathcal{Part \\ 1 \\ Dfs}$首先染色，根据染色规律可以知道，如果一个点与它相邻的某个点染上了同样的颜色，则它存在于奇环上。于是可以树上差分维护。注意判断返租边应该是dep[v] &lt; dep[u] - 1。顺便记录奇环的个数。 $\\mathcal{Part \\ 2 \\ Check}$ 如果有偶环，偶环上的所有边都不能删 如果没有奇环，所有边都可以删 如果有一个奇环，这个奇环上的所有边都能删 如果有多个奇环，所有奇环上的边都能删 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e4 + 5;int n, m, tot, cut, col[MAXN], dep[MAXN], sum1[MAXN], sum2[MAXN], ind[MAXN];vector&lt;int&gt; ans;struct Edge { int v, id; Edge() {} Edge(int V, int Id) { v = V, id = Id; }};vector&lt;Edge&gt; G[MAXN];void paint(int u, int c, int fa) { col[u] = c; dep[u] = dep[fa] + 1; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i].v; if (!col[v]) { paint(v, col[u] * -1, u); ind[v] = G[u][i].id; sum1[u] += sum1[v]; sum2[u] += sum2[v]; } else if (dep[v] &lt; dep[u] - 1) { if (col[v] == col[u]) cut = G[u][i].id, sum1[u]++, sum1[v]--, tot++; else sum2[u]++, sum2[v]--; } }}int main() { // freopen(&quot;CF19E.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;CF19E.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, u, v; i &lt;= m; i++) { scanf(&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(Edge(v, i)); G[v].push_back(Edge(u, i)); } for (int i = 1; i &lt;= n; i++) if (!col[i]) paint(i, 1, 0); if (tot == 0) { printf(&quot;%d\\n&quot;, m); for (int i = 1; i &lt;= m; i++) printf(&quot;%d &quot;, i); return 0; } if (tot == 1) { ans.push_back(cut); } for (int i = 1; i &lt;= n; i++) if (sum1[i] == tot &amp;&amp; !sum2[i]) { ans.push_back(ind[i]); } sort(ans.begin(), ans.end()); ans.resize(unique(ans.begin(), ans.end()) - ans.begin()); printf(&quot;%d\\n&quot;, ans.size()); for (int i = 0; i &lt; ans.size(); i++) { printf(&quot;%d &quot;, ans[i]); } return 0;}","link":"/2021/12/28/2021-12-28-CF19E%20Fairy%20%E9%A2%98%E8%A7%A3/"},{"title":"「Note」有源汇有上下界最小流","text":"网上的模板乱七八糟的，找的的两种 $\\mathrm{reliable}$ 的版本 $\\mathcal{Link}$link $\\mathcal{Sol}$具体的证明不写了，主要是网上对于这种题的写法都不一样。重新理一遍思路。有些东西或许是错的，如果有疑问的可以留言。 约定: $nowst$ 和 $nowed$ 表示原图指定的 源/汇 点， $st$ 和 $ed$ 表示建的虚点。 $\\mathcal{Step \\ 1}$对于原图进行建边 Connect(u, v, lower, upper)统计每个点可浮动的流量 balance[i] $\\mathcal{Step \\ 2}$ case 1 balance[i] &gt; 0 则 Connect(i, ed, balance[i]) case 2 balance[i] &lt; 0 则 Connect(st, i, -balance[i])$\\mathcal{Step \\ 3}$从这一步开始就很神奇了。。。 $\\mathcal{Way \\ 1}$ 直接Connect(nowed, nowst, 0, INF)，以$st$为源，$ed$为汇做一遍最大流。 以$nowed$为源，$nowst$为汇做一遍最大流 （退流） 用 $ans$ 累加上面左右最大流的和，答案是$INF - ans$ (反向边) 正常人的写法。其实就是退流思想是将残量网络中不需要的流退掉，将最大流与可行流相加即可（类似于有源汇上下界最大流）。 $\\mathcal{Way \\ 2}$ 以$st$为源，$ed$为汇做一遍最大流 Connect(nowed, nowst, 0, INF) 以$st$为源，$ed$为汇做一遍最大流 答案是 $&lt;nowst, nowed&gt;$ 的反向边现存流量 这就很神奇了。我似乎没有看到退流，但是代码写起来令人心情愉悦。并且没有把 源汇 和 虚源汇写错的风险。 问题是为什么是对的。。。@FlowerDream 需要您透彻的讲解，似乎机房里就您比较懂了。 $\\mathcal{Code}$$mathcal{Way \\ 1}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 2e5 + 5;const int MAXM = 5e5 + 5;const int INF = 1e18;int n, m, sum, ans, tmp, nowst, nowed, balance[MAXN], d[MAXN], cur[MAXN], base[MAXM];int st, ed, tot = 1, head[MAXN], edge[MAXM], nxt[MAXM], ver[MAXM];queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs(int st) { while (!q.empty()) q.pop(); memset(d, 0, sizeof(d)); d[st] = 1, q.push(st), cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v]) continue; d[v] = d[u] + 1, cur[v] = head[v]; q.push(v); if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow; for (int i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; int k = dinic(v, min(res, edge[i])); if (!k) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k, res -= k; cur[u] = i; } return flow - res;}signed main() { // freopen(&quot;7.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%lld %lld %lld %lld&quot;, &amp;n, &amp;m, &amp;nowst, &amp;nowed); st = n + 1, ed = n + 2; for (int i = 1, u, v, lower, upper; i &lt;= m; i++) { scanf(&quot;%lld %lld %lld %lld&quot;, &amp;u, &amp;v, &amp;lower, &amp;upper); balance[u] += lower, balance[v] -= lower, base[i] = lower; AddEdge(u, v, upper - lower); } for (int i = 1; i &lt;= n; i++) { if (balance[i] &gt; 0) { sum += balance[i]; AddEdge(i, ed, balance[i]); } else { AddEdge(st, i, -balance[i]); } } AddEdge(nowed, nowst, INF); while (bfs(st)) { while ((tmp = dinic(st, INF))) ans += tmp; } if (ans &lt; sum) { printf(&quot;please go home to sleep\\n&quot;); } else { st = nowed, ed = nowst, ans = 0; // printf(&quot;%lld\\n&quot;, ans); while (bfs(st)) { while ((tmp = dinic(st, INF))) ans += tmp; } printf(&quot;%lld\\n&quot;, INF - ans); } return 0;} $\\mathcal{Way \\ 2}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 2e5 + 5;const int MAXM = 5e5 + 5;const int INF = 1e18;int n, m, sum, ans, tmp, nowst, nowed, balance[MAXN], d[MAXN], cur[MAXN], base[MAXM];int st, ed, tot = 1, head[MAXN], edge[MAXM], nxt[MAXM], ver[MAXM];queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}void Connect(int u, int v, int lower, int upper) { AddEdge(u, v, upper - lower); balance[u] += lower, balance[v] -= lower;}bool bfs(int st) { while (!q.empty()) q.pop(); memset(d, 0, sizeof(d)); d[st] = 1, q.push(st), cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v]) continue; d[v] = d[u] + 1, cur[v] = head[v]; q.push(v); if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow; for (int i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; int k = dinic(v, min(res, edge[i])); if (!k) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k, res -= k; cur[u] = i; } return flow - res;}signed main() { // freopen(&quot;7.in&quot;, &quot;r&quot;, stdin); scanf(&quot;%lld %lld %lld %lld&quot;, &amp;n, &amp;m, &amp;nowst, &amp;nowed); st = n + 1, ed = n + 2; for (int i = 1, u, v, lower, upper; i &lt;= m; i++) { scanf(&quot;%lld %lld %lld %lld&quot;, &amp;u, &amp;v, &amp;lower, &amp;upper); Connect(u, v, lower, upper); } for (int i = 1; i &lt;= n; i++) { if (balance[i] &gt; 0) { sum += balance[i]; AddEdge(i, ed, balance[i]); } else { AddEdge(st, i, -balance[i]); } } while (bfs(st)) while ((tmp = dinic(st, INF))) ans += tmp; Connect(nowed, nowst, 0, INF); while (bfs(st)) while ((tmp = dinic(st, INF))) ans += tmp; if (ans &lt; sum) { printf(&quot;please go home to sleep\\n&quot;); } else { printf(&quot;%d\\n&quot;, edge[tot]); } return 0;}","link":"/2022/01/03/2022-01-03-%E6%9C%89%E6%BA%90%E6%B1%87%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E6%9C%80%E5%B0%8F%E6%B5%81/"},{"title":"「Note」扩展欧拉定理","text":"真是令人自闭。 $\\mathcal{Theorem}$$$a^x\\equiv\\begin{cases}a^{x\\bmod\\varphi(m)} &amp; (a,m)=1 \\a^{x\\bmod\\varphi(m)+\\varphi(m)} &amp; (a,m)\\neq1,x\\ge\\varphi(m)\\end{cases}\\pmod m$$ $\\mathcal{Pro}$writing… $\\mathbb{CF17D \\ Notepad}$$\\mathcal{Link}$link $\\mathcal{Sol}$就是求 $b ^ {n - 1} \\times (b - 1) \\ \\mathrm{mod} \\ c$。那么套上去就行。 $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;int b, n, c, phi, tmp, ans, flag;string bs, ns;void read(int&amp; x, int Mod, string str) { flag = 0; for (int i = 0; i &lt; str.length(); i++) x = ((x &lt;&lt; 3) + (x &lt;&lt; 1) + (str[i] ^ 48)), flag |= (x &gt;= Mod), x %= Mod; }int qpow(int x, int y, int Mod) { int res = 1; while (y) { if (y &amp; 1) res = res * x % Mod; x = x * x % Mod, y &gt;&gt;= 1; } return res;}signed main() { cin &gt;&gt; bs &gt;&gt; ns &gt;&gt; c, tmp = phi = c, read(b, c, bs); for (int i = 2; i * i &lt;= tmp; i++) if (tmp % i == 0) { phi = phi / i * (i - 1); while (tmp % i == 0) tmp /= i; } if (tmp &gt; 1) phi = phi / tmp * (tmp - 1); read(n, phi, ns); ans = ((b - 1) * qpow(b, (n - 1) % phi + flag * phi, c) % c + c) % c; printf(&quot;%lld\\n&quot;, ans ? ans : c); return 0;}","link":"/2022/01/11/2022-01-11-%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"},{"title":"「Note」关于斜率优化维护内容的推导","text":"追求乱搞科学严谨证明，拒绝对于 不等号方向 与 单调 队列 / 栈 的排列组合。 哈哈哈，今天上台直接乱说，好像以前都是盲猜单调队列维护下凸壳过的。。。 约定对于一般形式 $T(j_1, j_2) \\le /\\geq g(i)$ 中 $g(i)$ 有单调性的情况进行讨论。结合图像还是很清晰的。 $\\mathrm{I}. \\ T(j_1, j_2) \\le g(i), g(i) \\uparrow$$g(i)$ 斜率一直变大，最优的决策点即是让 $g(i)$ 在 $y$ 轴上截距最小，移动过程中发现 $j_4$ 显然不可能成为决策点。所以应该维护一个下凸壳。于是我们维护的数据结构里的东西满足下面的关系。$T(j_1, j_2) \\le T(j_2, j_3) \\le T(j_4, j_5) \\le \\dots \\le T(j_{k - 1}, j_k) \\le g(i)$。那么可以发现，越靠前的决策点越不可能成为切点，于是我们应该从头将决策点弹出，所以是单调队列。 $\\mathrm{II}. \\ T(j_1, j_2) \\le g(i), g(i) \\downarrow$$g(i)$ 斜率一直变小，最优的决策点即是让 $g(i)$ 在 $y$ 轴上截距最小，移动过程中发现 $j_4$ 显然不可能成为决策点。所以应该维护一个下凸壳。于是我们维护的数据结构里的东西满足下面的关系。$T(j_1, j_2) \\le T(j_2, j_3) \\le T(j_4, j_5) \\le \\dots \\le T(j_{k - 1}, j_k) \\le g(i)$。然后看出来在 $g(i)$ 一开始时，斜率很大 $j_3$ 是一个很优的决策点，但是当斜率变小之后，在 $j_3$ 之前的 $j_2$ 会优于 $j_3$，这时从尾把 $j_3$ 弹出，可以看出，斜率变得更小时，$j_3$ 只会更劣，弹出 $j_3$ 不影响正确性，所以我们应该维护一个单调栈。 $\\mathrm{III}. \\ T(j_1, j_2) \\ge g(i), g(i) \\uparrow$$g(i)$ 斜率一直变大，最优的决策点即是让 $g(i)$ 在 $y$ 轴上截距最大，移动过程中发现 $j_2$ 显然不可能成为决策点。所以应该维护一个上凸壳。于是我们维护的数据结构里的东西满足下面的关系。$T(j_1, j_2) \\ge T(j_2, j_3) \\ge T(j_4, j_5) \\ge \\dots \\ge T(j_{k - 1}, j_k) \\ge g(i)$。观察图像可以发现，在斜率比较小的时候，$j_3$ 是一个很优的决策点，但是当斜率变大时，前面的 $j_4$ 会替代掉 $j_3$，并且我们可以肯定，在斜率越来越大时，$j_4$ 一定优于 $j_3$，所以可以把 $j_3$ 从尾部弹出，我们应该维护一个单调栈。 $\\mathrm{IV}. \\ T(j_1, j_2) \\ge g(i), g(i) \\downarrow$$g(i)$ 斜率一直变小，最优的决策点即是让 $g(i)$ 在 $y$ 轴上截距最大，移动过程中发现 $j_2$ 显然不可能成为决策点。所以应该维护一个上凸壳。于是我们维护的数据结构里的东西满足下面的关系。$T(j_1, j_2) \\ge T(j_2, j_3) \\ge T(j_4, j_5) \\ge \\dots \\ge T(j_{k - 1}, j_k) \\ge g(i)$。可以看到，斜率很大时 $j_1$ 是最优的，当斜率在变小后，右上角的 $j_4$ 会比 $j_1$ 更优，并且在斜率不断变小中，$j_4$ 永远比 $j_1$ 优。","link":"/2022/01/28/2022-01-28-%E5%85%B3%E4%BA%8E%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E7%BB%B4%E6%8A%A4%E5%86%85%E5%AE%B9%E7%9A%84%E6%8E%A8%E5%AF%BC/"},{"title":"「Note」后缀数组","text":"上课直接听晕过去。。。 $\\mathbb{Problem}$给定一个字符串，要求对其所有的后缀进行排序。朴素做法直接是按字典序写一个 cmp 函数，但是两两之间比较的复杂度会飙升到 $\\Theta(n)$，sort 一遍下来是 $\\Theta(n ^ 2 log_2^n)$ 的时间复杂度，显然不够优，此时可以引进 后缀数组 求解。 $\\mathbb{Definitions}$后缀数组 $\\mathtt{Suffix Array}$ 由两个主要的数组组成。一个是 后缀编号 $\\mathtt{sa}$ ，一个是 数组排名 $\\mathtt{rnk}$。 其实是顾名思义， $\\mathtt{sa_i}$ 表示 排名为 $i$ 的后缀的编号， $\\mathtt{rnk_i}$ 表示 编号为 $i$ 的后缀的排名。表示可能和课上略有所出入，最终目的是便于理解。 $\\mathbb{Build}$思想和 基数排序 类似。如果不会基排，其实也无所谓。 既然提到 基数排序 和 上面的 朴素做法， 那么可以考虑对于 $\\Theta(n ^ 2 log_2^n)$ 的算法进行优化。 这里直接给出做法。 当时上课时看到就傻了，这个倍增是个什么鬼哟？ 其实 ppt 上有一句 利用上一轮比较的结果 也不难想到对于后缀 $[i, n]$ 的长度为 $len$ 的前缀实际上相当于 后缀 $[i + 2, n]$ 的长度为 $\\frac{len}{2}$ 的前缀 拼上 后缀 $[i + 4, n]$ 的长度为 $\\frac{len}{2}$ 的前缀。 而这两个前缀的信息已经在上一层处理过，那么可以直接拿来用。 说着确实很玄，放一张 oi-wiki 上的图应该就很清晰了。 $\\mathbb{Code}$123int n, m, w[MAXN], sa[MAXN], now[MAXN], rnk[MAXN], tmp[MAXN];char s[MAXN];// w[i] 记录当前排名为 &lt;= i 的后缀个数, now 和 tmp 是 未成形的 sa 和 rnk 123456void init(int n, int m) { // n 是 |string|, m 是字符集大小 // w[i] 记录当前排名为 &lt;= i 的后缀个数，所有最后来了一边前缀和 for (int i = 1; i &lt;= m; i++) w[i] = 0; for (int i = 1; i &lt;= n; i++) w[rnk[i]]++; for (int i = 2; i &lt;= m; i++) w[i] += w[i - 1];} 12// 功能是排序装桶（对于当前）void push_in(int n) { for (int i = n; i &gt;= 1; i--) sa[w[rnk[now[i]]]--] = now[i]; } 1234567891011121314151617181920void Sa(int n, int m) { for (int i = 1; i &lt;= n; i++) rnk[i] = s[i], now[i] = i; // 进行第一次单字符排序 init(n, m), push_in(n); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { // 当前比较长度为 len * 2 int pos = 0; init(n, m); // 每次要重新计算桶的大小 for (int i = n - len + 1; i &lt;= n; i++) now[++pos] = i; // 如果倍增后 len + i 爆出去了，相当于低位补空，直接排在前面 for (int i = 1; i &lt;= n; i++) if (sa[i] &gt; len) now[++pos] = sa[i] - len; // 拼 计算 now push_in(n), memcpy(tmp, rnk, sizeof(rnk)), pos = 0; for (int i = 1; i &lt;= n; i++) { if (tmp[sa[i]] != tmp[sa[i - 1]] || tmp[sa[i] + len] != tmp[sa[i - 1] + len]) pos++; // 拼 rnk[sa[i]] = pos; // 标记排名 } m = pos; // 重新分配桶的空间 }}","link":"/2022/01/24/2022-01-24-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"},{"title":"「Note」离散概率 复习","text":"Just a review. 离散概率 $\\mathtt{discrete \\ probability}$离散 $\\mathtt{discrete}$，即是非连续性，意味着不用微积分而只用和式即可以计算。对于这类可直接用和式计算的概率，就称为 离散概率。 定义 $\\mathtt{definitions}$如同函数有定义域一样，先给出概率的“定义域”，即是 概率空间 $\\mathtt{probability \\ space}$，概率空间是指由在一个给定问题中能发生的所有事件，以及赋予每个 基本事件 $\\mathtt{elementrary \\ event}$ $\\omega \\in \\Omega$ 一个概率 $\\mathrm{Pr(\\omega)}$ 的规则所组成的集合 $\\Omega$。 上面的定义提到了 事件 $\\mathtt{event}$，一个 事件 即是 $\\Omega$ 的一个子集，我们把 $\\Omega$ 中的每一个单元素 $\\omega$ 成为 $\\Omega$ 的一个 基本事件 。 再对于上述的所有定义给出限制（即是满足的公理） 非负性: $\\forall \\ \\omega \\in \\Omega, \\ \\ \\mathrm{Pr(\\omega)} \\in [0, 1]$ 规范性: $\\sum_\\limits{\\omega \\in \\Omega} \\mathrm{Pr(\\omega)} = 1$ 可加性: $\\exists X,Y \\in \\Omega, X \\cap Y = \\varnothing \\rightarrow \\mathrm{Pr(X \\cup Y)} = \\mathrm{Pr(X)} + \\mathrm{Pr(Y)}$ 再定义 随机变量 $\\mathtt{random \\ variable}$ 是定义在 基本事件 $\\omega$ 上 函数 。形象化地理解，当基本事件 为 $\\mathtt{\\omega}$ 时，对应的随机变量取值 $\\alpha$。 独立性 $\\mathtt{independent}$现在对 独立性 $\\mathtt{independent}$ 进行定义。$\\exists X,Y \\in \\Omega, \\mathrm{Pr(X \\cap Y)} = \\mathrm{Pr(X) \\times Pr(Y)}$ 则称事件 $X$ 和事件 $Y$ 是独立的。如果有多个事件 $X_{1 \\dots n}$ 组成集合 $C$ ，若 $\\mathrm{Pr(\\bigcap_\\limits{A \\subseteq C} A)} = \\prod_\\limits{A \\subseteq C} \\mathrm{Pr(A)} , \\forall \\ A \\subseteq C$，则称 $X_{1 \\dots n}$是互相独立的。 $\\mathtt{an \\ example \\ between \\ definitions }$抛骰子太复杂了，可以举抛硬币的例子。 发生的动作是 把一枚硬币抛两次。 概率空间 是 ${ HH, HT, TH, TT }$。可以令事件 $A = { HH, HT }$， $B = { HH, TH }$， $C = { HH, TT }$。$\\mathrm{A \\cap B = A \\cap C = B \\cap C} = \\mathrm{A \\cap B \\cap C} = {HH, TT}$。可知 $\\mathrm{Pr(A) = Pr(B) = Pr(C) = \\frac{1}{2}}$，$\\mathrm{Pr(A \\cap B) = Pr(A) \\times Pr(B) = Pr(A \\cap C) = Pr(A) \\times Pr(C) = Pr(B \\cap C)} = Pr(B) \\times Pr(C) = \\frac{1}{4}$则事件 $A, B$ 两两独立，$A, C$ 两两独立，$B, C$ 两两独立。可知 $\\mathrm{Pr(A \\cap B \\cap C)} = \\frac{1}{4} \\neq Pr(A) \\times Pr(B) \\times Pr(C)$。则事件 $A, B, C$ 并不互相独立。 期望 $\\mathtt{expected \\ value}$先引入 均值 $\\mathtt{mean}$，它是所有值的和除以值的个数。 如果我们去计算 概率空降 上某个 随机变量 $X$ 的 均值 , 可以得到下面的式子。$$\\sum_\\limits{x \\in X(\\Omega)} x \\times \\mathrm{Pr}(X = x)$$此处的 $X(\\Omega)$ 表示使","link":"/2022/01/12/2022-01-12-%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87%20%E5%A4%8D%E4%B9%A0/"},{"title":"「Solution」诗人小G题解","text":"这题和斜率优化放一起就很离谱 $\\mathcal{Link}$link $\\mathcal{Sol}$题目已经很清楚了，不难想到一个朴素的 dp。定义 $sum_i$ 为诗句长度的前缀和， $dp_i$ 为以 $i$ 结尾，已经排版好的诗歌的不和谐度。 则有$$dp_i = \\min{ dp_j + | sum_i - sum_j + i - j - 1 - l | ^ p \\mid 0 \\le j &lt; i }$$这样是一个 $\\mathcal{O(n^2)}$ 的时间复杂度。 打满有 30pts 。 看到 $n \\le 1e5$ ，意味着 $\\mathcal{O(n)}$ 或 $\\mathcal{O(n \\log n)}$ 这样的时间复杂度比较正确。 其实分析数据范围都能猜到这道题的决策大概率是有单调性的。 结论是这道题确实有决策单调性的性质。 $\\mathcal{Pro}$对于两个决策点 $i&lt;j$ ，有且仅有一个划分点 $k$， 当决策点 $k’ &gt; k$ 时 $j$ 优于 $i$ ，当决策点 $k’ &lt; k$ 时 $i$ 优于 $j$ 。 我们定义以 $k$ 为决策点的函数为 $g_k$ 。 那么 $g_k(i) = dp_k + \\mid sum_i - sum_k + i - k - 1 - l\\mid ^ p$ 。 可以看到 $g_k(i)$ 以 $sum_k + k + 1 + l$ 为对称轴，且 $p$ 是定值，$sum_i + i$ 单调递增。 如果你把中间的 $sum_i + i$ 视作连续的，或者干脆把 $sum_i + i$ 换成 $i$ ，那么这一堆函数是可以通过平移转化的。 在满足函数间能平移转换后，就可以保证两两之间只有一个交点。 $\\mathcal{Code}$重点在如何套路化地写这种决策单调性的题。 那么把每个点作为决策点可以找的属于它的决策区间。 可以用一个结构体保存决策区间的信息。 123struct Node { int l, r, pos;} q[MAXN]; 首先初始化，塞一个决策点 0 ，决策区间是 [1, n] 。 1head = 1, tail = 0, q[++tail] = Node{1, n, 0}; 对于每个当前点，首先计算当前的 dp[i] 值。 这时检查队头，如果队首元素的决策区间的右端点够不到当前点（就是说当前点不会队首元素更新）， q[tail].r &lt; i ，那么就弹掉它。等拿到可行的队首后，用队首元素计算 dp[i] 。 考虑加入当前的决策点 i 。 从后往前考虑，如果当前决策点对队尾元素的左区间比队尾元素的决策点对队尾元素的左区间更优，直接弹掉队尾。换句话说，当前决策点的 “管辖范围” 比队尾的更广，能更快地把队尾更前面的决策点顶掉。 1while (head &lt; tail &amp;&amp; cal(q[tail].l, i) &lt;= cal(q[tail].l, q[tail].pos)) tail--; 在不断弹出队尾后，会发现一个情况，当前决策点管不到队尾的左端点，但是对于队尾的右端点来说，当前的决策点会更优。也就是队尾的 “管辖范围” 需要割开。 因为已知单调性，所以可以对 [q[tail].l, q[tail].r] 这段区间进行二分，找到划分点，最后加入当前的决策点的决策区间即可。 12345678910int l = q[tail].l, r = q[tail].r;while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (cal(mid, q[tail].pos) &gt; cal(mid, i)) r = mid - 1; else l = mid;}if (l &gt; q[tail].l) q[tail].r = l;else tail--;q[++tail] = Node{l, n, i}; 给个完整代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LD long doubleusing namespace std;const int MAXN = 1e5 + 5;const long long INF = 1e18;char poe[30];int t, n, p, head, tail;LD l, sum[MAXN], dp[MAXN];LD qpow(LD x, int y) { LD res = 1; while (y) { if (y &amp; 1) res = res * x; x = x * x; y &gt;&gt;= 1; } return res;}struct Node { int l, r, pos; } q[MAXN];LD Abs(LD num) { return num &lt; 0 ? -num : num; }LD cal(int y, int x) { if (y &gt; x) swap(x, y); return dp[y] + qpow(Abs(sum[x] - sum[y] + x - y - 1 - l), p);}int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d %Lf %d&quot;, &amp;n, &amp;l, &amp;p); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%s&quot;, poe); sum[i] = sum[i - 1] + strlen(poe); } head = 1, tail = 0, q[++tail] = Node{1, n, 0}; for (int i = 1; i &lt;= n; i++) { while (head &lt; tail &amp;&amp; q[head].r &lt; i) head++; int j = q[head].pos; dp[i] = cal(j, i); while (head &lt; tail &amp;&amp; cal(q[tail].l, i) &lt;= cal(q[tail].l, q[tail].pos)) tail--; int l = q[tail].l, r = q[tail].r; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; // printf(&quot;%d %d %d %d\\n&quot;, i, l, mid, r); if (cal(mid, q[tail].pos) &gt; cal(mid, i)) r = mid - 1; else l = mid; } if (l &gt; q[tail].l) q[tail].r = l; else tail--; q[++tail] = Node{l, n, i}; // printf(&quot;dp[%d] = %.0Lf\\n&quot;, i, dp[i]); } if (dp[n] &gt; INF) { printf(&quot;Too hard to arrange\\n&quot;); } else { printf(&quot;%.0Lf\\n&quot;, dp[n]); } printf(&quot;--------------------\\n&quot;); } return 0;}","link":"/2022/02/06/2022-02-06-%E8%AF%97%E4%BA%BA%E5%B0%8FG%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」拦截导弹","text":"我爱调代码 $\\mathcal{Link}$link $\\mathcal{Sol}$定义 $f_0(i)$ 为以 $i$ 为终点的最长上升子序列的长度， $g_0(i)$ 为 $f_0$ 的个数。同样地，定义 $f_1(i)$ 为以 $i$ 为起点的最长上升子序列的长度， $g_1(i)$ 为 $f_1$ 的个数。那么记方案总数为 $tot$ ，第二问的答案即是 $\\frac{g_0(i) \\times g_1(i)}{tot}$暴力转是 $\\mathcal{O}(n^2)$ 的。因为是个三维的偏序，可以用 cdq 来优化。代码要想清楚再写，注意细节，手不要乱抖。。。 $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 5e5 + 5;int n, m, cnt, maxl, num[MAXN], f[MAXN][3];double g[MAXN][3], tot;struct Node { int h, v, t; } a[MAXN];map&lt;int, int&gt; h;// 线段树维护区间最大值以及最大值的个数struct Result { int f; double g; };struct SegmentTree { int l, r, dat; double sum; } s[MAXN &lt;&lt; 2];void push_up(int p) { s[p].dat = max(s[p &lt;&lt; 1].dat, s[p &lt;&lt; 1 | 1].dat), s[p].sum = 0; if (s[p &lt;&lt; 1].dat == s[p].dat) s[p].sum += s[p &lt;&lt; 1].sum; if (s[p &lt;&lt; 1 | 1].dat == s[p].dat) s[p].sum += s[p &lt;&lt; 1 | 1].sum;}void clear(int p) { if (s[p].dat == 0) return; s[p].dat = 0, clear(p &lt;&lt; 1), clear(p &lt;&lt; 1 | 1), push_up(p);}void build(int p, int l, int r) { s[p].l = l, s[p].r = r; if (l == r) { s[p].dat = 0, s[p].sum = 0; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid), build(p &lt;&lt; 1 | 1, mid + 1, r); push_up(p);}void update(int p, int x, int val, double num) { if (s[p].l == s[p].r) { if (val == s[p].dat) s[p].sum += num; else if (val &gt; s[p].dat) s[p].dat = val, s[p].sum = num; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (x &lt;= mid) update(p &lt;&lt; 1, x, val, num); else update(p &lt;&lt; 1 | 1, x, val, num); push_up(p);}Result query(int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) { return Result{s[p].dat, s[p].sum}; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; Result res = {0, 0}, tmp1 = {0, 0}, tmp2 = {0, 0}; if (l &lt;= mid) tmp1 = query(p &lt;&lt; 1, l, r); if (r &gt; mid) tmp2 = query(p &lt;&lt; 1 | 1, l, r); res.f = max(tmp1.f, tmp2.f); res.g += (res.f == tmp1.f) * tmp1.g + (res.f == tmp2.f) * tmp2.g; return res;}void cdq(int l, int r, int opt) { if (l == r) return; int mid = (l + r) &gt;&gt; 1, pos = l; sort(a + l, a + r + 1, [](const Node&amp; x, const Node&amp; y) { return x.t &lt; y.t; }); cdq(l, mid, opt); // 注意要算完左边的贡献后立即与右边合并，保证转移从左向右不中断 sort(a + l, a + mid + 1, [](const Node&amp; x, const Node&amp; y) { return (x.h == y.h) ? x.t &lt; y.t : x.h &gt; y.h; }); sort(a + mid + 1, a + r + 1, [](const Node&amp; x, const Node&amp; y) { return (x.h == y.h) ? x.t &lt; y.t : x.h &gt; y.h; }); clear(1); for (int i = mid + 1; i &lt;= r; i++) { while (pos &lt;= mid &amp;&amp; a[pos].h &gt;= a[i].h) update(1, a[pos].v, f[a[pos].t][opt], g[a[pos].t][opt]), pos++; // 第一遍居然把 a[pos].v 写成了 a[pos].t 。。。 Result res = query(1, a[i].v, n); if (!res.f) continue; // dp 转移最大值 if (f[a[i].t][opt] == res.f + 1) g[a[i].t][opt] += res.g; else if (f[a[i].t][opt] &lt; res.f + 1) f[a[i].t][opt] = res.f + 1, g[a[i].t][opt] = res.g; // printf(&quot;--%d %d\\n&quot;, a[i].t, g[a[i].t][opt]); } cdq(mid + 1, r, opt); // 开始写掉了。。。}signed main() { scanf(&quot;%lld&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld %lld&quot;, &amp;a[i].h, &amp;a[i].v), a[i].t = i, num[i] = a[i].v, m = max(m, a[i].h); sort(num + 1, num + 1 + n); for (int i = 1; i &lt;= n; i++) if (num[i] != num[i - 1]) h[num[i]] = ++cnt; for (int i = 1; i &lt;= n; i++) a[i].v = h[a[i].v], f[i][0] = f[i][1] = 1, g[i][0] = g[i][1] = 1.0; build(1, 1, n), cdq(1, n, 0); for (int i = 1; i &lt;= n; i++) a[i].v = cnt - a[i].v + 1, a[i].h = m - a[i].h + 1, a[i].t = n - a[i].t + 1; sort(a + 1, a + 1 + n, [](const Node&amp; x, const Node&amp; y) { return x.t &lt; y.t; }); for (int i = 1; i &lt;= n; i++) maxl = max(maxl, f[i][0]); printf(&quot;%lld\\n&quot;, maxl); build(1, 1, n), cdq(1, n, 1); for (int i = 1; i &lt;= n; i++) tot += (f[i][0] == maxl) * g[i][0]; // for (int i = 1; i &lt;= n; i++) { // printf(&quot;%d %d\\n&quot;, g[i][0], g[i][1]); // } // printf(&quot;%d\\n&quot;, tot); for (int i = 1; i &lt;= n; i++) { if (f[i][0] + f[n - i + 1][1] - 1 != maxl) printf(&quot;0 &quot;); else printf(&quot;%.6lf &quot;, g[i][0] * (g[n - i + 1][1] / tot)); } return 0;}","link":"/2022/02/06/2022-02-12-%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」cdq斜率优化","text":"All in one. $\\mathcal{Template}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#define LL long longusing namespace std;const int MAXN = 1e5 + 5;const LL INF = 1e18;int n, que[MAXN];struct Node { int ind; LL x, y; } a[MAXN], tmp[MAXN];long double K(int x, int y) { if (a[x].x == a[y].x) { if (a[x].y &lt; a[y].y) return INF; else return -INF; } return ((long double)(a[y].y - a[x].y) / (long double)(a[y].x - a[x].x));}void cdq(int l, int r) { if (l == r) { a[l].y = /**/; return; } int mid = (l + r) &gt;&gt; 1; for (int i = l, p = l, q = mid + 1; i &lt;= r; i++) { if (a[i].ind &lt;= mid) tmp[p++] = a[i]; else tmp[q++] = a[i]; } for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; cdq(l, mid); int head = 1, tail = 0; for (int i = l; i &lt;= mid; i++) { while (head &lt; tail &amp;&amp; K(que[tail - 1], que[tail]) &gt;= / &lt;= K(que[tail - 1], i)) tail--; que[++tail] = i; } for (int i = mid + 1; i &lt;= r; i++) { while (head &lt; tail &amp;&amp; K(que[head], que[head + 1]) &gt;= / &lt;= /**/) head++; int j = que[head]; dp[a[i].ind] = /**/; } cdq(mid + 1, r); int p = l, q = mid + 1, pos = l; while (p &lt;= mid &amp;&amp; q &lt;= r) { if (a[p].x &lt; a[q].x) tmp[pos++] = a[p++]; else tmp[pos++] = a[q++]; } while (p &lt;= mid) tmp[pos++] = a[p++]; while (q &lt;= r) tmp[pos++] = a[q++]; for (int i = l; i &lt;= r; i++) a[i] = tmp[i];} $\\mathcal{Building \\ Bridges}$$\\mathcal{Link}$link $\\mathcal{Sol}$方程直接一眼: 记 $w_i$ 的前缀和为 $sum_i$ 。$$\\begin{aligned}dp_i &amp;= dp_j + (sum_{i-1} - sum_j) + (h_i - h_j) ^ 2 \\ &amp;= dp_j + sum_{i-1} - sum_j + h_i^2 + h_j^2 - 2h_ih_j\\end{aligned}$$然后假设 $k_1$ 比 $k_2$ 更优。那么$$\\begin{aligned}dp_{k_1} + sum_{i-1} - sum_{k_1} + h_i^2 + h_{k_1}^2 - 2h_ih_{k_1} &amp;&lt; dp_{k_2} + sum_{i-1} - sum_{k_2} + h_i^2 + h_{k_2}^2 - 2h_ih_{k_2} \\\\rightarrow dp_{k_1} - dp_{k_2} - sum_{k_1} + sum_{k_2} + h_{k_1}^2 - h_{k_2}^2 - 2h_ih_{k_1} + 2h_ih_{k_2} &amp;&lt; 0 \\dp_{k_1} - dp_{k_2} - sum_{k_1} + sum_{k_2} + h_{k_1}^2 - h_{k_2}^2 &amp;&lt; 2h_ih_{k_1} - 2h_ih_{k_2} \\\\frac{(dp_{k_1} - sum_{k_1} + h_{k_1}^2) - (dp_{k_2} - sum_{k_2} + h_{k_2}^2)}{h_{k_1} - h_{k_2}} &amp;&lt; 2h_i\\end{aligned}$$这是个下凸壳。结果发现 $h_i$ 没有单调性。带进来就是说 $x$ 和 $k$ 都没有单调性。所以要用 cdq 来维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 1e5 + 5;const LL INF = 1e18;int n, que[MAXN];LL h[MAXN], w[MAXN], sum[MAXN], dp[MAXN];struct Node { int ind; LL x, y; } a[MAXN], tmp[MAXN];long double K(int x, int y) { if (a[x].x == a[y].x) { if (a[x].y &lt; a[y].y) return INF; else return -INF; } return ((long double)(a[y].y - a[x].y) / (long double)(a[y].x - a[x].x));}void cdq(int l, int r) { if (l == r) { a[l].y = dp[a[l].ind] - sum[a[l].ind] + h[a[l].ind] * h[a[l].ind]; return; } int mid = (l + r) &gt;&gt; 1; for (int i = l, p = l, q = mid + 1; i &lt;= r; i++) { if (a[i].ind &lt;= mid) tmp[p++] = a[i]; else tmp[q++] = a[i]; } for (int i = l; i &lt;= r; i++) a[i] = tmp[i]; cdq(l, mid); int head = 1, tail = 0; for (int i = l; i &lt;= mid; i++) { while (head &lt; tail &amp;&amp; K(que[tail - 1], que[tail]) &gt;= K(que[tail - 1], i)) tail--; que[++tail] = i; } for (int i = mid + 1; i &lt;= r; i++) { // if (a[i].ind == 5) { // printf(&quot;debug\\n&quot;); // } while (head &lt; tail &amp;&amp; K(que[head], que[head + 1]) &lt;= 2 * h[a[i].ind]) head++; int j = que[head]; dp[a[i].ind] = min(dp[a[i].ind], dp[a[j].ind] + (sum[a[i].ind - 1] - sum[a[j].ind]) + (h[a[i].ind] - h[a[j].ind]) * (h[a[i].ind] - h[a[j].ind])); // printf(&quot; dp[%d] = %d %d\\n&quot;, a[i].ind, dp[a[i].ind], a[j].ind); } cdq(mid + 1, r); int p = l, q = mid + 1, pos = l; while (p &lt;= mid &amp;&amp; q &lt;= r) { if (a[p].x &lt; a[q].x) tmp[pos++] = a[p++]; else tmp[pos++] = a[q++]; } while (p &lt;= mid) tmp[pos++] = a[p++]; while (q &lt;= r) tmp[pos++] = a[q++]; for (int i = l; i &lt;= r; i++) a[i] = tmp[i];}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;h[i]); dp[i] = INF, a[i].x = h[i], a[i].ind = i; } dp[1] = 0; for (int i = 1; i &lt;= n; i++) { scanf(&quot;%lld&quot;, &amp;w[i]), sum[i] = sum[i - 1] + w[i]; } sort(a + 1, a + 1 + n, [](const Node&amp; x, const Node&amp; y) { return x.x &lt; y.x; }); cdq(1, n); printf(&quot;%lld\\n&quot;, dp[n]); return 0;} $\\mathcal{BZOJ4700. 适者}$$\\mathcal{Link}$link $\\mathcal{Sol}$先考虑没有开局双杀这个操作时的答案。基本的贪心思路，考虑相邻的两个敌人， $(d_1,a_1)$ 和 $(d_2,a_2)$ 。不交换攻击顺序时造成的代价为 $a_1 \\times \\frac{d_1}{atk} + a_2 \\times \\frac{d_2+d_1}{atk}$ 。如果交换，则代价为 $a_2 \\times \\frac{d_2}{atk} + a_1 \\times \\frac{d_2+d_1}{atk}$ 。如果交换后更优，则有$$\\begin{aligned} a_1 \\times \\frac{d_1}{atk} + a_2 \\times \\frac{d_2+d_1}{atk} &amp;\\le a_2 \\times \\frac{d_2}{atk} + a_1 \\times \\frac{d_2+d_1}{atk} \\ a_2 \\times \\frac{d_1}{atk} &amp;\\le a_1 \\times \\frac{d_2}{atk} \\ \\frac{a_2}{d_2} &amp;\\le \\frac{a_1}{d_1}\\end{aligned}$$那么把 $\\frac{d}{a}$ 作为关键字排序就可以算出答案。考虑开局双杀操作，你会发现，直接移除某个人后，其他的人的相对击败顺序并不会变，也就是说，可以直接计算移除某一个人后的贡献。记前缀血量 $sum_i = \\sum_{j = 1}^{i} d_i$ 。不移除人的答案是 $Ans = \\sum_{i = 1}^n \\frac{sum_i}{atk}a_i$ 当移除掉第 $j$ 个人后，分前后两部分计算$$\\begin{aligned} Ans &amp;= (\\sum_{i=1}^{j-1} \\frac{sum_i}{atk}a_i) + (\\sum_{i=j+1}^{n} \\frac{sum_i - d_j}{atk} a_i) \\ &amp;= (\\sum_{i=1}^{j-1} \\frac{sum_i}{atk}a_i) + (\\sum_{i=j+1}^{n} \\frac{sum_i}{atk} a_i) - (\\sum_{i=j+1}^{n} \\frac{d_j}{atk} a_i) \\ &amp;= (\\sum_{i = 1}^n \\frac{sum_i}{atk}a_i) - \\frac{sum_j}{atk}a_j - d_j\\sum_{i=j+1}^{n} \\frac{a_i}{atk}\\end{aligned}$$可以看到改变的值为 $\\frac{sum_j}{atk}a_j + d_j\\sum_{i=j+1}^{n} \\frac{a_i}{atk}$ 。如果再干掉一个人，假设位置为 $k (k &gt; j)$ 。他会改变 $\\frac{sum_k - d_j}{atk}a_k + d_k\\sum_{i=k+1}^{n} \\frac{a_i}{atk}$ 。把两次操作合在一起得到$$\\begin{aligned} Ans = (\\sum_{i = 1}^n \\frac{sum_i}{atk}a_i) - (\\frac{sum_j}{atk}a_j + d_j\\sum_{i=j+1}^{n} \\frac{a_i}{atk}) - (\\frac{sum_k - d_j}{atk}a_k + d_k\\sum_{i=k+1}^{n} \\frac{a_i}{atk})\\end{aligned}$$然后可以莽一个 $\\mathcal{O}(n^2)$ 的暴力 dp 。可以直接预处理出所有的单杀局面，记为 $dp_{i, 0}$ 。然后考虑双杀局面 $dp_{i, 1}= \\min_{j=1}^{i-1} {dp_{j, 0} - \\frac{sum_i - d_j}{atk}a_i - d_i\\sum_{k = i + 1}^n \\frac{a_k}{atk}}$ 。看起来可以优化。记 $g_i = \\sum_{j = i + 1}^n \\frac{a_j}{atk}$ ，假设两个决策点 $k_1$ , $k_2$ , 如果 $k_1$ 优于 $k_2$ 。$$\\begin{aligned} dp_{k_1, 0} - \\frac{sum_i - d_{k_1}}{atk}a_i - d_i g(i) &amp;\\le dp_{k_2, 0} - \\frac{sum_i - d_{k_2}}{atk}a_i - d_ig(i) \\ dp_{k_1, 0} - dp_{k_2, 0} &amp;\\le \\frac{d_{k_2} - d_{k_1}}{atk} a_i \\\\end{aligned}$$结果发现 $d_{k_2} - d_{k_1}$ 正负不定，挪不过去。就强制写一个 cdq 。 1","link":"/2022/02/13/2022-02-13-cdq%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"title":"「Solution」Mobius &amp; Dirichlet Solution Set","text":"All in one… updating… $\\mathcal{Theorem}$$$[\\gcd(i, j) = 1] = \\sum_{d | \\gcd(i, j)} \\mu(d)$$ $\\mathbb{完全平方数}$$\\mathcal{Link}$link $\\mathcal{Sol}$二分 + 莫比乌斯函数$$Ans = \\sum_{i = 1}^{\\sqrt{n}} \\lfloor \\frac{n}{i^2} \\rfloor$$ $\\mathcal{Code}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 1e5 + 5;int t, n, cnt, mu[MAXN], pr[MAXN];LL l, r, mid;bool vis[MAXN];void Euler() { mu[1] = 1; for (int i = 2; i &lt;= 1e5; i++) { if (!vis[i]) { pr[++cnt] = i, mu[i] = -1; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= 1e5; j++) { vis[pr[j] * i] = 1; if (i % pr[j] == 0) { mu[i * pr[j]] = 0; break; } mu[i * pr[j]] = -mu[i]; } }}int count(LL x) { int sum = 0; for (int i = 1; i * i &lt;= x; i++) { sum += (x / (i * i)) * mu[i]; } return sum;}int main() { Euler(); // for (int i = 2; i &lt;= 20; i++) { // printf(&quot;%d &quot;, mu[i]); // } // printf(&quot;\\n&quot;); scanf(&quot;%d&quot;, &amp;t); // printf(&quot;test %d\\n&quot;, count(19)); while (t--) { scanf(&quot;%d&quot;, &amp;n); l = 1, r = 2e9; while (l &lt; r) { mid = (l + r) &gt;&gt; 1; if (count(mid) &gt;= n) r = mid; else l = mid + 1; } printf(&quot;%lld\\n&quot;, l); } return 0;} $\\mathbb{GCD}$$\\mathcal{Link}$link $\\mathcal{Sol}$$$\\begin{aligned} &amp;\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [\\gcd(i, j) = k] \\ = &amp;\\sum_{i = 1}^{\\lfloor \\frac{n}{k} \\rfloor} \\sum_{j = 1}^{\\lfloor \\frac{m}{k} \\rfloor} [\\gcd(i, j) = 1] \\ = &amp;\\sum_{i = 1}^{\\lfloor \\frac{n}{k} \\rfloor} \\sum_{j = 1}^{\\lfloor \\frac{m}{k} \\rfloor} \\sum_{d \\mid \\gcd(i, j)} \\mu(d) \\ = &amp;\\sum_{d = 1}^{\\min(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor)} \\mu(d) \\lfloor \\frac{n}{kd} \\rfloor \\lfloor \\frac{m}{kd} \\rfloor\\end{aligned}$$然后可以直接枚举 $d$ 。 $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long long#define LL long longusing namespace std;const int MAXN = 1e5 + 5;int vis[MAXN], pr[MAXN], cnt, mu[MAXN], sum[MAXN];int a, b, c, d, k, t, cas;void Euler () { mu[1] = 1; for (int i = 2; i &lt;= 1e5; i++) { if (!vis[i]) { pr[++cnt] = i, mu[i] = -1; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= 1e5; j++) { vis[pr[j] * i] = 1; if (i % pr[j] == 0) { mu[i * pr[j]] = 0; break; } mu[i * pr[j]] = -mu[i]; } } for (int i = 1; i &lt; MAXN; i++) sum[i] = sum[i - 1] + mu[i];}signed main() { Euler (); scanf(&quot;%lld&quot;, &amp;t); while(t--) { scanf(&quot;%lld %lld %lld %lld %lld&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); if (k == 0) { printf(&quot;Case %lld: 0&quot;, ++cas); continue; } b = b / k, d = d / k; if (b &gt; d) swap(b, d); LL all, del, last, ans; all = del = 0; for (int i = 1; i &lt;= b; i = last + 1) { last = min(b / (b / i), d / (d / i)); all += (sum[last] - sum[i - 1]) * (b / i) * (d / i); } for (int i = 1; i &lt;= b; i = last + 1) { last = b / (b / i); del += (sum[last] - sum[i - 1]) * (b / i) * (b / i); } ans = all - (del / 2); printf(&quot;Case %lld: %lld\\n&quot;, ++cas, ans); } return 0;} $\\mathbb{[HAOI2011]Problem \\ b}$$\\mathcal{Link}$link $\\mathcal{Sol}$$$\\begin{aligned} &amp;\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [\\gcd(i, j) = k] \\ = &amp;\\sum_{i = 1}^{\\lfloor \\frac{n}{k} \\rfloor} \\sum_{j = 1}^{\\lfloor \\frac{m}{k} \\rfloor} [\\gcd(i, j) = 1] \\ = &amp;\\sum_{i = 1}^{\\lfloor \\frac{n}{k} \\rfloor} \\sum_{j = 1}^{\\lfloor \\frac{m}{k} \\rfloor} \\sum_{d \\mid \\gcd(i, j)} \\mu(d) \\ = &amp;\\sum_{d = 1}^{\\min(\\lfloor \\frac{n}{k} \\rfloor, \\lfloor \\frac{m}{k} \\rfloor)} \\mu(d) \\lfloor \\frac{n}{kd} \\rfloor \\lfloor \\frac{m}{kd} \\rfloor\\end{aligned}$$ 然后应该用整除分块，时间复杂度 $\\mathcal{O}(n + \\sqrt{n})$ 。 $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5e4 + 5;int t, a, b, c, d, k, pr[MAXN], cnt, ans;int mu[MAXN], sum[MAXN];bool vis[MAXN];void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}void Euler () { mu[1] = 1; for (int i = 2; i &lt;= 5e4; i++) { if (!vis[i]) { pr[++cnt] = i, mu[i] = -1; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= 5e4; j++) { vis[pr[j] * i] = 1; if (i % pr[j] == 0) { mu[i * pr[j]] = 0; break; } mu[i * pr[j]] = -mu[i]; } } for (int i = 1; i &lt; MAXN; i++) sum[i] = sum[i - 1] + mu[i];}int query (int n, int m) { if (n &gt; m) swap(n, m); int res = 0; for (int i = 1, last = 1; i &lt;= n; i = last + 1) { last = min(n / (n / i), m / (m / i)); res += (sum[last] - sum[i - 1]) * (n / (i * k)) * (m / (i * k)); } return res;}int main () { read(t); Euler (); while (t--) { read(a), read(b), read(c), read(d), read(k); ans = query (b, d) - query (a - 1, d) - query (c - 1, b) + query (a - 1, c - 1); printf (&quot;%d\\n&quot;, ans); } return 0;} $\\mathbb{YY的GCD}$$\\mathcal{Link}$link $\\mathcal{Sol}$令所有素数组成的集合为 $\\mathbb{P}$ 。 $$\\begin{aligned} &amp; \\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [\\gcd(i, j) \\in \\mathbb{P}] \\ = &amp; \\sum_{p \\in \\mathbb{P}} \\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [\\gcd(i, j) = p] \\ = &amp; \\sum_{p \\in \\mathbb{P}} \\sum_{i = 1}^{\\lfloor \\frac{n}{p} \\rfloor} \\sum_{i = 1}^{\\lfloor \\frac{n}{p} \\rfloor} [\\gcd(i, j) = 1] \\ = &amp; \\sum_{p \\in \\mathbb{P}} \\sum_{d = 1}^{\\min(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor)} \\mu(d) \\lfloor \\frac{n}{pd} \\rfloor \\lfloor \\frac{m}{pd} \\rfloor\\end{aligned}$$ 令 $pd = T$ 。$$\\begin{aligned} = &amp; \\sum_{p \\in \\mathbb{P}} \\sum_{d = 1}^{\\min(\\lfloor \\frac{n}{p} \\rfloor, \\lfloor \\frac{m}{p} \\rfloor)} \\mu(d) \\lfloor \\frac{n}{pd} \\rfloor \\lfloor \\frac{m}{pd} \\rfloor \\ = &amp; \\sum_{T = 1}^{n} \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum_{p \\mid T} \\mu(\\frac{T}{p}) \\\\end{aligned}$$ 后面的 ${p \\mid T} \\mu(\\frac{T}{p})$ 可以于预处理。然后又是喜闻乐见的整除分块。 $\\mathcal{Code}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 1e7 + 5;int t, n, m, pr[MAXN], cnt, ans;int mu[MAXN], h[MAXN];bool vis[MAXN];void Euler () { mu[1] = 1; for (int i = 2; i &lt;= 1e7; i++) { if (!vis[i]) { pr[++cnt] = i; mu[i] = -1; h[i] = 1; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= 1e7; j++) { vis[i * pr[j]] = 1; if (i % pr[j] == 0) { h[i * pr[j]] = mu[i]; mu[i * pr[j]] = 0; break; } else { h[i * pr[j]] = -h[i] + mu[i]; mu[i * pr[j]] = -mu[i]; } } h[i] += h[i - 1]; }}signed main () { scanf (&quot;%lld&quot;, &amp;t); Euler (); while (t--) { scanf (&quot;%lld %lld&quot;, &amp;n, &amp;m); if (n &gt; m) swap (n, m); ans = 0; for (int l = 1, r = 1; l &lt;= n; l = r + 1) { r = min (n / (n / l), m / (m / l)); ans = ans + (h[r] - h[l - 1]) * (n / l) * (m / l); } printf (&quot;%lld\\n&quot;, ans); } return 0;} $\\mathbb{Multiplicative Functions}$$\\mathcal{Link}$link $\\mathcal{Sol}$$$\\begin{aligned} f * f^{-1} = \\epsilon \\ f^{-1}(1) &amp;= \\frac{1}{f(1)} \\ f^{-1}(n) * f(n) &amp;= \\sum_{d \\mid n} f^{-1}(d)f(\\frac{n}{d}) \\ &amp; = f^{-1}(n)f(1) + \\sum_{d \\mid n, d \\not = n} f^{-1}(d) f(\\frac{n}{d}) \\ &amp; = \\epsilon(n) \\ &amp; = 0\\ f^{-1}(n) = -\\frac{\\sum_{d \\mid n, d \\not = n} f^{-1}(d) f(\\frac{n}{d})}{f(1)}\\end{aligned}$$ $\\mathcal{Code}$1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int Mod = 2007;const int MAXN = 1e4 + 5;int n, f[MAXN], invf[MAXN], pr[MAXN], cnt;bool vis[MAXN];void Euler() { for (int i = 1; i &lt;= n; i++) { invf[i] = (-invf[i] + Mod) % Mod; printf(&quot;%d &quot;, invf[i]); for (int j = 2; j * i &lt;= n; j++) { invf[i * j] = (invf[i * j] + f[j] * invf[i]) % Mod; } }}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;f[i]); invf[1] = -1; Euler(); return 0;} $\\mathbb{Clarke \\ and \\ math}$$\\mathcal{Link}$link $\\mathcal{Sol}$$$\\begin{aligned} 1(x) = 1 \\ g_i&amp;=\\sum_{i_1\\mid i}\\sum_{i_2 \\mid i_1}\\sum_{i_3 \\mid i_2}⋯\\sum_{i_k\\mid i_{k−1}}f(i_k) \\ &amp;=\\sum_{i_1\\mid i}\\sum_{i_2 \\mid i_1}\\sum_{i_3 \\mid i_2}⋯\\sum_{i_k\\mid i_{k−1}}f(i_k) \\times 1(\\frac{i_{k - 1}}{i_{k}}) \\ &amp;=\\sum_{j \\mid i} f(j) * 1^k \\\\end{aligned}$$ $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 1e5 + 5;const int Mod = 1e9 + 7;int t, n, k, f[MAXN], ans[MAXN], tmp[MAXN], x[MAXN];void dirichlet(int* ans, int* x) { memset(tmp, 0, sizeof(tmp)); int up = sqrt(n); for (int i = 1; i &lt;= up; i++) { tmp[i * i] = (tmp[i * i] + ans[i] * x[i] % Mod) % Mod; for (int j = i + 1; j &lt;= n / i; j++) { tmp[i * j] = (tmp[i * j] + ans[i] * x[j] % Mod) % Mod; tmp[i * j] = (tmp[i * j] + ans[j] * x[i] % Mod) % Mod; } } for (int i = 1; i &lt;= n; i++) ans[i] = tmp[i];}signed main() { scanf(&quot;%lld&quot;, &amp;t); while (t--) { scanf(&quot;%lld %lld&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;f[i]); for (int i = 1; i &lt;= n; i++) ans[i] = 0, x[i] = 1; ans[1] = 1; while (k) { if (k &amp; 1) dirichlet(ans, x); dirichlet(x, x); k &gt;&gt;= 1; } dirichlet(ans, f); for (int i = 1; i &lt;= n; i++) { printf(&quot;%lld &quot;, ans[i]); } printf(&quot;\\n&quot;); } return 0;} $\\mathbb{BZOJ4407 \\ 于神之怒加强版}$$\\mathcal{Link}$link $\\mathcal{Sol}$$$\\begin{aligned} &amp; \\sum_{i=1}^n \\sum_{j=1}^m \\gcd(i,j)^k \\ = &amp; \\sum_{g = 1}^{\\min(n, m)} g^k \\sum_{i=1}^{\\lfloor \\frac{n}{g} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{g} \\rfloor} [\\gcd(i, j) = 1] \\ = &amp; \\sum_{g}^{\\min(n, m)} g^k \\sum_{i=1}^{\\lfloor \\frac{n}{g} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{g} \\rfloor} \\sum_{d \\mid \\gcd(i, j)} \\mu(d) \\ = &amp; \\sum_{d=1}^{\\min(n, m)} \\sum_{t = 1}^{\\lfloor \\frac{n}{d} \\rfloor} dt^k \\sum_{i=1}^{\\lfloor \\frac{n}{dt} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{dt} \\rfloor} \\sum_{d \\mid \\gcd(i, j)} \\mu(d) \\\\end{aligned}$$ 令 $T = dt$ 。 $$\\begin{aligned} &amp; = \\sum_{T = 1}^{\\min(n, m)} \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum_{d \\mid T} d^k \\mu(\\frac{T}{d}) \\ &amp; = \\sum_{T = 1}^{\\min(n, m)} \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum_{d \\mid T} id_k(d) \\mu(\\frac{T}{d}) \\\\end{aligned}$$令 $f(T) = \\sum_{d \\mid T} id_k(d) \\mu(\\frac{T}{d})$。$$\\begin{aligned} f(n) &amp; = f(\\prod p_i ^ {x_i}) \\ &amp; = \\prod f(p_i^{x_i}) \\ f(p_i^{x_i}) &amp;= \\sum_{j = 1}^{x_i} id_k(p_i^j) \\times \\mu(p_i^{x_i - j}) \\ &amp;= f(p_i^{x_i})\\times \\mu(1) + f(p_i^{x_i - 1})\\times\\mu(p_i) \\ &amp;= (p_i^k - 1)\\times p_i^{k\\times (x_i - 1)}\\end{aligned}$$然后《发现》递推关系: $f(p_i^{x_i}) = f(p_i^{x_i - 1}) \\times p_i^k$ 。当 $x_i = 1$ 时，$f(p_i) = p_i^k - 1$ 。 在线性筛的时候，首先得到 $f(i)$ ，目前要求 $f(i \\times p_j)$ 。 $$f(i \\times p_j) =\\begin{cases} f(i) \\times (p_j^k - 1) \\ , \\ p_j \\nmid i \\ f(i) \\times p_j^k \\ , \\ p_j \\mid i\\end{cases}$$ $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long long#define int long longusing namespace std;const int MAXN = 5e6 + 5;const int Mod = 1e9 + 7;int t, k, n, m, cnt, mu[MAXN], pr[MAXN];bool vis[MAXN];LL f[MAXN], ans;LL qpow(LL x, int y) { LL res = 1; while (y) { if (y &amp; 1) res = res * x % Mod; x = x * x % Mod; y &gt;&gt;= 1; } return res;}void Euler() { mu[1] = 1, f[1] = 1; for (int i = 2; i &lt;= 5e6; i++) { if (!vis[i]) { pr[++cnt] = i, mu[i] = -1, f[i] = (qpow(i, k) - 1 + Mod) % Mod; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= 5e6; j++) { vis[pr[j] * i] = 1; if (i % pr[j] == 0) { f[i * pr[j]] = (f[i] * qpow(pr[j], k)) % Mod; mu[i * pr[j]] = 0; break; } else { f[i * pr[j]] = (f[i] * (qpow(pr[j], k) - 1 + Mod)) % Mod; mu[i * pr[j]] = -mu[i]; } } } for (int i = 2; i &lt;= 5e6; i++) f[i] = (f[i] + f[i - 1] + Mod) % Mod;}signed main() { scanf(&quot;%lld %lld&quot;, &amp;t, &amp;k); Euler(); while (t--) { scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m); int up = min(n, m); ans = 0; for (int i = 1, last = 1; i &lt;= up; i = last + 1) { last = min(n / (n / i), m / (m / i)); ans = (ans + ((n / i) * (m / i) % Mod) * ((f[last] - f[i - 1] + Mod) % Mod)) % Mod; } printf(&quot;%lld\\n&quot;, ans); } return 0;} $\\mathbb{Crash的数字表格}$$\\mathcal{Link}$link $\\mathcal{Sol}$$$\\begin{aligned} &amp;\\sum \\limits {i = 1} ^{n} \\sum \\limits {j = 1} ^{m} \\mathrm{lcm}( i,j)\\ =&amp;\\sum \\limits {i = 1} ^{n} \\sum \\limits {j = 1} ^{m} \\frac{i\\times j}{\\gcd(i,j)} \\ =&amp;\\sum \\limits {i = 1} ^{n} \\sum \\limits {j = 1} ^{m} \\sum{d \\mid i, d\\mid j, \\gcd(\\frac{i}{d}, \\frac{j}{d}) = 1} \\frac{i\\times j}{d} \\ =&amp;\\sum{d=1}^{n} \\sum{i=1}^{n} \\sum{j=1}^{m} [\\gcd(\\frac{i}{d}, \\frac{j}{d}) = 1] \\frac{i \\times j}{d} \\ =&amp;\\sum{d=1}^{n} \\sum{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i, j) = 1] i\\times j \\times d \\ =&amp;\\sum_{d=1}^{n} d \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i, j) = 1] i\\times j\\ =&amp;\\sum_{d=1}^{n} d \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} \\sum_{g \\mid \\gcd(i, j)} \\mu(g) i\\times j\\ =&amp;\\sum_{d=1}^n d \\sum_{g \\mid d} \\mu(g) \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} [g \\mid i] \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [g \\mid j] i\\times j \\ =&amp;\\sum_{d=1}^n d \\sum_{g = 1}^n \\mu(g) g^2 \\sum_{i=1}^{\\lfloor \\frac{n}{dg} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{dg} \\rfloor} i\\times j\\ =&amp;\\sum_{d=1}^n d \\sum_{g = 1}^n \\mu(g) g^2 \\frac{(\\lfloor \\frac{n}{dg} \\rfloor + 1) \\times \\lfloor \\frac{n}{dg} \\rfloor}{2} \\frac{(\\lfloor \\frac{m}{dg} \\rfloor + 1) \\times \\lfloor \\frac{m}{dg} \\rfloor}{2} \\\\end{aligned}$$整除分块可以 $\\mathcal{O}(n \\log n)$ 处理掉。普通版本就可以解决了。对于多组数据的情况还要优化。$$\\begin{aligned} =&amp;\\sum_{d=1}^n d \\sum_{g = 1}^n \\mu(g) g^2 \\frac{(\\lfloor \\frac{n}{dg} \\rfloor + 1) \\times \\lfloor \\frac{n}{dg} \\rfloor}{2} \\frac{(\\lfloor \\frac{m}{dg} \\rfloor + 1) \\times \\lfloor \\frac{m}{dg} \\rfloor}{2} \\ =&amp;\\sum_{T=1}^{n} \\sum_{d \\mid T} d \\times \\mu(\\frac{T}{d}) \\times (\\frac{T}{d})^2 \\frac{(\\lfloor \\frac{n}{T} \\rfloor + 1) \\times \\lfloor \\frac{n}{T} \\rfloor}{2} \\frac{(\\lfloor \\frac{m}{T} \\rfloor + 1) \\times \\lfloor \\frac{m}{T} \\rfloor}{2} \\ =&amp;\\sum_{T=1}^{n} T \\frac{(\\lfloor \\frac{n}{T} \\rfloor + 1) \\times \\lfloor \\frac{n}{T} \\rfloor}{2} \\frac{(\\lfloor \\frac{m}{T} \\rfloor + 1) \\times \\lfloor \\frac{m}{T} \\rfloor}{2} \\sum_{g \\mid T} \\mu(g) \\times g\\ =&amp;\\sum_{T=1}^{n} T\\sum_{g \\mid T} \\mu(g) \\times g \\frac{(\\lfloor \\frac{n}{T} \\rfloor + 1) \\times \\lfloor \\frac{n}{T} \\rfloor}{2} \\frac{(\\lfloor \\frac{m}{T} \\rfloor + 1) \\times \\lfloor \\frac{m}{T} \\rfloor}{2} \\\\end{aligned}$$令 $f(x) = \\sum_{d \\mid x} \\mu(d) \\times d$ 。$$f(i \\times p_j) =\\begin{cases} f(i) , p_j \\mid i \\ f(i) \\times f(p_j) , p_j \\nmid i\\end{cases}$$ $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 1e7 + 5;const int Mod = 100000009;void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}int t, n, m, ans, mu[MAXN], f[MAXN], pr[MAXN], sum[MAXN], inv, cnt;bool vis[MAXN];void Euler() { inv = (Mod * 3 + 1) / 4; f[1] = 1, mu[1] = 1; for (int i = 2; i &lt;= 1e7; i++) { if (!vis[i]) { pr[++cnt] = i, mu[i] = -1, f[i] = (1 - i + Mod) % Mod; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= 1e7; j++) { vis[pr[j] * i] = 1; if (i % pr[j] == 0) { mu[i * pr[j]] = 0; f[i * pr[j]] = f[i]; break; } mu[i * pr[j]] = -mu[i]; f[i * pr[j]] = (f[i] * f[pr[j]] % Mod + Mod) % Mod; } } for (int i = 1; i &lt;= 1e7; i++) sum[i] = (sum[i - 1] + f[i] * i % Mod) % Mod; }signed main() { Euler(); read(t); while (t--) { read(n), read(m); int up = min(n, m); ans = 0; for (int i = 1, last = 1; i &lt;= up; i = last + 1) { last = min(min(n / (n / i), m / (m / i)), up); ans = (ans + (sum[last] - sum[i - 1] + Mod) % Mod * ((n / i + 1) * (n / i) % Mod) % Mod * ((m / i + 1) * (m / i) % Mod) % Mod) % Mod; } printf(&quot;%lld\\n&quot;, ans * inv % Mod); } return 0;} $\\mathbb{数表}$$\\mathcal{Link}$link $\\mathcal{Sol}$$$\\begin{aligned} &amp;\\sum_{i = 1}^n \\sum_{j = 1}^m [f(\\gcd(i, j)) \\le a] f(\\gcd(i, j)) \\ =&amp;\\sum_{d, f(d) \\le a} f(d) \\sum_{i=1}^n \\sum_{j=1}^{n} \\gcd(i, j) = 1; \\ =&amp;\\sum_{d, f(d) \\le a} f(d) \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} [\\gcd(i, j) = 1] \\ =&amp;\\sum_{d, f(d) \\le a} f(d) \\sum_{i=1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j=1}^{\\lfloor \\frac{m}{d} \\rfloor} \\sum_{g}^{\\min(\\lfloor \\frac{n}{d} \\rfloor, \\lfloor \\frac{m}{d} \\rfloor)} \\ =&amp;\\sum_{d, f(d) \\le a} f(d) \\sum_{g}^{\\min(\\lfloor \\frac{n}{d} \\rfloor, \\lfloor \\frac{m}{d} \\rfloor)} \\mu(g) \\lfloor \\frac{n}{dg} \\rfloor \\lfloor \\frac{m}{dg} \\rfloor \\ =&amp;\\sum_{T = 1}^n \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum_{d \\mid T} [f(d) \\le a] f(d) \\mu(\\frac{T}{d})\\end{aligned}$$然后可以把后面的一块抠出来。令 $h(T) = \\sum_{d \\mid T} [f(d) \\le a] f(d) \\mu(\\frac{T}{d})$ 。然后随着 $a$ 的递增，可以动态维护，用 bit 即可。 $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 1e5 + 5;const int Mod = (1ll &lt;&lt; 31);int q, cnt, lev, pr[MAXN], mu[MAXN], f[MAXN], g[MAXN], sum[MAXN], h[MAXN], bit[MAXN], ans[MAXN];bool vis[MAXN];map&lt;int, int&gt; re;int lowbit(int x) { return x &amp; -x; }void update(int p, int val) { for (int i = p; i &lt;= 1e5; i += lowbit(i)) bit[i] = (bit[i] + val) % Mod; }int query(int p) { int res = 0; for (int i = p; i; i -= lowbit(i)) res += bit[i]; return res; }void Euler() { g[1] = f[1] = 1; mu[1] = sum[1] = 1; for (int i = 2; i &lt;= 1e5; i++) { if (!vis[i]) { pr[++cnt] = i, mu[i] = -1, f[i] = g[i] = i + 1; } for (int j = 1; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= 1e5; j++) { vis[pr[j] * i] = 1; if (i % pr[j] == 0) { mu[i * pr[j]] = 0; g[i * pr[j]] = g[i] * pr[j] + 1; f[i * pr[j]] = f[i] / g[i] * g[i * pr[j]]; break; } else { mu[i * pr[j]] = -mu[i]; f[i * pr[j]] = f[i] * f[pr[j]]; g[i * pr[j]] = 1 + pr[j]; } } sum[i] = sum[i - 1] + mu[i]; }}struct Questions { int a, n, m, ind; };Questions que[MAXN];struct Num { int val, ind; } tmp[MAXN];vector&lt;int&gt; add[MAXN];void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}signed main() { Euler(); for (int i = 1; i &lt;= 1e5; i++) tmp[i].val = f[i], tmp[i].ind = i; sort(tmp + 1, tmp + MAXN - 4, [](const Num&amp; x, const Num&amp; y) { return x.val &lt; y.val; }); for (int i = 1; i &lt;= 1e5; i++) { if (tmp[i].val != tmp[i - 1].val) re[++lev] = tmp[i].val; add[lev].push_back(tmp[i].ind); // printf(&quot;%d %d %d\\n&quot;, tmp[i].val, tmp[i].ind, re[tmp[i].val]); } // printf(&quot;\\n&quot;); read(q); for (int i = 1; i &lt;= q; i++) read(que[i].n), read(que[i].m), read(que[i].a), que[i].ind = i; sort(que + 1, que + 1 + q, [](const Questions&amp; x, const Questions&amp; y) { return x.a &lt; y.a; }); for (int i = 1, last = 0; i &lt;= q; i++) { if (que[i].a != que[i - 1].a) { int pos = 0; for (pos = last + 1; re[pos] &lt;= que[i].a &amp;&amp; pos &lt;= lev; pos++) { for (int k = 0; k &lt; add[pos].size(); k++) { int x = add[pos][k]; // printf(&quot;%d %d %d-\\n&quot;, x, f[x], re[x]); for (int t = 1; t * x &lt;= 1e5; t++) { h[t * x] = (h[t * x] + f[x] * mu[t] + Mod) % Mod; update(t * x, (f[x] * mu[t] + Mod) % Mod); } } } last = pos - 1; // printf(&quot;\\n&quot;); } int res = 0, up = min(que[i].n, que[i].m); for (int l = 1, r = 1; l &lt;= up; l = r + 1) { r = min(que[i].n / (que[i].n / l), que[i].m / (que[i].m / l)); r = min(r, up); res = (res + (query(r) - query(l - 1)) * (que[i].n / l) % Mod * (que[i].m / l) % Mod + Mod) % Mod; } ans[que[i].ind] = res; } for (int i = 1; i &lt;= q; i++) { printf(&quot;%lld\\n&quot;, ans[i]); } return 0;} $\\mathbb{DZY \\ Loves \\ Math}$$\\mathcal{Link}$link $\\mathcal{Sol}$定义 $f(n)$ 为 $n$ 所含质因子的最大幂指数。$$\\begin{aligned} &amp;\\sum_{i = 1}^{a} \\sum_{j = 1}^b f(\\gcd(i, j)) \\ =&amp;\\sum_{T = 1}^n \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum_{d \\mid T} f(d) \\mu(\\frac{T}{d})\\end{aligned}$$把 $f$ 预处理出来，用埃筛算贡献即可。$1e7$ 的数据规模跑的过去个鬼啊。。。这个玩意儿没有积性没办法搞啊。。。 果断咕掉。 $\\mathcal{Code}$123456#include &lt;gu&gt;using namespace gu;int Gu() { return Gu();} $\\mathbb{约数个数和}$$\\mathcal{Link}$link $\\mathcal{Sol}$$$\\begin{aligned} &amp;\\sum_{i=1}^n\\sum_{j=1}^m d(ij) \\ =&amp;\\sum_{i=1}^n\\sum_{j=1}^m \\frac{d(ij)}{\\gcd(i, j)} \\times (\\gcd(i, j) + 1) \\ =&amp;\\end{aligned}$$","link":"/2022/02/06/2022-02-10-Mobius%20&%20Dirichlet%20Solution%20Set/"},{"title":"「Note」整体二分","text":"比 cdq 阳间多了 ！！！1 $\\mathcal{Dynamic \\ Rankings}$$\\mathcal{Link}$link $\\mathcal{Sol}$整体二分却也是个比较好懂的算法。大概就是用递归代替 while ，实现多线程推进。然后把修改替换成删除和添加。注释写在代码里 $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 6e5 + 5;const int INF = 0x3f3f3f3f;int n, m, cnt, qcnt, num[MAXN], ans[MAXN], bit[MAXN];struct Question { int l, r, k, op, ind; } q[MAXN], q1[MAXN], q2[MAXN];int lowbit(int x) { return x &amp; -x; }void update(int x, int val) { for (int i = x; i &lt;= n; i += lowbit(i)) bit[i] += val; }int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += bit[i]; return res;}void solve(int vall, int valr, int optl, int optr) { if (optl &gt; optr) return; if (vall == valr) { for (int i = optl; i &lt;= optr; i++) if (q[i].op == 2) ans[q[i].ind] = vall; return; } int mid = (vall + valr) &gt;&gt; 1, cnt1 = 0, cnt2 = 0; for (int i = optl; i &lt;= optr; i++) { if (q[i].op == 1) { // 对于 删 / 加 操作 if (q[i].l &lt;= mid) q1[++cnt1] = q[i], update(q[i].ind, q[i].r); // 统计 &lt;= mid 的做出贡献 else q2[++cnt2] = q[i]; } else { int tmp = query(q[i].r) - query(q[i].l - 1); if (q[i].k &gt; tmp) q[i].k -= tmp, q2[++cnt2] = q[i]; else q1[++cnt1] = q[i]; } } for (int i = 1; i &lt;= cnt1; i++) q[optl + i - 1] = q1[i]; for (int i = 1; i &lt;= cnt2; i++) q[optl + cnt1 + i - 1] = q2[i]; for (int i = 1; i &lt;= cnt1; i++) if (q1[i].op == 1) update(q1[i].ind, -q1[i].r); // 注意每层都要还原 solve(vall, mid, optl, optl + cnt1 - 1); solve(mid + 1, valr, optl + cnt1, optr);}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, x; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;x); num[i] = x; q[++cnt] = Question{x, 1, 0, 1, i}; } for (int i = 1, l, r, k, x, y; i &lt;= m; i++) { char opt; cin &gt;&gt; opt; if (opt == 'Q') scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k), q[++cnt] = Question{l, r, k, 2, ++qcnt}; else { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); // 拆成 删除 / 添加 q[++cnt] = Question{num[x], -1, 0, 1, x}, num[x] = y; q[++cnt] = Question{num[x], 1, 0, 1, x}; } } solve(-INF, INF, 1, cnt); for (int i = 1; i &lt;= qcnt; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;} $\\mathcal{[ZJOI2013]K大数查询}$$\\mathcal{Link}$link $\\mathcal{Sol}$这道题要把上一题的单修改成区修就好了。主要开 long long 。 $\\mathcal{Code}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 5e4 + 5;const LL INF = 1e18;int n, m, qcnt;LL ans[MAXN];struct SegmentTree { int l, r; LL dat, tag; } s[MAXN &lt;&lt; 4];void push_up(int p) { s[p].dat = (s[p &lt;&lt; 1].dat + s[p &lt;&lt; 1 | 1].dat); }void push_down(int p) { if (!s[p].tag) return; s[p &lt;&lt; 1].dat += (s[p &lt;&lt; 1].r - s[p &lt;&lt; 1].l + 1) * s[p].tag, s[p &lt;&lt; 1].tag += s[p].tag; s[p &lt;&lt; 1 | 1].dat += (s[p &lt;&lt; 1 | 1].r - s[p &lt;&lt; 1 | 1].l + 1) * s[p].tag, s[p &lt;&lt; 1 | 1].tag += s[p].tag; s[p].tag = 0;}void build(int p, int l, int r) { s[p].l = l, s[p].r = r; if (l == r) { s[p].dat = 0; return; } int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid), build(p &lt;&lt; 1 | 1, mid + 1, r); push_up(p);}void update(int p, int l, int r, LL add) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) { s[p].dat += (s[p].r - s[p].l + 1) * add, s[p].tag += add; return; } push_down(p); int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (l &lt;= mid) update(p &lt;&lt; 1, l, r, add); if (r &gt; mid) update(p &lt;&lt; 1 | 1, l, r, add); push_up(p);}LL query(int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].dat; push_down(p); int mid = (s[p].l + s[p].r) &gt;&gt; 1, res = 0; if (l &lt;= mid) res += query(p &lt;&lt; 1, l, r); if (r &gt; mid) res += query(p &lt;&lt; 1 | 1, l, r); return res;}struct Question { int l, r, ind, op; LL c; } q[MAXN], q1[MAXN], q2[MAXN];void solve(LL vall, LL valr, int optl, int optr) { if (optl &gt; optr) return; if (vall == valr) { for (int i = optl; i &lt;= optr; i++) if (q[i].op == 2) ans[q[i].ind] = vall; return; } LL mid = (vall + valr) &gt;&gt; 1; int cnt1 = 0, cnt2 = 0; for (int i = optl; i &lt;= optr; i++) { if (q[i].op == 1) { if (q[i].c &lt;= mid) q1[++cnt1] = q[i]; else update(1, q[i].l, q[i].r, 1), q2[++cnt2] = q[i]; } else { LL tmp = query(1, q[i].l, q[i].r); if (q[i].c &gt; tmp) q[i].c -= tmp, q1[++cnt1] = q[i]; else q2[++cnt2] = q[i]; } } for (int i = 1; i &lt;= cnt1; i++) q[optl + i - 1] = q1[i]; for (int i = 1; i &lt;= cnt2; i++) q[optl + cnt1 + i - 1] = q2[i]; for (int i = 1; i &lt;= cnt2; i++) if (q2[i].op == 1) update(1, q2[i].l, q2[i].r, -1); solve(vall, mid, optl, optl + cnt1 - 1), solve(mid + 1, valr, optl + cnt1, optr);}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); build(1, 1, n); for (int i = 1, opt, l, r; i &lt;= m; i++) { LL c; scanf(&quot;%d %d %d %lld&quot;, &amp;opt, &amp;l, &amp;r, &amp;c); if (opt == 1) q[i] = Question{l, r, i, 1, c}; else q[i] = Question{l, r, ++qcnt, 2, c}; } solve(-INF, INF, 1, m); for (int i = 1; i &lt;= qcnt; i++) printf(&quot;%lld\\n&quot;, ans[i]); return 0;} $\\mathcal{Sign \\ on \\ Fence}$$\\mathcal{Link}$link $\\mathcal{Sol}$把求值转化成判定就好了，大概是个 trick 。把问题变成查询是否有大于等于 mid 且长度不少于 k 的子区间。然后就要线段树来维护一段最长的 0/1 区间。于是题目就变成了 SHOI2015脑洞治疗仪 + 整体二分。 $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2e5 + 5;const int INF = 0x3f3f3f3f;int n, m, cnt, ans[MAXN];struct SegmentTree { int l, r, dat, lmax, rmax; } s[MAXN &lt;&lt; 2];void push_up(int p) { s[p].lmax = max((s[p &lt;&lt; 1].lmax == s[p &lt;&lt; 1].r - s[p &lt;&lt; 1].l + 1) * s[p &lt;&lt; 1 | 1].lmax + s[p &lt;&lt; 1].lmax, s[p &lt;&lt; 1].lmax); s[p].rmax = max((s[p &lt;&lt; 1 | 1].rmax == s[p &lt;&lt; 1 | 1].r - s[p &lt;&lt; 1 | 1].l + 1) * s[p &lt;&lt; 1].rmax + s[p &lt;&lt; 1 | 1].rmax, s[p &lt;&lt; 1 | 1].rmax); s[p].dat = max(max(s[p &lt;&lt; 1].dat, s[p &lt;&lt; 1 | 1].dat), s[p &lt;&lt; 1].rmax + s[p &lt;&lt; 1 | 1].lmax);}void build(int p, int l, int r) { s[p].l = l, s[p].r = r; if (l == r) { s[p].dat = s[p].lmax = s[p].rmax = 0; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid), build(p &lt;&lt; 1 | 1, mid + 1, r); push_up(p);}void update(int p, int x, int val) { if (s[p].l == s[p].r) { s[p].dat = s[p].lmax = s[p].rmax = val; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (x &lt;= mid) update(p &lt;&lt; 1, x, val); if (x &gt; mid) update(p &lt;&lt; 1 | 1, x, val); push_up(p);}int query(int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].dat; int mid = (s[p].l + s[p].r) &gt;&gt; 1, lmax = 0, rmax = 0, addl = 0, addr = 0; if (l &lt;= mid) { lmax = query(p &lt;&lt; 1, l, r); if (r &gt; mid) addl = min(mid - l + 1, s[p &lt;&lt; 1].rmax); } if (r &gt; mid) { rmax = query(p &lt;&lt; 1 | 1, l, r); if (l &lt;= mid) addr = min(r - mid, s[p &lt;&lt; 1 | 1].lmax); } return max(addl + addr, max(lmax, rmax));}struct Question { int l, r, k, op, ind; } q[MAXN], q1[MAXN], q2[MAXN];void solve(int vall, int valr, int optl, int optr) { if (optl &gt; optr) return; if (vall == valr) { for (int i = optl; i &lt;= optr; i++) if (q[i].op == 2) ans[q[i].ind] = vall; return; } int mid = (vall + valr) &gt;&gt; 1, cnt1 = 0, cnt2 = 0; for (int i = optl; i &lt;= optr; i++) { if (q[i].op == 1) { if (q[i].l &gt; mid) update(1, q[i].ind, 1), q2[++cnt2] = q[i]; else q1[++cnt1] = q[i]; } else { int tmp = query(1, q[i].l, q[i].r); if (tmp &gt;= q[i].k) q2[++cnt2] = q[i]; else q1[++cnt1] = q[i]; } } for (int i = 1; i &lt;= cnt1; i++) q[optl + i - 1] = q1[i]; for (int i = 1; i &lt;= cnt2; i++) q[optl + cnt1 + i - 1] = q2[i]; solve(vall, mid, optl, optl + cnt1 - 1); for (int i = optl + cnt1; i &lt;= optr; i++) if (q[i].op == 1) update(1, q[i].ind, 0); solve(mid + 1, valr, optl + cnt1, optr);}int main() { scanf(&quot;%d&quot;, &amp;n); build(1, 1, n); for (int i = 1, x; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;x); q[++cnt] = Question{x, 1, 0, 1, i}; } scanf(&quot;%d&quot;, &amp;m); for (int i = 1, l, r, k; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k); q[++cnt] = Question{l, r, k, 2, i}; } solve(-INF, INF, 1, cnt); for (int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;} $\\mathcal{THUPC2017 \\ 天天爱射击}$$\\mathcal{Link}$link $\\mathcal{Sol}$首先吐槽题面。题目可以把子弹看成修改，把木板看成查询。可以直接上手了。主要在修改答案时改为统计每个修改造成贡献的查询有多少个。 $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 4e5 + 5;const int INF = 0x3f3f3f3f;int n, m, up, cnt, x1[MAXN], x2[MAXN], cou[MAXN], ans[MAXN], bit[MAXN];int lowbit(int x) { return x &amp; -x; }void update(int x, int val) { for (int i = x; i &lt;= up; i += lowbit(i)) bit[i] += val; }int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += bit[i]; return res;}struct Question { int l, r, k, op, ind; } q[MAXN], q1[MAXN], q2[MAXN];void solve(int vall, int valr, int optl, int optr) { if (optl &gt; optr) return; if (vall == valr) { for (int i = optl; i &lt;= optr; i++) if (q[i].op == 2) ans[vall]++; return; } int mid = (vall + valr) &gt;&gt; 1, cnt1 = 0, cnt2 = 0; for (int i = optl; i &lt;= optr; i++) { if (q[i].op == 1) { if (q[i].ind &lt;= mid) update(q[i].l, 1), q1[++cnt1] = q[i]; else q2[++cnt2] = q[i]; } else { int tmp = query(q[i].r) - query(q[i].l - 1); if (q[i].k &lt;= tmp) q1[++cnt1] = q[i]; else q[i].k -= tmp, q2[++cnt2] = q[i]; } } for (int i = 1; i &lt;= cnt1; i++) q[optl + i - 1] = q1[i]; for (int i = 1; i &lt;= cnt2; i++) q[optl + cnt1 + i - 1] = q2[i]; for (int i = 1; i &lt;= cnt1; i++) if (q1[i].op == 1) update(q1[i].l, -1); solve(vall, mid, optl, optl + cnt1 - 1); solve(mid + 1, valr, optl + cnt1, optr);}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d %d %d&quot;, &amp;x1[i], &amp;x2[i], &amp;cou[i]), up = max(up, x2[i]); for (int i = 1, x; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;x), q[++cnt] = Question{x, 1, 0, 1, i}; for (int i = 1; i &lt;= n; i++) q[++cnt] = Question{x1[i], x2[i], cou[i], 2, i}; solve(0, n + 1, 1, cnt); for (int i = 1; i &lt;= m; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;} $\\mathcal{Till \\ I \\ Collapse}$$\\mathcal{Link}$link $\\mathcal{Sol}$大概是个整体二分？你会发现答案单调，且最多只有 $\\sqrt n $ 种答案取值。然后可以搞一个神奇的二分模板套上去算它。 $\\mathcal{Template}$123456789void solve(int l, int r) { int lnum = check(l), rnum = check(r); if (lnum == rnum) { for (int i = l; i &lt;= r; i++) ans[i] = lnum; return; } int mid = (l + r) &gt;&gt; 1; solve(l, mid), solve(mid + 1, r);} 时间复杂度是 $\\mathcal{O}(\\sqrt n \\log n)$ 。 $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;int n, len, dp[MAXN], fa[MAXN], dfn[MAXN], ans[MAXN];vector&lt;int&gt; G[MAXN];bool vis[MAXN];void dfs(int u, int fath) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == fath) continue; dfs(v, u); } fa[u] = fath, dfn[++len] = u;}int check(int k) { for (int i = 1; i &lt;= n; i++) dp[i] = 1, vis[i] = 0; int sum = 0; for (int i = 1; i &lt;= n; i++) if (!vis[dfn[i]] &amp;&amp; !vis[fa[dfn[i]]] &amp;&amp; fa[dfn[i]]) { if (dp[fa[dfn[i]]] + dp[dfn[i]] &gt;= k) { sum++, vis[fa[dfn[i]]] = 1; } else dp[fa[dfn[i]]] = max(dp[fa[dfn[i]]], dp[dfn[i]] + 1); } return sum;}void solve(int l, int r) { int lnum = check(l), rnum = check(r); if (lnum == rnum) { for (int i = l; i &lt;= r; i++) ans[i] = lnum; return; } int mid = (l + r) &gt;&gt; 1; solve(l, mid), solve(mid + 1, r);}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1, u, v; i &lt; n; i++) { scanf(&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); } dfs(1, 0), solve(1, n); ans[1] = n; for (int i = 1; i &lt;= n; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;} $\\mathcal{You \\ Are \\ Given \\ a \\ Tree}$$\\mathcal{Link}$link $\\mathcal{Sol}$与上一题类似。只不过在树上，先 dfs 出 dfn 序，搞一个在 dfn 序上的 dp 就好了。 $\\mathcal{Code}$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e5 + 5;int n, len, dp[MAXN], fa[MAXN], dfn[MAXN], ans[MAXN];vector&lt;int&gt; G[MAXN];bool vis[MAXN];void dfs(int u, int fath) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == fath) continue; dfs(v, u); } fa[u] = fath, dfn[++len] = u;}int check(int k) { for (int i = 1; i &lt;= n; i++) dp[i] = 1, vis[i] = 0; int sum = 0; for (int i = 1; i &lt;= n; i++) if (!vis[dfn[i]] &amp;&amp; !vis[fa[dfn[i]]] &amp;&amp; fa[dfn[i]]) { if (dp[fa[dfn[i]]] + dp[dfn[i]] &gt;= k) { sum++, vis[fa[dfn[i]]] = 1; } else dp[fa[dfn[i]]] = max(dp[fa[dfn[i]]], dp[dfn[i]] + 1); } return sum;}void solve(int l, int r) { int lnum = check(l), rnum = check(r); if (lnum == rnum) { for (int i = l; i &lt;= r; i++) ans[i] = lnum; return; } int mid = (l + r) &gt;&gt; 1; solve(l, mid), solve(mid + 1, r);}int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1, u, v; i &lt; n; i++) { scanf(&quot;%d %d&quot;, &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); } dfs(1, 0), solve(1, n); ans[1] = n; for (int i = 1; i &lt;= n; i++) printf(&quot;%d\\n&quot;, ans[i]); return 0;}","link":"/2022/02/16/2022-02-16-%5BNote%5D%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"},{"title":"「Note」LinkCutTree","text":"我不理解? $\\mathbb{Problem}$简单的来说，就是在树剖的基础上加一个操作，支持树的裂开与合并。 $\\mathbb{Editorial}$如果做一遍重链剖分操作，操作完之后会发现，树上形成了很多以链为单位的连续区间，那么这时就能用 SegmentTree 做一些操作。 本质上， LinkCutTree 维护的是动态的重链。搞清楚维护的内容或许就来了一大半了。 然后说一下具体的实现。如果我们想操作某个区间，对于树剖来说，就是两个点反复上跳到 lca 并在中途维护题目要求的信息，会发现走的都是重链，如果我维护的是一个动态的树，并且期望达到树剖一样的效果，那我该怎么搞呢？ 把重链抽象成结构体 : struct maxchain{ chain, fa } 。这提示我们可以单独对于每条链维护一个结构体，其中包含本条链的信息和这条链的顶端的点的父节点（方便往上跳）。 $\\mathcal{Struct}$1struct Splay { int fa, ch[2], dat, ind, val; bool rev; } s[MAXN]; 如果把 link 和 cut 搬到链上表示，即是拆掉某条链的部分，接在另外一条链的某个位置。就是个序列操作，那么就可以用 Splay 作为内层数据结构实现这个操作。 注：Splay 以动态的深度作为关键字建树。父节点的指针是单向的，仅是 son -&gt; fa 大致的思想如上，讲讲核心的操作。 $\\mathcal{Opter}$我自己造的操作。。。opter(x, y) 表示把 x 和 y 之间的路径抠出来，进行操作。如果 x 和 y 在一个 splay 里面，并且 x 为原树的根，这个就是 Splay 的基操，直接把 y 转到 Splay 的根，然后 x -&gt; y 的路径就以 y 为根，取出 y 不就好了嘛。然而这个美好的想法肯定不是一直成立。那我们就强行让它成立。因为他是 动态树 /xyx。 $\\mathcal{Makeroot}$顾名思义，造一个根，额，makeroot(x) 实际上是把 x 变成原树的根。如果 x 和原树的根再一个 Splay 里面，那这个只需要把 x 旋到 Splay 的根就行了。你发现我又开始设想某种简单舒适的 case 了。然而我还是可以强行办到。只要我把 x 到原树根路径上的点塞到一个 Splay 里面就好了。 $\\mathcal{Accecss}$$\\mathbb{Editorial}$通俗的讲， access(x) 就是把 x 和当前的根（原树）之间的路径变成一条重链，或者是说，把 x 和当前的根（原树）之间的路径上的点塞到一个 Splay 里面。所以现在你沿着当前点往上跳就行了。。。 步骤如下： 首先把 x 旋到他所在的 Splay 的根。 找到这条 Splay 的顶端节点的父指针，直接将单向的父指针改成双向的，两条链就拼在了一起，即是 s[x].ch[1] = i 。直接连右儿子就行了，因为 i 的深度一定大于 x 。发现这里不需要去双向断边。 更新 x 。 $\\mathcal{Code}$1234567void access(int x) { for (int i = 0; x; i = x, x = s[x].fa) { splay(x); s[x].ch[1] = i; push_up(x); }} 返回去， makeroot 和 opter 的代码就也能写了。 12345678910void makeroot(int x) { access(x); splay(x); push_rev(x); // 反转两个儿子}void opter(int x, int y) { makeroot(x); access(y); splay(y);} $\\mathcal{Link}$回到本职操作。链接两个点，实际上是把两棵树拼到一起，首先把其中一个点旋到根，这个时候处于根的点可以随便搞，直接把 fa 指针指到另一个节点即可。 12345void link(int x, int y) { makeroot(x); if (findroot(y) == x) return; // 不对同连通块里的两点加边 s[x].fa = y;} $\\mathcal{Cut}$很(h&amp;emacr;i)清晰，先把一个点旋到根，把另外一点的父节点置空，把当前节点的右儿子置空。 123456void cut(int x, int y) { makeroot(x); if (findroot(y) != x || s[y].ch[0] || s[y].fa != x) return; // 判 &lt;x,y&gt; 是否存在 s[y].fa = 0, s[x].ch[1] = 0; push_up(x);} $\\mathcal{Changes \\ about \\ Splay}$突然发现 Splay 部分忘了写了。。。 观察可知，当 makeroot 之后父子关系、深度会发生变化，以前的 Splay 并不适用了，这个时候应该把 Splay 以 newroot 为根反转过来。 12345678910111213141516171819202122void push_rev(int p) { s[p].rev ^= 1, swap(s[p].ch[0], s[p].ch[1]); }void push_down(int p) { if (!s[p].rev) return; push_rev(s[p].ch[0]), push_rev(s[p].ch[1]); s[p].rev = 0;}bool check(int x) { return ((s[s[x].fa].ch[0] != x) &amp;&amp; (s[s[x].fa].ch[1] != x)); }void push_all(int x) { if (!check(x)) push_all(s[x].fa); push_down(x);}void splay(int x) { push_all(x); while (!check(x)) { int y = s[x].fa, z = s[y].fa; if (!check(y)) rotate((ident(x) == ident(y)) ? y : x); rotate(x); } push_up(x);} $\\mathcal{Code}$以 「NOI2014」魔法森林 中维护联通块内最大边权及其编号的代码为例。 LinkCutTree.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct LinkCutTree { struct Splay { int fa, ch[2], dat, ind, val; bool rev; } s[MAXN]; void push_up(int p) { s[p].dat = max(s[s[p].ch[0]].dat, max(s[p].val, s[s[p].ch[1]].dat)); if (s[s[p].ch[0]].dat == s[p].dat) { s[p].ind = s[s[p].ch[0]].ind; } else if (s[s[p].ch[1]].dat == s[p].dat) { s[p].ind = s[s[p].ch[1]].ind; } else s[p].ind = p; } void push_rev(int p) { s[p].rev ^= 1, swap(s[p].ch[0], s[p].ch[1]); } void push_down(int p) { if (!s[p].rev) return; push_rev(s[p].ch[0]), push_rev(s[p].ch[1]); s[p].rev = 0; } bool check(int x) { return ((s[s[x].fa].ch[0] != x) &amp;&amp; (s[s[x].fa].ch[1] != x)); } int ident(int x) { return x == s[s[x].fa].ch[1]; } void connect (int f, int p, int k) { s[f].ch[k] = p, s[p].fa = f; } void rotate (int x) { int y = s[x].fa, z = s[y].fa, k = ident (x), k2 = ident (y); if (!check(y)) s[z].ch[k2] = x; s[x].fa = z; connect(y, s[x].ch[k ^ 1], k); connect(x, y, k ^ 1); push_up (y), push_up (x); } void push_all(int x) { if (!check(x)) push_all(s[x].fa); push_down(x); } void splay(int x) { push_all(x); while (!check(x)) { int y = s[x].fa, z = s[y].fa; if (!check(y)) rotate((ident(x) == ident(y)) ? y : x); rotate(x); } push_up(x); } void access(int x) { for (int i = 0; x; i = x, x = s[x].fa) splay(x), s[x].ch[1] = i, push_up(x); } void makeroot(int x) { access(x), splay(x), push_rev(x); } int findroot(int x) { access(x), splay(x), push_down(x); while (s[x].ch[0]) x = s[x].ch[0], push_down(x); splay(x); return x; } void opter(int x, int y) { makeroot(x), access(y), splay(y); } void link(int x, int y) { makeroot(x); if (findroot(y) == x) return; s[x].fa = y; } void cut(int x, int y) { makeroot(x); if (findroot(y) != x || s[y].ch[0] || s[y].fa != x) return; s[y].fa = 0, s[x].ch[1] = 0; push_up(x); }} lct;","link":"/2022/02/25/2022-02-25-LinkCutTree/"},{"title":"「Note」PresidentTree","text":"小清新数据结构 查询 Kth1234567891011121314151617181920212223242526272829303132333435struct PresidentTree { int tot, cnt, root[MAXN]; struct Node { int l, r, lch, rch; LL dat; } s[MAXN]; void init() { for (int i = 1; i &lt;= tot; i++) s[i] = Node{0, 0, 0, 0, 0}, root[i] = 0; tot = cnt = 0; } int newnode(int val, int l, int r) { s[++tot] = Node{l, r, 0, 0, 0}; return tot; } void update(int&amp; p, int x, LL val) { s[++tot] = s[p], p = tot, s[p].dat++; if (s[p].l == s[p].r) return; int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (x &lt;= mid) { if (!s[p].lch) s[p].lch = newnode(0, s[p].l, mid); update(s[p].lch, x, val); } else { if (!s[p].rch) s[p].rch = newnode(0, mid + 1, s[p].r); update(s[p].rch, x, val); } } int query(int rt1, int rt2, int k) { if (s[rt1].l == s[rt1].r) return s[rt1].l; int mid = (s[rt1].r + s[rt1].l) &gt;&gt; 1; int num = s[s[rt2].lch].dat - s[s[rt1].lch].dat; if (num &gt;= k) { if (!s[rt1].lch) s[rt1].lch = newnode(0, s[rt1].l, mid); if (!s[rt2].lch) s[rt2].lch = newnode(0, s[rt2].l, mid); return query(s[rt1].lch, s[rt2].lch, k); } else { if (!s[rt1].rch) s[rt1].rch = newnode(0, mid + 1, s[rt1].r); if (!s[rt2].rch) s[rt2].rch = newnode(0, mid + 1, s[rt2].r); return query(s[rt1].rch, s[rt2].rch, k - num); } }} pret; 区间修改12345678910111213141516171819202122232425262728293031struct PresidentTree { int tot, cnt, root[MAXN]; struct Node { int l, r, lch, rch; LL dat, tag; } s[MAXN]; void init() { for (int i = 1; i &lt;= tot; i++) s[i] = Node{0, 0, 0, 0, 0, 0}, root[i] = 0; tot = cnt = 0; } void build(int&amp; p, int l, int r) { p = ++tot; s[p].l = l, s[p].r = r, s[p].dat = a[s[p].l]; if (l == r) return; int mid = (s[p].l + s[p].r) &gt;&gt; 1; build(s[p].lch, l, mid), build(s[p].rch, mid + 1, r); s[p].dat = s[s[p].lch].dat + s[s[p].rch].dat; } void update(int&amp; p, int l, int r, LL val) { s[++tot] = s[p], p = tot; if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) { s[p].tag += val; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (l &lt;= mid) update(s[p].lch, l, r, val); if (r &gt; mid) update(s[p].rch, l, r, val); s[p].dat += val * (min(r, s[p].r) - max(l, s[p].l) + 1); } LL query(int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) { return s[p].dat + s[p].tag * (s[p].r - s[p].l + 1); } int mid = (s[p].l + s[p].r) &gt;&gt; 1; LL res = 0; if (l &lt;= mid) res += query(s[p].lch, l, r); if (r &gt; mid) res += query(s[p].rch, l, r); res += s[p].tag * (min(r, s[p].r) - max(l, s[p].l) + 1); return res; }} pret;","link":"/2022/02/22/2022-02-22-%5BNote%5D%20PresidentTree/"},{"title":"「Note」杜教筛","text":"大抵算个套路。 $\\mathbb{Editorial}$给一个积性函数 $f$ ， 要求 $f$ 前缀和。即是求 $\\sum_{i = 1}^{n} f(i)$ 。 但是当 $n$ 很大时，直接线筛的时间复杂度会很大。杜教筛利用了狄利克雷卷积的性质，建立方程，将比较难直接算的函数，转化成一些简单函数的运算求解。 具体地说，首先把要求的结果 $\\sum_{i = 1}^n f(i)$ 设为 $S(n)$ 。然后再找一个积性函数 $g(i)$ ，利用卷积，可以知道$$\\begin{aligned} &amp;\\sum_{i = 1}^{n} (f * g)(i) \\ =&amp;\\sum_{i = 1}^{n} \\sum_{d \\mid i} f(d) g(\\frac{i}{d}) \\ =&amp;\\sum_{d = 1}^{n} g(d) \\sum_{i = 1}^{\\lfloor{\\frac{n}{d}}\\rfloor} f(i) \\\\end{aligned}$$马上可以发现 $\\sum_{i = 1}^{\\lfloor{\\frac{n}{d}}\\rfloor} f(i)$ 可以替换成 $S(\\lfloor{\\frac{n}{d}}\\rfloor)$ 。那么原式就是 $\\sum_{d = 1}^{n} g(d) S(\\lfloor{\\frac{n}{d}}\\rfloor)$ 。我想要的是 $S(n)$ 。这个式子里有 $g(1)S(n)$ 。那么找到 $g(1)S(n)$ 就找得到 $S(n)$ 了。这个可以通过 $\\sum_{d = 1}^{n} g(d) S(\\lfloor{\\frac{n}{d}}\\rfloor) - \\sum_{d = 2}^{n} g(d) S(\\lfloor{\\frac{n}{d}}\\rfloor)$ 得到。再来一波回代， $S(n) = \\frac{\\sum_{i = 1}^{n} (f * g)(i) - \\sum_{d = 2}^{n} g(d) S(\\lfloor{\\frac{n}{d}}\\rfloor)}{g(1)}$ 。你可以选择一个合适的 $g$ 使得卷积可以飞快的算出来，假设算卷积的时间复杂度为 $\\mathcal{O}(1)$ 。 那总共的时间复杂度可以达到 $\\mathcal{O}(n^{\\frac{3}{4}})$ , 比线性快得多。 $\\mathcal{Lucas的数论}$$\\mathcal{Link}$link $\\mathcal{Sol}$先记一个结论。$d(ij) = \\sum_{x \\mid i} \\sum_{y \\mid j}[\\gcd(x, y)]$于是这道题就可做了。$$$$","link":"/2022/02/18/2022-02-18-%5BNote%5D%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"title":"「Note」可持久化数据结构 全家桶","text":"统一了代码风格，一律是封装的形式。 $\\mathcal{SegmentTree}$1234567891011121314151617181920212223242526272829struct PresidentTree { int tot, cnt, root[MAXN]; struct Node { int lch, rch, dat; } s[MAXN * 25]; void init() { for (int i = 1; i &lt;= tot; i++) s[i] = Node{0, 0, 0}, root[i] = 0; tot = cnt = 0; } int newnode(int val, int l, int r) { s[++tot] = Node{l, r, 0}; return tot; } void update(int l, int r, int&amp; p, int x, int val) { s[++tot] = s[p], p = tot, s[p].dat += val; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(l, mid, s[p].lch, x, val); else update(mid + 1, r, s[p].rch, x, val); } int query(int l, int r, int rt1, int rt2, int k) { if (l == r) return l; int mid = (r + l) &gt;&gt; 1; int num = s[s[rt2].lch].dat - s[s[rt1].lch].dat; if (num &gt;= k) return query(l, mid, s[rt1].lch, s[rt2].lch, k); else return query(mid + 1, r, s[rt1].rch, s[rt2].rch, k - num); } int count(int l, int r, int rt1, int rt2, int x) { if (l == r) return s[rt2].dat - s[rt1].dat; int mid = (r + l) &gt;&gt; 1; if (x &lt;= mid) return count(l, mid, s[rt1].lch, s[rt2].lch, x); else return count(mid + 1, r, s[rt1].rch, s[rt2].rch, x); }} pret; $\\mathcal{DSU}$123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Present_UnionFindTree { int cnt, root[MAXN * 35]; struct Node{ int l, r, fa, rnk, res; } s[(MAXN &lt;&lt; 2) * 35]; void build(int&amp; p, int l, int r) { p = ++cnt, s[p].res = INF; if (l == r) { s[p].fa = l, s[p].res = dis[l]; return; } int mid = (l + r) &gt;&gt; 1; build(s[p].l, l, mid), build(s[p].r, mid + 1, r); } void merge(int&amp; p, int l, int r, int pos, int nfa) { s[++cnt] = s[p], p = cnt; if (l == r) { s[p].fa = nfa; return; } int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) merge(s[p].l, l, mid, pos, nfa); else merge(s[p].r, mid + 1, r, pos, nfa); } void update(int&amp; p, int l, int r, int pos, int add, int val) { s[++cnt] = s[p], p = cnt; if (l == r) { s[p].rnk += add; s[p].res = val; return; } int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(s[p].l, l, mid, pos, add, val); else update(s[p].r, mid + 1, r, pos, add, val); } int query(int p, int l, int r, int pos) { if (l == r) return p; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) return query(s[p].l, l, mid, pos); else return query(s[p].r, mid + 1, r, pos); } int FindSet(int p, int pos) { int now = query(p, 1, n, pos); if (s[now].fa == pos) return now; return FindSet(p, s[now].fa); }} ust; $\\mathcal{Trie}$123456789101112131415161718192021struct Trie { int cnt, root[MAXN], ch[MAXN * 30][30], ed[MAXN * 30]; void insert(int p, int lst, char* s) { int len = strlen(s + 1); for (int i = 1; i &lt;= len; i++) { int now = s[i] - 'a' + 1; for (int j = 1; j &lt;= 26; j++) if (j != now) ch[p][j] = ch[lst][j]; p = ch[p][now] = ++cnt, lst = ch[lst][now]; ed[p] = ed[lst] + 1; } } int query(int x, int y, int pre, char* s) { int len = strlen(s + 1), res = n; for (int i = 1; i &lt;= len; i++) { int now = s[i] - 'a' + 1; res = min(res, ed[ch[x][now]] + ed[ch[y][now]] - 2 * ed[ch[pre][now]]); x = ch[x][now], y = ch[y][now], pre = ch[pre][now]; } return res; }} trie; $\\mathcal{Treap}$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct Treap { int cnt, root[MAXN], pre, now, nxt; struct Node { int val, key, l, r, siz; } s[MAXN * MAXLOG]; int newnode(int val) { s[++cnt].val = val, s[cnt].key = rand(), s[cnt].siz = 1; return cnt; } void push_up(int p) { s[p].siz = s[s[p].l].siz + s[s[p].r].siz + 1; } void split(int p, int val, int&amp; x, int&amp; y) { if (!p) { x = y = 0; return; } if (s[p].val &lt;= val) s[++cnt] = s[p], x = cnt, split(s[x].r, val, s[x].r, y), push_up(x); else s[++cnt] = s[p], y = cnt, split(s[y].l, val, x, s[y].l), push_up(y); } int merge(int x, int y) { if (!x || !y) return x + y; int p = ++cnt; if (s[x].key &gt; s[y].key) s[p] = s[x], s[p].r = merge(s[p].r, y); else s[p] = s[y], s[p].l = merge(x, s[p].l); push_up(p); return p; } void insert(int&amp; p, int val) { split(p, val, pre, nxt), p = merge(pre, merge(newnode(val), nxt)); } void remove(int&amp; p, int val) { split(p, val, pre, nxt), split(pre, val - 1, pre, now); now = merge(s[now].l, s[now].r), p = merge(merge(pre, now), nxt); } int queryrnk(int p, int val) { split(p, val - 1, pre, nxt); int res = s[pre].siz + 1 - 1; p = merge(pre, nxt); return res; } int querykth(int p, int k) { while (p) { if (s[s[p].l].siz + 1 == k) return s[p].val; if (s[s[p].l].siz &gt;= k) { p = s[p].l; continue; } k -= s[s[p].l].siz + 1, p = s[p].r; } } int querypre(int p, int val) { split(p, val - 1, pre, nxt); int res = querykth(pre, s[pre].siz); p = merge(pre, nxt); return res; } int querynxt(int p, int val) { split(p, val, pre, nxt); int res = querykth(nxt, 1); p = merge(pre, nxt); return res; }} treap;","link":"/2022/03/02/2022-03-02-%E3%80%8CNote%E3%80%8D%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E5%85%A8%E5%AE%B6%E6%A1%B6/"},{"title":"「Solution」棘手的操作 题解","text":"关于我不会可并堆这个事。 $\\mathcal{Link}$link $\\mathcal{Sol}$两个 $log$ 的线段树合并应该都会，我就不说了。这个做法的瓶颈在于合并过慢，考虑把它办了。希望是不合并，把每个连通块搞到一段连续的区间里，以降低复杂度。发现只有合并操作，不用考虑分割，貌似这个思路是对的。继续想，把所有的联通块都可以挤扁成链，如图：当两个联通块中有两点相连时，可以等价地直接把他们首尾相接。那么可以先把操作离线下来，把所有的合并操作先做一遍，并记录每个操作后，被操作的连通块的大小变化，同时把连出来的图存好。跑 dfs ，标上 dfn ，现在图上只有多条单链，可以直接映射到线段树上，就可以把联通块的操作转到区间上。 大约的确是没写的太清楚，可以看看加了注释的代码 $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// Maybe it is a LinkQueryTree...#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 3e5 + 5;const int INF = 0x3f3f3f3f;int n, m, a[MAXN], dfn[MAXN], redfn[MAXN], tot;struct Question { int opt, u, v; } que[MAXN];vector&lt;int&gt; G[MAXN];vector&lt;int&gt; len[MAXN];struct UnionFindSet { int fa[MAXN], siz[MAXN], tail[MAXN]; void init() { for (int i = 1; i &lt;= n; i++) { len[i].clear(); G[i].clear(); fa[i] = tail[i] = i, siz[i] = 1, len[i].push_back(1); } } int FindSet(int v) { if (fa[v] == v) return v; else return fa[v] = FindSet(fa[v]); } void UnionSet(int u, int v) { int x = FindSet(u); int y = FindSet(v); if (x == y) return; if (siz[x] &lt; siz[y]) swap(x, y); // 启发式 fa[y] = tail[x]; // 将小块的头接到大块的尾 G[tail[x]].push_back(y); // 大块的尾箱小块的头连边，把两条链拼一起 tail[x] = tail[y]; // 更新链尾 siz[x] += siz[y]; // 更新大小 len[x].push_back(siz[x]); // 记录每个版本的链长 }} dsu;void dfs(int u) { dfn[u] = ++tot, redfn[tot] = u; // 双向映射 for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; dfs(v); }}struct SegmentTree { // 这个就是一个区修区查线段树 struct Node { int l, r, dat, tag; } s[MAXN &lt;&lt; 2]; void push_up(int p) { s[p].dat = max(s[p &lt;&lt; 1].dat, s[p &lt;&lt; 1 | 1].dat); } void push_down(int p) { if (!s[p].tag) return; s[p &lt;&lt; 1].tag += s[p].tag; s[p &lt;&lt; 1 | 1].tag += s[p].tag; s[p &lt;&lt; 1].dat += s[p].tag; s[p &lt;&lt; 1 | 1].dat += s[p].tag; s[p].tag = 0; } void build(int p, int l, int r) { s[p].l = l, s[p].r = r; if (l == r) { s[p].dat = a[redfn[l]]; return; } int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid), build(p &lt;&lt; 1 | 1, mid + 1, r); push_up(p); } void update(int p, int l, int r, int val) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) { s[p].dat += val; s[p].tag += val; return; } push_down(p); int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (l &lt;= mid) update(p &lt;&lt; 1, l, r, val); if (r &gt; mid) update(p &lt;&lt; 1 | 1, l, r, val); push_up(p); } int query(int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].dat; push_down(p); int mid = (s[p].l + s[p].r) &gt;&gt; 1, res = -INF; if (l &lt;= mid) res = max(res, query(p &lt;&lt; 1, l, r)); if (r &gt; mid) res = max(res, query(p &lt;&lt; 1 | 1, l, r)); return res; }} seg;int main() { // freopen(&quot;kittle.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;kittle.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); scanf(&quot;%d&quot;, &amp;m); for (int i = 1, u, v; i &lt;= m; i++) { char opt[3]; scanf(&quot;%s&quot;, opt); if (opt[0] == 'U') { scanf(&quot;%d %d&quot;, &amp;u, &amp;v), que[i] = Question{0, u, v}; } else if (opt[0] == 'A') { if (opt[1] == '1') scanf(&quot;%d %d&quot;, &amp;u, &amp;v), que[i] = Question{1, u, v}; else if (opt[1] == '2') scanf(&quot;%d %d&quot;, &amp;u, &amp;v), que[i] = Question{2, u, v}; else scanf(&quot;%d&quot;, &amp;v), que[i] = Question{3, 0, v}; } else { if (opt[1] == '1') scanf(&quot;%d&quot;, &amp;u), que[i] = Question{4, u, 0}; else if (opt[1] == '2') scanf(&quot;%d&quot;, &amp;u), que[i] = Question{5, u, 0}; else que[i] = Question{6, 0, 0}; } } // 离线下来，连一遍图 dsu.init(); for (int i = 1; i &lt;= m; i++) if (que[i].opt == 0) { dsu.UnionSet(que[i].u, que[i].v); } // 建立映射 for (int i = 1; i &lt;= n; i++) if (dsu.FindSet(i) == i) { // 对于每条链，从链头开始标 dfn dfs(i); } // for (int i = 1; i &lt;= n; i++) { // printf(&quot;%d &quot;, dfn[i]); // } // printf(&quot;\\n&quot;); // for (int i = 1; i &lt;= n; i++) { // printf(&quot;%d &quot;, redfn[i]); // } // printf(&quot;\\n&quot;); seg.build(1, 1, n), dsu.init(); // 这里又把 dsu 清空一遍，边操作边更新，保证 dsu 和当前图的一致性 for (int i = 1, res; i &lt;= m; i++) { if (que[i].opt == 0) { dsu.UnionSet(que[i].u, que[i].v); } else if (que[i].opt == 1) { seg.update(1, dfn[que[i].u], dfn[que[i].u], que[i].v); } else if (que[i].opt == 2) { // 现在这个联通块对应的区间就是 [dfn[now], dfn[now] + len - 1] int now = dsu.FindSet(que[i].u); seg.update(1, dfn[now], dfn[now] + len[now][len[now].size() - 1] - 1, que[i].v); } else if (que[i].opt == 3) { seg.update(1, 1, n, que[i].v); } else if (que[i].opt == 4) { res = seg.query(1, dfn[que[i].u], dfn[que[i].u]); printf(&quot;%d\\n&quot;, res); } else if (que[i].opt == 5) { int now = dsu.FindSet(que[i].u); res = seg.query(1, dfn[now], dfn[now] + len[now][len[now].size() - 1] - 1); printf(&quot;%d\\n&quot;, res); } else { res = seg.query(1, 1, n); printf(&quot;%d\\n&quot;, res); } /* for (int j = 1; j &lt;= n; j++) { printf(&quot;%d &quot;, seg.query(1, dfn[j], dfn[j])); } printf(&quot;\\n&quot;); */ } return 0;}","link":"/2022/03/29/2022-03-29-%E3%80%8CSolution%E3%80%8D%E6%A3%98%E6%89%8B%E7%9A%84%E6%93%8D%E4%BD%9C%20%E9%A2%98%E8%A7%A3/"},{"title":"「Solution」2022-04-09-CQ2008 &amp; ZJ2009踩坑祭","text":"属于是把能踩的坑都跳了一遍。。。 位统计$\\mathcal{Link}$link $\\mathcal{Sol}$把所有的操作累到一起。查询的是一段区间。 $\\mathcal{Code}$ bit.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 200005;const int MAXK = 25;const int Mod = 65536;int n, m, d;struct SegmentTree { struct Node { int l, r; int dat; } s[MAXN &lt;&lt; 2]; void build(int p, int l, int r) { s[p].l = l, s[p].r = r; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, mid), build(p &lt;&lt; 1 | 1, mid + 1, r); } void update(int p, int pos) { if (s[p].l == s[p].r) { s[p].dat += 1; return; } int mid = (s[p].l + s[p].r) &gt;&gt; 1; if (pos &lt;= mid) update(p &lt;&lt; 1, pos); else update(p &lt;&lt; 1 | 1, pos); s[p].dat = s[p &lt;&lt; 1].dat + s[p &lt;&lt; 1 | 1].dat; } int query(int p, int l, int r) { if (s[p].l &gt;= l &amp;&amp; s[p].r &lt;= r) return s[p].dat; int mid = (s[p].l + s[p].r) &gt;&gt; 1, res = 0; if (l &lt;= mid) res += query(p &lt;&lt; 1, l, r); if (r &gt; mid) res += query(p &lt;&lt; 1 | 1, l, r); return res; }} seg[MAXK];int main() {// freopen(&quot;bit.in&quot;, &quot;r&quot;, stdin);// freopen(&quot;bit.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt;= 15; i++) seg[i].build(1, 0, Mod); for (int i = 1, x; i &lt;= n; i++) { scanf(&quot;%d&quot;, &amp;x); int num = 0; for (int w = 0; w &lt;= 15; w++) { if ((x &gt;&gt; w) &amp; 1) num |= (1 &lt;&lt; w); seg[w].update(1, num); } } for (int i = 1, add, pos; i &lt;= m; i++) { char opt[2]; scanf(&quot;%s&quot;, opt); if (opt[0] == 'C') { scanf(&quot;%d&quot;, &amp;add); d = (d + add) % Mod; } else { scanf(&quot;%d&quot;, &amp;pos); int l, r, ans = 0; l = (1 &lt;&lt; pos) + (1 &lt;&lt; pos + 1) - (d &amp; ((1 &lt;&lt; pos + 1) - 1)); r = min((1 &lt;&lt; pos + 2) - (d &amp; ((1 &lt;&lt; pos + 1) - 1)), Mod); ans += seg[pos].query(1, l, r); l = (1 &lt;&lt; pos) - (d &amp; ((1 &lt;&lt; pos + 1) - 1)); r = min((1 &lt;&lt; pos + 1) - 1 - (d &amp; ((1 &lt;&lt; pos + 1) - 1)), Mod); ans += seg[pos].query(1, l, r); printf(&quot;%d\\n&quot;, ans); } } return 0;} 矩阵的个数$\\mathcal{Link}$link $\\mathcal{Sol}$看到其实前两行定了，第三行就会固定下来。一个 $n^5$ 的 dp 可以搞定 $\\mathcal{Code}$ matrix.cpp 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long long#define int long longusing namespace std;const int MAXN = 2e2 + 5;const LL Mod = 1e17;int n, a[MAXN], c1, c2, c3;LL dp[MAXN][MAXN][MAXN];signed main() { scanf(&quot;%lld %lld %lld %lld&quot;, &amp;n, &amp;c1, &amp;c2, &amp;c3); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); dp[0][0][0] = 1; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= c1; j++) { for (int k = 0; k &lt;= c2; k++) { for (int x = 0; x &lt;= a[i] &amp;&amp; x + j &lt;= c1; x++) { for (int y = 0; y + k &lt;= c2 &amp;&amp; y + x &lt;= a[i]; y++) { dp[i][j + x][k + y] = (dp[i][j + x][k + y] + dp[i - 1][j][k]) % Mod; } } } } } printf(&quot;%lld\\n&quot;, dp[n][c1][c2]); return 0;} 传感器网络$\\mathcal{Link}$link $\\mathcal{Sol}$醉了，这个东西居然是个暴力 什么神奇题目。以为是个很厉害的构造，结果是网络流跑答案然后暴力连边判断。强烈吐槽诈骗题目。 $\\mathcal{Code}$ net 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 55 * 55;const int INF = 0x3f3f3f3f;int n, l, r, mid, fa[MAXN];char opt[MAXN][MAXN];bool con[MAXN][MAXN];int st, ed, head[MAXN], ver[MAXN], edge[MAXN], nxt[MAXN], tot, d[MAXN], cur[MAXN];queue&lt;int&gt; q;void AddEdge(int u, int v, int c) { // printf(&quot;%d %d %d\\n&quot;, u, v, c); ver[++tot] = v, edge[tot] = c, nxt[tot] = head[u], head[u] = tot; ver[++tot] = u, edge[tot] = 0, nxt[tot] = head[v], head[v] = tot;}bool bfs(int st) { memset(d, 0, sizeof(d)); while (!q.empty()) q.pop(); q.push(st), d[st] = 1, cur[st] = head[st]; while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != 0) continue; q.push(v); cur[v] = head[v]; d[v] = d[u] + 1; if (v == ed) return true; } } return false;}int dinic(int u, int flow) { if (u == ed) return flow; int res = flow, k, i; for (i = cur[u]; i &amp;&amp; res; i = nxt[i]) { int v = ver[i]; if (!edge[i] || d[v] != d[u] + 1) continue; k = dinic(v, min(res, edge[i])); if (k == 0) d[v] = 0; edge[i] -= k, edge[i ^ 1] += k; res -= k; cur[u] = i; } return flow - res;}int ind(int op, int x) { return x + op * n; }bool check(int mid) { memset(head, 0, sizeof(head)); tot = 1; for (int i = 1; i &lt;= n; i++) { AddEdge(st, ind(0, i), 1); if (fa[i]) { if (fa[i] &gt; n) AddEdge(ind(0, i), ed, 1); else AddEdge(ind(0, i), ind(1, fa[i]), 1); } else if (con[0][i]) { AddEdge(i, ed, 1); } else { for (int j = 1; j &lt;= n; j++) if (con[i][j]) { AddEdge(ind(0, i), ind(1, j), 1); } } AddEdge(ind(1, i), ed, mid); } int res = 0, tmp = 0; while (bfs(st)) { while ((tmp = dinic(st, INF))) res += tmp; } // printf(&quot;%d %d\\n&quot;, mid, res); return res == n;}int main() { // freopen(&quot;sensor.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;sensor.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); st = (n &lt;&lt; 1) + 1, ed = (n &lt;&lt; 1) + 3; for (int i = 0; i &lt;= n; i++) { scanf(&quot;%s&quot;, opt[i] + 1); for (int j = 1; j &lt;= n; j++) { con[i][j] = (opt[i][j] == 'Y'); } } for (int i = 1; i &lt;= n; i++) con[n + 1][i] = con[0][i]; l = 0, r = n; while (l &lt; r) { mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } for (int i = 1; i &lt;= n; i++) { bool flag = false; for (int j = 1; j &lt;= n; j++) if (con[i][j]) { fa[i] = j; if (check(l)) { flag = true; break; } } if (!flag) printf(&quot;%d &quot;, n), fa[i] = n + 1; else printf(&quot;%d &quot;, fa[i] - 1); } return 0;}","link":"/2022/04/09/2022-04-09-CQ2008%20&%20ZJ2009%E8%B8%A9%E5%9D%91%E7%A5%AD/"},{"title":"「Summary」NOI Online 2022 提高组 瞎搞游记","text":"真·乱搞 $\\mathbb{丹钓战}$$\\mathcal{Link}$link $\\mathcal{Sol}$没啥好说的。先按照题意模拟一遍《丹钓战》，然后你可记录在未插入当前点时栈顶点的下标，作为当前点的权值。对于查询 [l, r] ，就是找 [l, r] 内权值 &lt;l 的点的个数。 $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5e5 + 5;const int MAXLOG = 55;inline void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}inline void write(int x) { if (x &lt; 0) { putchar('-'); x = -x; } if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');}int n, m, tp, pre[MAXN];struct Position { int a, b, ind; } pos[MAXN], st[MAXN];struct PresidentTree { int tot, root[MAXN]; struct Node { int lch, rch, dat; } s[MAXN * MAXLOG]; void push_up(int p) { s[p].dat = s[s[p].lch].dat + s[s[p].rch].dat; } void update(int&amp; p, int l, int r, int pos, int val) { s[++tot] = s[p], p = tot; if (l == r) { s[p].dat += val; return; } int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(s[p].lch, l, mid, pos, val); else update(s[p].rch, mid + 1, r, pos, val); push_up(p); } int query(int p, int l, int r, int ql, int qr) { if (l &gt;= ql &amp;&amp; r &lt;= qr) return s[p].dat; int mid = (l + r) &gt;&gt; 1, res = 0; if (ql &lt;= mid) res += query(s[p].lch, l, mid, ql, qr); if (qr &gt; mid) res += query(s[p].rch, mid + 1, r, ql, qr); return res; }} pret;int main() { freopen(&quot;stack.in&quot;, &quot;r&quot;, stdin); freopen(&quot;stack.out&quot;, &quot;w&quot;, stdout); // scanf(&quot;%d %d&quot;, &amp;n, &amp;m); read(n), read(m); for (int i = 1; i &lt;= n; i++) { // scanf(&quot;%d&quot;, &amp;pos[i].a); read(pos[i].a); } for (int i = 1; i &lt;= n; i++) { // scanf(&quot;%d&quot;, &amp;pos[i].b); read(pos[i].b); } // int tot = 0; for (int i = 1; i &lt;= n; i++) { pos[i].ind = i; while (tp &amp;&amp; (st[tp].a == pos[i].a || st[tp].b &lt;= pos[i].b)) tp--; pre[i] = st[tp].ind; st[++tp] = pos[i]; // if (tp == 1) { // tot++; // } // printf(&quot;%d &quot;, tot); } // for (int i = 1; i &lt;= n; i++) { // printf(&quot;%d &quot;, pre[i]); // } for (int i = 1; i &lt;= n; i++) pret.update(pret.root[i] = pret.root[i - 1], 0, n, pre[i], 1); for (int i = 1, l, r; i &lt;= m; i++) { // scanf(&quot;%d %d&quot;, &amp;l, &amp;r); read(l), read(r); int tmp = pret.query(pret.root[r], 0, n, 0, l - 1) - pret.query(pret.root[l - 1], 0, n, 0, l - 1); // printf(&quot;%d\\n&quot;, tmp); write(tmp), putchar('\\n'); } return 0;} $\\mathbb{讨论}$$\\mathcal{Link}$link $\\mathcal{Sol}$写了个神奇暴力在洛谷过了。。。大约的确出题人应该不会想到我这个做法，但愿卡不掉吧。。。 思路很简单，对于每个人和他会做的题目连边，依次遍历每个人和他会做的每一道题，找到另外会做这道题的人，把他的贡献值加一， 在一个人遍历完之后查看有贡献的人，如果他的贡献值比双方会做的题数都要少，那么两个人就可以讨论。如果，这个人找不到讨论对象，就可以把连向他的所有边删掉。找到就直接输出。 其实可以把这个做法卡到 $\\mathcal{O(n^2)}$ 。但是我觉得出题人不会这样造数据。 /xyx update: 嘤嘤嘤，被卡成了 $70pts$ (2022-03-30) $\\mathcal{Code}$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 5e6 + 5;inline void read(int&amp; x) { x = 0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') f = -f; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') { x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); c = getchar(); } x *= f;}inline void write(int x) { if (x &lt; 0) { putchar('-'); x = -x; } if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');}int t, n, tot[MAXN], cnt[MAXN], ans1, ans2;vector&lt;int&gt; G[MAXN], pos;int main() { freopen(&quot;discuss.in&quot;, &quot;r&quot;, stdin); freopen(&quot;discuss.out&quot;, &quot;w&quot;, stdout); // scanf(&quot;%d&quot;, &amp;t); read(t); while (t--) { // scanf(&quot;%d&quot;, &amp;n); read(n); // printf(&quot;!!%d!!\\n&quot;, n); ans1 = ans2 = 0; for (int i = 1; i &lt;= 2 * n; i++) G[i].clear(); for (int i = 1, k; i &lt;= n; i++) { // scanf(&quot;%d&quot;, &amp;k); read(k); cnt[i] = k; for (int j = 1, x; j &lt;= k; j++) { // scanf(&quot;%d&quot;, &amp;x); read(x); G[i].push_back(x + n); G[x + n].push_back(i); } } bool flag = false; for (int i = n; i &gt;= 1; i--) { pos.clear(); for (int j = 0; j &lt; G[i].size(); j++) { int u = G[i][j]; G[u].pop_back(); for (int k = 0; k &lt; G[u].size(); k++) { int v = G[u][k]; tot[v]++; if (tot[v] == 1) pos.push_back(v); } } for (int j = 0; j &lt; pos.size(); j++) { if (tot[pos[j]] &lt; cnt[pos[j]] &amp;&amp; tot[pos[j]] &lt; cnt[i]) { // printf(&quot;%d %d %d\\n&quot;, tot[pos[j]], cnt[pos[j]], cnt[i]); ans1 = i, ans2 = pos[j]; flag = true; break; } } for (int j = 0; j &lt; pos.size(); j++) tot[pos[j]] = 0; if (flag) { break; } } if (flag) { printf(&quot;YES\\n%d %d\\n&quot;, ans1, ans2); } else { printf(&quot;NO\\n&quot;); } } return 0;} $\\mathbb{如何正确地排序}$$\\mathcal{Link}$link $\\mathcal{Sol}$不会了。 $\\mathcal{Code}$","link":"/2022/03/26/2022-03-28-%E3%80%8CSummary%E3%80%8DNOI%20Online%202022%20%E6%8F%90%E9%AB%98%E7%BB%84%20%E7%9E%8E%E6%90%9E%E6%B8%B8%E8%AE%B0/"},{"title":"2022-04-13-HNOI2012 题解集合","text":"蔬菜越来越多。 与非$\\mathcal{Link}$link $\\mathcal{Sol}$记录一个常见（？）技巧。当题目给定一个位运算操作时，先从每个数位入手，只考虑四种情况。再看这个位运算操作是否可以推广。 拿这道题举例。 $$not (A) = A \\ nand \\ A \\A \\ or \\ B = not(not(A) \\ nand \\ not(B)) \\A \\ and \\ B = not(A \\ nand \\ B) \\A \\ xor \\ B = not(not(A) \\ and \\ not(B) \\ or \\ (A \\ and \\ B))$$ 就是说，只要有 nand 操作，你就可以把所有的操作全部表示出来。 $\\mathcal{Code}$ nand.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 1e7 + 5;LL n, k;LL l, r, a[MAXN], b[MAXN], num[MAXN], ans;LL query(LL x) { LL res = 0; if (x &gt;= ((1ll &lt;&lt; k) - 1)) return 1ll &lt;&lt; num[k - 1]; for (int i = k - 1; i &gt;= 0 &amp;&amp; x &gt;= 0; i--) { if ((x &gt;&gt; i) &amp; 1) { if (b[i]) { res = (res + (1ll &lt;&lt; num[i] - 1)); x -= b[i]; // printf(&quot;--%lld %lld %lld\\n&quot;, res, 1ll &lt;&lt; num[i] - 1, b[i]); } else { res = (res + (1ll &lt;&lt; num[i])); break; } } } res += (x == 0); return res;}int main() { // freopen(&quot;nand.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;nand.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%lld %lld %lld %lld&quot;, &amp;n, &amp;k, &amp;l, &amp;r); for (int i = 1; i &lt;= n; i++) scanf(&quot;%lld&quot;, &amp;a[i]); LL statment = 0; for (int i = k - 1; i &gt;= 0; i--) if (!((statment &gt;&gt; i) &amp; 1)) { LL tmp = (1ll &lt;&lt; k) - 1; for (int j = 1; j &lt;= n; j++) if ((a[j] &gt;&gt; i) &amp; 1) { tmp &amp;= a[j]; } else tmp &amp;= (~a[j]); b[i] = tmp; num[i] = 1; statment |= tmp; } for (int i = 1; i &lt; k; i++) num[i] += num[i - 1]; printf(&quot;%lld\\n&quot;, query(r) - query(l - 1)); return 0;} 集合选数$\\mathcal{Sol}$属于神仙构造了。考试时想到了要把建树，但是没把树拍扁。 首先一个 树形DP 的感觉不难得到。然后构造如下的矩阵。 $$1 \\ 2 \\ 4 \\ 8 \\ 16 \\ 32 \\ 64 \\dots \\3 \\ 6 \\ 12 \\ 24 \\ 48 \\ 96 \\ 192 \\ 384 \\dots \\9 \\ 18 \\ 36 \\ 72 \\ 144 \\ 288 \\ 576 \\ 1152 \\dots \\$$ 形式化一点就是 $a_{i, j}=\\left{\\begin{matrix} a_{i - 1, j} \\times 3, j = 1 \\ a_{i, j - 1} \\times 2, j \\not= 1 \\end{matrix}\\right.$ 矩阵很小，可以状压。 $\\mathcal{Code}$ set.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;const int MAXN = 15;const int MAXM = 20;const int Mod = 1e9 + 1;int n, r, c[MAXM], mat[MAXN][MAXM];bool vis[(1 &lt;&lt; MAXM) + 5], used[(1 &lt;&lt; MAXM) + 5];LL dp[MAXN][(1 &lt;&lt; MAXM) + 5], ans;LL cal(int s) { mat[1][1] = s; used[s] = 1; for (int i = 2; i &lt;= 12; i++) { mat[i][1] = mat[i - 1][1] * 3; if (mat[i][1] &gt; n) { r = i - 1; break; } used[mat[i][1]] = 1; } for (int i = 1; i &lt;= r; i++) { for (int j = 2; j &lt;= 18; j++) { mat[i][j] = mat[i][j - 1] * 2; if (mat[i][j] &gt; n) { c[i] = j - 1; break; } used[mat[i][j]] = 1; } } for (int i = 0; i &lt; (1 &lt;&lt; c[1]); i++) dp[1][i] = vis[i]; for (int i = 2; i &lt;= r; i++) { for (int j = 0; j &lt; (1 &lt;&lt; c[i]); j++) if (vis[j]) { dp[i][j] = 0; for (int k = 0; k &lt; (1 &lt;&lt; c[i - 1]); k++) if (vis[k] &amp;&amp; (k &amp; j) == 0) { dp[i][j] = (dp[i - 1][k] + dp[i][j]) % Mod; } } } LL sum = 0; for (int i = 0; i &lt; (1 &lt;&lt; c[r]); i++) sum = (sum + dp[r][i]) % Mod; return sum;}int main() { // freopen(&quot;set.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;set.out&quot;, &quot;w&quot;, stdout); scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; (1 &lt;&lt; MAXM - 2); i++) if (!((i &lt;&lt; 1) &amp; i)) vis[i] = 1; ans = 1; for (int i = 1; i &lt;= n; i++) if (!used[i]) ans = (ans * cal(i)) % Mod; printf(&quot;%lld\\n&quot;, ans); return 0;}","link":"/2022/04/13/2022-04-13-HNOI2012%20%E9%A2%98%E8%A7%A3%E9%9B%86%E5%90%88/"},{"title":"「Solution」2022-05-04-构造题入坑","text":"被小学生题目羞辱了。。。 Engineer ArtemLinklink Soldouble - 奇偶性 处理。 只要保证了相邻数字奇偶性不同就行了。 Code Engineer Artem 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1e2 + 5;int t, n, m;int main() { scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) { for (int j = 1, x; j &lt;= m; j++) { scanf(&quot;%d&quot;, &amp;x); if (((i + j) &amp; 1) == (x &amp; 1)) x++; printf(&quot;%d &quot;, x); } printf(&quot;\\n&quot;); } } return 0;} XOR-gunLinklink","link":"/2022/05/04/2022-05-04-%E6%9E%84%E9%80%A0%E9%A2%98%E5%85%A5%E5%9D%91/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"逆序对","slug":"逆序对","link":"/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"区间DP","slug":"区间DP","link":"/tags/%E5%8C%BA%E9%97%B4DP/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"实用技巧","slug":"实用技巧","link":"/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"欧拉回路","slug":"欧拉回路","link":"/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"name":"树的重心","slug":"树的重心","link":"/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"ST表","slug":"ST表","link":"/tags/ST%E8%A1%A8/"},{"name":"考试","slug":"考试","link":"/tags/%E8%80%83%E8%AF%95/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"分层图","slug":"分层图","link":"/tags/%E5%88%86%E5%B1%82%E5%9B%BE/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"总结","slug":"总结","link":"/tags/%E6%80%BB%E7%BB%93/"},{"name":"图论100","slug":"图论100","link":"/tags/%E5%9B%BE%E8%AE%BA100/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"数位DP","slug":"数位DP","link":"/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"动态开点","slug":"动态开点","link":"/tags/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"优化","slug":"优化","link":"/tags/%E4%BC%98%E5%8C%96/"},{"name":"搜索","slug":"搜索","link":"/tags/%E6%90%9C%E7%B4%A2/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"tarjan","slug":"tarjan","link":"/tags/tarjan/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"乱搞","slug":"乱搞","link":"/tags/%E4%B9%B1%E6%90%9E/"},{"name":"treap","slug":"treap","link":"/tags/treap/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"lca","slug":"lca","link":"/tags/lca/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"状压dp","slug":"状压dp","link":"/tags/%E7%8A%B6%E5%8E%8Bdp/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"结论题","slug":"结论题","link":"/tags/%E7%BB%93%E8%AE%BA%E9%A2%98/"},{"name":"review","slug":"review","link":"/tags/review/"},{"name":"容斥原理","slug":"容斥原理","link":"/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最小割","slug":"最小割","link":"/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"图论,二分图","slug":"图论-二分图","link":"/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"图论,二分图,网络流","slug":"图论-二分图-网络流","link":"/tags/%E5%9B%BE%E8%AE%BA-%E4%BA%8C%E5%88%86%E5%9B%BE-%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"图论,网络流","slug":"图论-网络流","link":"/tags/%E5%9B%BE%E8%AE%BA-%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"斜率优化","slug":"斜率优化","link":"/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"决策单调性","slug":"决策单调性","link":"/tags/%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7/"},{"name":"cdq","slug":"cdq","link":"/tags/cdq/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"Dirichlet","slug":"Dirichlet","link":"/tags/Dirichlet/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"平衡树","slug":"平衡树","link":"/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"构造","slug":"构造","link":"/tags/%E6%9E%84%E9%80%A0/"}],"categories":[{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"贪心","slug":"贪心","link":"/categories/%E8%B4%AA%E5%BF%83/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"离散化","slug":"离散化","link":"/categories/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"区间DP","slug":"区间DP","link":"/categories/%E5%8C%BA%E9%97%B4DP/"},{"name":"STL","slug":"STL","link":"/categories/STL/"},{"name":"树","slug":"树","link":"/categories/%E6%A0%91/"},{"name":"RMQ","slug":"RMQ","link":"/categories/RMQ/"},{"name":"考试","slug":"考试","link":"/categories/%E8%80%83%E8%AF%95/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"模板","slug":"模板","link":"/categories/%E6%A8%A1%E6%9D%BF/"},{"name":"逆序对","slug":"逆序对","link":"/categories/%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"name":"游记","slug":"游记","link":"/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"暴力","slug":"暴力","link":"/categories/%E6%9A%B4%E5%8A%9B/"},{"name":"DP","slug":"DP","link":"/categories/DP/"},{"name":"线段树","slug":"线段树","link":"/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"AtCoder","slug":"AtCoder","link":"/categories/AtCoder/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"总结","slug":"总结","link":"/categories/%E6%80%BB%E7%BB%93/"},{"name":"分治","slug":"分治","link":"/categories/%E5%88%86%E6%B2%BB/"},{"name":"treap","slug":"treap","link":"/categories/treap/"},{"name":"位运算","slug":"位运算","link":"/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"dp","slug":"dp","link":"/categories/dp/"},{"name":"review","slug":"review","link":"/categories/review/"},{"name":"网络流","slug":"网络流","link":"/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"}]}